{"title":"Aotu.io","description":"凹凸实验室(Aotu.io) 始建于2015年，是一个年轻基情的技术社区组织。<br/>O2面向多终端技术体系，致力于构建沉淀与分享包括但不限于交互、页面制作技巧、前端开发、原生APP开发等方面的专业知识及案例。","language":"zh-cn","link":"https://aotu.io","pubDate":"Mon, 27 Apr 2020 07:15:08 GMT","lastBuildDate":"Tue, 28 Apr 2020 03:05:36 GMT","generator":"hexo-generator-json-feed","webMaster":"凹凸实验室","items":[{"title":"京东小程序 Taro 开发对比原生开发测评","link":"https://aotu.io/notes/2020/04/27/taro-vs-jd/","description":"Taro 自 1.3.20 版本开始支持转换为京东小程序，受到了很多同学的关注。当中有欢呼雀跃的声音：“一键转换为京东小程序，终于可以准时下班啦”。也有对 Taro 不太了解的同学提出了一些疑问：“转换的效果如何？”、“转换后代码的性能是否达标？”等等。 针对各种疑问，我们从性能与开发体验的角度切入，把京东小程序原生开发与 Taro 开发进行了一番对比。 性能对比针对性能的问题，我们分别测试了 Taro 空项目的包大小和 Taro 在长列表中的表现。因为包大小会影响小程序的首次加载速度，而长列表则是常常出现性能瓶颈的场景。 Taro 空项目包大小目前各小程序都有对主包的大小进行限制，如京东小程序限制为 5M、微信小程序限制为 2M。这是因为初次进入的速度对于用户的体验非常地关键，而主包体积越大下载的时间就最长。因此小程序框架的大小也成为了开发前框架选型的重要参考指标之一，倘若框架体积过大，就会压缩业务逻辑的可用空间。 下列图片分别是 Taro 运行时框架压缩前后的大小，可以看到压缩后仅为84k，对主包空间的影响十分小。 压缩前： 压缩后： 长列表渲染表现benchmark 介绍我们参照 js-framework-benchmark 编写了一份 benchmark，测试对比了 Taro 代码与原生代码在长列表场景下的渲染表现。 测速指标 初始化：从进入页面开始到完成 40 个商品的渲染。 创建：页面 onLoad 后创建 40 个商品。 增加：往已创建了 40 个商品的列表中每次增加 20 个商品。 部分更新：在 400 个商品中更新每第 10 个商品的名称。 交换：在 400 个商品中交换其中两个商品的位置。 选中：点击商品图片，改变商品名称的字体颜色。 计时点Taro： 开始：事件响应函数的顶部。 结束：setState 回调函数的顶部。 原生小程序： 开始：事件响应函数的顶部。 结束：setData 回调函数的顶部。 其它benchmark 仓库：Github Taro 版本：1.3.21 测试机型：魅蓝 note 测试方法：每组测试 10 条数据，去除其中最大值与最小值后求平均值 测试结果因为在京东小程序与微信小程序中，setData 的 callback 的触发时机稍有不同，所以分开列出。 操作 Taro jd 原生京东小程序 初始化 150 123 创建 87 85 部分更新 125 235 交换 140 213 选中 131 155 操作 Taro weapp 原生微信小程序 初始化 1155 1223 创建 500 408 部分更新 167 307 交换 252 309 选中 193 178 经测试发现，列表的长度会对增加操作的耗时产生影响：列表越长，增加操作的耗时越久。因此不能简单地对 N 次增加操作求平均增加耗时。这里我们选择使用折线图来展现出随增加操作次数的变化，渲染耗时的变化趋势。 测试结论创建 在创建时，Taro 会对数据做一些处理，因此会比原生稍慢。 初始化 初始化与创建相比，差别是引入了页面构造耗时。即初始化耗时 = 页面构造耗时 + 创建操作耗时。 Taro 在页面初始化、创建操作时都会对数据进行处理，因此整个初始化耗时会比原生稍慢。 那为什么微信小程序中 Taro 初始化耗时更短呢？在 benchmark 中 Taro 和原生分别在 componentWillMount 和 onLoad 渲染列表，而 Taro 使用 Component 构造页面，componentWillMount 其实是在 attached 生命周期中触发。因为在微信小程序中 attached 比 onLoad 早触发得多，所以会出现如此现象。 选中 因为 Taro 只是把回调函数包装了一层，处理了事件参数和 this 等，所以和原生的速度相当。 部分更新、交换、增加 Taro 的速度会优于原生。原因是 Taro 会先对将要 setData 的数据和当前 data 的数据做一次 diff，这能够大大减少 setData 的数据量，加快渲染速度。对比两个折线图可以得知，数据量越大，diff 的优化收益也越大。 Taro 对小程序的性能优化setData在小程序中，性能的问题主要在于单次 setData 数据量过大和频繁调用 setData 上。Taro 利用 diff 解决了单次 setData 数据量过大的问题，而对于频繁调用 setData 也有解决的办法。 Taro 的 setState 遵循 React 规范，不同于 setData 的同步更新，它会异步地去更新视图。因此假设开发者在单次事件循环中多次调用 setState，最后也只会在下一个事件循环中进行一次 setData。 跳转预加载小程序由 A 页面跳转到 B 页面的过程中，从 A 页面发起跳转到 B 页面触发 onLoad，有着 300~400 毫秒的延时。Taro 提供了 componentWillPreload 钩子，钩子会在发起跳转后立即执行。开发者可以尽早地在钩子里做一些数据拉取的工作，相比在 onLoad 触发后再去拉取数据就能够节省 300~400 毫秒的延时。 shouldComponentUpdate &amp; Taro.PureComponent开发者的 Class Component 可以继承 Taro.PureComponent，这样组件在更新前会对新旧 props 和新旧 state 各做一次浅对比，避免不必要的更新。当然开发者可以自己实现 shouldComponentUpdate，通过手动控制新旧 props 和新旧 state 的对比，决定是否更新组件。 Taro.memo如果开发者书写的是函数式组件，则可以利用 Taro.memo 实现 shouldComponentUpdate 的相同功能。 开发体验对比语法京东小程序的原生语法和微信小程序相仿，都是类 MVVM 语法，没有接触过小程序的开发者有一定学习成本。另外样式语法为 css 的子集，其中自适应尺寸单位为 rpx，这样意味着如果我们需要 css 预处理器时需要手动配置工作流，并且在编写样式时处处注意尺寸单位的转换。 目前 Taro 遵循 React 语法（将来会支持所有 Web 前端框架），JSX 令我们的代码更加灵活。因此拥有 React 开发经验的开发者可以马上上手 Taro 的开发工作。在样式方面 Taro 支持在创建项目时选择是否使用 css 预处理器，选择后会自动配置相应的工作流。对于样式单位 Taro 也会把用户编写的 px 数值自动转换成对应的 rpx 数值，开发者无需再分心处理各平台的样式单位。 项目结构原生开发中，页面和组件各由4个文件（js、jxml、jxss、json）所组成，代码管理相对麻烦。 Taro 中页面和组件均由一份 js 文件和一份样式文件组成，创建与维护十分容易。 开发生态微信小程序经过不断迭代，相继推出了插件系统和支持引用 npm 包的功能。但京东小程序暂不支持前两者，京东小程序社区也还没打造起来，开发生态资源十分匮乏。 Taro 中不但能自由引用 npm 包，而且还大量支持 React 社区中沉淀的优秀工具和库，如 react-redux、mobx-react 等。 开发辅助京东小程序原生开发不支持 Typescript，只能在 IDE 的编辑器中有自动补全功能，编码效率不高，同时也容易出错。 Taro 完美支持 Typescript，自带代码智能提示和代码实时检查功能，能让开发效率大大提升。 写在最后看到这里大家可能会问，Taro 性能真的优于原生吗？其实并不然，针对每个场景，我们都可以用原生写出性能最佳的代码。但是这样做工作量太大，实际项目开发中需要掌握效率与优化之间的平衡。Taro 的优势在于能让我们在书写更有效率的代码、拥有更丰富的生态的同时，还带来了不错的性能。 最后，欢迎大家来使用 Taro 开发各端应用，有任何开发问题欢迎在Taro 论坛 或 GitHub 上和我们交流，我们会第一时间回复。 相关链接 Taro 官方网站 Taro 文档 Taro 论坛","pubDate":"Mon, 27 Apr 2020 07:15:08 GMT","guid":"https://aotu.io/notes/2020/04/27/taro-vs-jd/","category":"Taro"},{"title":"使用 Taro 快速开发京东小程序","link":"https://aotu.io/notes/2020/04/27/taro-build-jd/","description":"近两年来小程序逐渐成为互联网的一个行业风口，一直备受业界关注，各大厂也接踵推出了自己的小程序。近日京东也推出了小程序：京东小程序。Taro 作为一款专注于多端统一开发的框架，第一时间对京东小程序进行了适配。接下来就跟着小编一起了解一下如何使用 Taro 快速开发京东小程序吧。 背景京东小程序京东小程序平台是京东自研技术（能力）开放平台，平台集成京东特色功能，串联商家和用户。为用户提供延展服务，给商家带来新机遇。京东小程序平台不仅支持存量自营、POP商家自动开通，还支持新型的非电商领域商家参与小程序生态。 加入京东小程序开放平台的商家，可以利用京东平台完整的营销、交易、支付、会员、物流等能力，更加便捷地构建起自己的特色服务场景。助力商家实现生态场景上的“跃迁”，快速为用户提供一站式服务体验。 京东小程序只需一次开发即可运行在京东 APP、京东金融 APP、京麦 APP 三端。京东 APP、京东金融 APP 会开放特定的能力，对优质小程序还会开放多个高流量入口，包含扫码、搜索、消息等多种方式触达。而京麦 APP 小程序主要用于商家工具插件的开发定制。 TaroTaro 是凹凸实验室推出的一套遵循 React 语法规范的多端统一开发解决方案，也是京东小程序官方推荐的开发框架。 使用 Taro 开发不但能更规范、更有效率地编码， 畅享 React / Vue 生态的各种工具。更重要的是只需编写一份代码，即可运行在各种平台：京东/微信/百度/支付宝/字节跳动/QQ小程序、快应用、H5、React-Native 等。 如今 Taro 正被广泛用于京东各大业务，例如京东购物（微信）、京喜（微信、H5、RN）、京东好物街（微信、百度、字节跳动）、京东到家（微信、H5）等，在业界也被各大型业务广泛应用，如：58 同城、喜茶、腾讯吐个槽社区等等。 使用 Taro 快速开发京东小程序入驻京东小程序进入京东小程序官网，提交相关信息后完成入驻。 开发1.安装 Taro 的 CLI 工具： 1npm install -g @tarojs/cli 已安装 Taro 的同学请注意更新 Taro 版本，Taro 自 1.3.20 后支持转换京东小程序。 2.使用 CLI 创建项目： 1taro init [projectName] 3.进入项目根目录，使用 CLI 编译项目，根据 Taro 文档 进行开发： 1taro build --type jd [--watch] 4.调试 申请入驻京东小程序成功后，京东小程序会给开发者发放邀请码，同时提供开发者工具下载，下载后可使用开发者工具进行调试。 Taro 已完全适配京东小程序Taro 已 100% 完成了转换京东小程序的工作，全面支持京东小程序的各种特性。 开发中如遇到任何问题或困难，欢迎在 Github Issues、Taro 社区进行反馈，或联系 **taro@jd.com**，我们会尽快给予答复与支持。 示例项目转换效果图小编尝试把 Taro Github 上学习资源中的优秀开源项目：仿严选多端项目 分别转换为微信小程序端和京东小程序端，对比可见转换非常完美，表现效果基本一致。 微信小程序端 京东小程序端 未来规划Taro 团队对于京东小程序是充满期待和信心的。为此我们讨论并规划了一系列工作，由底层框架适配，到辅助业务落地、拓展京东小程序生态，再到京东小程序的可视化自助搭建等，目前已经完成物料市场的部分物料适配验证并标记支持京东小程序、体验可视化自助搭建请点击这个链接按照指引申请体验权限。 期待大家参与共建有任何意见建议、业务支持、合作诉求的，尽请发送邮件到 **taro@jd.com**，我们会第一时间回复。 心动不如行动，现在就开始使用 Taro 开发你的京东小程序吧～ 了解更多关于京东小程序《京东小程序平台，他来了》","pubDate":"Mon, 27 Apr 2020 06:55:08 GMT","guid":"https://aotu.io/notes/2020/04/27/taro-build-jd/","category":"Taro"},{"title":"Atom 服务架构演变","link":"https://aotu.io/notes/2020/04/21/atom-services-upgrade/","description":"Atom 是什么？Atom 是集结业内各色资深电商行业设计师，提供一站式专业智能页面和小程序设计服务的平台。经过 2 年紧凑迭代，项目越来越庞大，需求不断变更优化，内部逻辑错综复杂，维护成本急剧拉升。同时，Atom 将要承载的业务越来越多，要向更多的内部用户和商家提供服务，为了适应这些变化，架构升级成为当时紧迫的事项，我们将解构服务端模块，让服务轻量化、模块化，更便捷地拓展业务场景。 Atom 服务端经历了三个版本的迭代，本文着重剖析第三个版本。 架构 1.0这是 Atom 最古老的一个版本，在这一版本中，只规划了频道页的功能，目的是把开发人员从繁复的频道页开发中解放出来，因为功能目的纯粹，所以系统复杂度较低，服务端直接使用了 Koa 框架上手开发，这是一个单体架构的服务，所有的代码都在一个进程中运行。 在部署方面，运用的是非常原始的手工操作：开发人员登入机器，拉取代码后进行类似本地环境的安装启动，然后在不同机器重复这个过程。 另外，Quark 的旧版本使用的是具名组件，具名组件一定程度限制了 Quark 自身的扩展性，这里不作展开。 架构 2.0从频道页搭建平台到多场景页面搭建平台，Atom 用了不到一年时间，更丰富的组件，更多的模板，更多的场景，更多参与进来的设计师，更多的用户，产品开发逐渐专业化，简单的手工运维已经不再适用，于是前端和服务端都进行了一次大换血，服务端用 Salak 重构，Salak 是个非常好上手的服务端框架，同时为我们带来了接口文档的自动化生成功能，前端和服务端都改为依靠 Talos（一容器式部署内部平台）来部署。服务端逐渐迈入工业时代。 然而，这个阶段仍然没解决粗放的开发方式，缺乏宏观上的规划，日益暴露了以下这些问题： 高度集中 90% 以上服务集中于一个单体架构中，业务越来越复杂，代码量越来越大，代码的可读性、可维护性和可扩展性下降，开发人员接入成本剧增，业务扩展的代价成指数上升，持续交付能力难以维持。随着用户越来越多，程序承受的并发越来越高，单体架构的应用的并发能力有限。由于系统复杂度的提高，测试的难度也越来越大。 耦合度高 单体中的各个模块间互相依赖，互相影响，互相掣肘，导致代码重用性低，新功能开发往往由于忌惮耦合逻辑中的隐藏彩蛋，而选择重新编写，这不是我们希望看到的！ 逻辑混乱 除了耦合导致的逻辑混乱，Atom 作为一个从零成长起来的平台，本身就淤积了大量的历史需求，有些是不再使用的，有些是几乎不被使用的，这些代码逻辑给开发人员一个极大的挑战：在进行代码维护的时候不敢轻易改动代码。另外在迭代中需要向下兼容，让服务端有沉重的历史包袱。 代码冗余 由于框架在前期没有定义好规范标准，在开发过程比较严格遵守代码校验，代码的逻辑、常量等等重复定义，这也同时让项目变得难以维护，比如修改一个常量需要在保证没有遗漏的前提同时修改多处。 新架构目标根据原有架构的优劣，我们设置了本次架构升级的目标： 服务模块化 服务通用化 插拔式站点 插拔式场景 标准与规范 名词解释： 站点：即把服务端与平台解耦，从原来的服务即平台，到可以为互相隔离的多个平台提供相同的服务。 场景：为应对不同业务类型而设定的概念，不同场景有不同的管理方式和流程等。 整体架构整体架构分为 Web 应用层、接口层、服务层 和 数据层 4 部分，这样拆分能做到入口统一，在部署上的单点部署让发布更加的便捷，独立部署则降低对服务整体的影响： Web 应用层：包括 Atom 平台及其他的平台应用 接口层：提供网关服务，应用层的请求经由网关作权限控制及请求转发 服务层： 服务通信：异步通信使用 MQ，RPC 通信使用 HTTP 业务模块：核心代码，拆解众多小模块应用 基础服务：统一把控用户与权限 服务管理：提升服务的稳定性、健壮性、灵活性 数据层：核心数据存储 其中网关作为整个服务端的流量入口，对所有流量进行处理，拦截非法请求，解析登录态并传递到下游，校验接口权限以及超时响应等，统一把控，同时减轻下游的压力。 实施计划/筹备/评估在正式进入升级开发前，小组通过会议探讨架构升级的必要性和可行性，促使我们进行升级的直接原因是平台新增的站点需求和场景需求，如要在原有架构上实现这个需求，势必会在原已混乱的逻辑上增添更多的耦合逻辑，而间接原因，亦即升级必要性，则是要让系统模块化、标准化、通用化，让系统的逻辑更加清晰，提升整个系统的可维护性。 经过我们反复的探讨，对原系统按照功能进行分割，在功能的基础上再按照通用性进行进一步拆分，附加新架构的支撑性工作，评估这些工作的工作量和预计用时，最后对任务进行分配下达。 实施模块化为什么要模块化？随着平台越做越大，我们想要让各个部分的功能更加独立、明确、清晰，把各部分之间的影响降到最低，对各部分单独运维，避免牵一发而动全身的情况。 这次升级按照功能和通用性把项目划分为 10+ 个模块：如专门负责编译的模块，专门负责模板管理的模块，负责定时任务的模块，作为入口的网关等等。 其中拆分出来若干通用服务，通用服务作为独立于 Atom 系统之外的服务，可以为 Atom 以及其他系统提供服务。 对项目进行模块拆解，最为头疼的是斩断关联逻辑，模块的剥离和修复必然会导致一个问题——相同的代码在不同的模块重复出现。为了解决这个问题，我们把部分这些代码放到工具 npm 包中，这些代码包括了：常量、TypeScript 类型定义、权限映射、Mongoose Schema 定义、Salak 插件和工具方法等等。 另一个问题，在原架构中，模块间可以通过代码直接调用，那新架构中如何“还原”这个功能？为了保证解耦度，新架构中仅有少数需要即时调用的功能在模块间通过接口进行直接调用，其他的都是通过 MQ 消息队列和数据库进行互通。 对于 MQ 通信，这里举个例子：编译。服务端编译通常需要的时间比较长，长时间占用连接对服务性能有所影响，而且编译结果并不需要同步响应，对编译模块来说，如果来者不拒，对服务有不小的压力，于是我们决定使用消息队列来完成各个模块之间的通信： 由项目模块通过接口直接调用发布模块发起发布操作； 发布模块向消息池推送一条“我要编译”； 编译模块接收到消息后由自身情况判断是否可以进入编译，否则先不予以响应； 编译的各个状态也通过消息推送； 最后项目模块在接收到编译状态的消息后作各种处理。 通用化前面提到在模块化的工作中，我们拆出了 4 个通用的服务模块，通用服务独立于 Atom 系统之外，可以为 Atom 以及其他系统提供服务。模块的通用化是出于两点考虑： 丰富部门的服务，减少重复开发功能 排除 Atom 非核心代码，让系统瘦身 伴随而来的一个问题值得我们思考，如何考量一个功能是否值得抽离通用化？我们应该尽量避免陷入一个误区：系统模块化就是把系统拆得越细越好。如果拆分过细，势必增加运维工作量。在拆分模块的时候，我们考量的是一个模块内的功能是否完整且独立，以及部门或公司对这个通用服务的需求度，真正地做到低耦合高内聚。 标准化代码层面，下面做了个简单的对比： 对比项 旧架构 新架构 主要语言 JavaScript TypeScript 代码检测 未遵守 必需 接口名称 花样百出 统一形式 接口输出 百花齐放 统一形式 TypeScript 的好，前端人都知道，它为我们带来了自动补全、可选的类型系统，使我们能够用上更加新的 JavaScript 特性等等，更多可以参考《为什么选择 TypeScript》。出现后面三点的原因是什么？旧架构经历了从零到一的过程，项目在最初规划欠缺以及中后期没有足够的时间对系统进行修正，时间和需求的变更的双重作用导致代码淤积。 为此，我们在新架构的开发中就强调代码的标准化，对每次提交都要经过代码检测，然后是对五花八门的接口进行统一： 接口路径统一：旧架构中，一个列表接口的路径可能是 /xxx/list，也可能是 /xxx/xxxes 等等，我们在新架构中基于 RESTful API 规则，用资源名词组成的路径和语义化的 HTTP 协议统一接口的定义； 参数名统一：比如列表入参中每页数量可能叫 pageSize 也可能叫 count，于是我们把它统一成一个名字，要求在开发中遵守这个约定； 输出统一：在数据输出到前端前对数据进行处理筛选，剔除包括 _id 和 __v 等无关数据，在输出形式上也做了统一，要求输出中所有的 _id 都替换以 id 的名字出现等等。 代码标准化的好处是让代码更加好维护，开发人员很快就能定位到对应的接口代码，对前端而言则减少对接口的识别记忆。 插拔式站点前面提到，这次架构升级的直接原因是站点需求和场景需求。如果在旧架构下迭代站点需求，只会进一步增加耦合度。为此，我们增加了站点管理模块，在几乎所有的数据项中增加了站点字段，给几乎所有的数据库查询都带上了站点参数。通过这些努力，现在新增站点只需要通过站点模块新增站点，再做一些初始化配置即可完成。 站点概念除对 Atom 功能有了更高要求，也对原来的权限体系形成了新的挑战。在升级前的版本中用户的权限仅有一个集合，要实现每个站点拥有不同的权限只能从两个角度出发： 权限含义拆分（为每个站点分别提供一套独立的权限） 用户权限增加一层抽象（用户的权限改变为多个集合根据站点进行切换） 在比较了两种修改形式后，拆分权限含义虽然在理解上比较容易代码也改动不多。但却大大提升了维护权限表的难度，相当于新增场景就需要增加一套权限，无法做到可插拔。最后在网关层增加了根据用户访问站点切换权限集合的逻辑。 插拔式场景场景是站点下面一个纬度，现有活动、频道、心理学测试、SNS、店铺几大场景，如果在旧架构下新增一个场景，需要排期进行开发，而且代码上恐怕也会增加不少针对不同场景的 if-else。为了更便捷省心地扩展和维护场景，我们对场景相关的代码从资源管理的角度做了拆解。 ATOM下每个场景拥有的资源主要有 模板/项目/标签/权限 四种： 12345标签 页面 | |模板------&gt;项目权限 首先介绍项目模块目录的结构，项目模块的代码基于 策略模式 组织，每个场景的业务逻辑拆分到单独文件，由调度器直接调用，避免不同场景间逻辑掺杂。 调度器文件命名为 base_资源_service 场景策略文件命名为 场景小写_资源_service 通用策略文件命名为 common_资源_service 当用户查询进来时，调度器根据查询的条件直接调用对应策略文件中的方法（一般不允许直接调用指定场景的策略除非确认不会关联到其他场景的数据），当调度器没有没有找到对应场景下的策略时，默认会调用 common_service 的逻辑，所以各场景需要继承 common_service。以页面管理服务为例，调度器为 src/service/page 目录下的 base_page_service，通用逻辑为 common_page_service，频道页场景逻辑为 ch_page_service。 出于对场景下公有方法的统一抽象，服务中常用的 CRUD 方法接口 放置在 AbstractServiceClass 文件中 123456├── src│ ├── service│ │ └── &#123;resource&#125;│ │ ├── base_&#123;resource&#125;_service 策略文件调用器,controller/mq 直接调用│ │ ├── common_&#123;resource&#125;_service 通用策略文件，例如列表查询共用的参数处理│ │ └── &#123;scene&#125;_&#123;resource&#125;_service 场景策略文件，场景特殊的 部署数据迁移鉴于这次升级的巨变，在新旧版本间的切换务必慎重，除了前端与服务端为此做的大量的联调外，我们还对数据进行了兼容性迁移，主要做法是通过迁移脚本把旧数据根据新架构的需要做多重处理，尔后写入新数据库中。 不中断部署在单体架构中，每一次服务的发布部署都会造成几分钟的空窗。 为避免这种情况，在生产环境，我们保证每个模块至少拥有两个容器，在部署的时候，把部分容器从负载均衡摘除，然后循环检测容器是否还有流量，直至没有流量进来才进行更新操作，服务启动后重新添加到负载均衡，然后对剩下的容器进行同样的操作，这样做的好处是，保证了整个部署过程，服务是不中断的，避免了部署过程中的空档情况。 运维为避免再重蹈旧架构下糟糕的运维体验及项目代码管理，我们为新架构梳理了一个运维文档，包括快速接入、开发、调试、部署方方面面的细节都尽可能详尽地记录下来。 为系统增加了监控，监控每个接口的性能和可用性。 效果经过这次升级，基本达成计划中的效果： 清晰：逻辑梳理、去除冗余、TS 重构、ESNext 模块化：解耦 10+ 模块，独立运作；HTTP、MQ、数据层等多通信方式 标准化：强代码规范；接口统一；响应统一 通用化：4+ 通用模块，平台无关；抽取公共库、配置、插件、中间件等 易迁移：一键初始化；一键、单点、独立部署；入口统一 易扩展：+新增站点拓展能力；调整场景拓展；节省人力时间成本 95%+ 易维护：追加日志；一键部署；不中断部署 易对接：完备的 Joi 文档；详尽的接口变更记录；尽可能的向上兼容 工具/方法/协作工具对项目的顺利进行有非常重要的影响，因此在这次升级中，我们尝试了多种工具。 为了保证项目成员对自己负责模块有清晰的了解以及对模块的改造有明确的图样，团队引入流程图工具用于梳理旧架构的模块并分工，梳理勾画新架构各个模块内部的逻辑等等。 在排期方面，我们实践使用到了甘特图，用甘特图按照模块对任务进行拆分，然后指派给对应的负责人并设置计划的进行时间，每天同步整体的进度，从甘特图可以清晰地了解项目的资源分配与排期，也能看到项目计划与实际的对照，有助于项目整体的进度把控。 甘特图对项目升级的任务进行了初步的划分，对于更细化的划分，我们放到了 IssueBoard，IssueBoard 像是一个简化版的任务看板，但对我们来说已经绰绰有余了，另外，选择它的理由还包括：它支持跟 git 提交进行联动，适合开发人员使用，可以通过每次提交来关闭相应的 Issue。 总结反思在这次升级过程中，也暴露了一些不足，主要体现在排期与预期以及在前期的沟通上。 排期与预期 在升级筹划初期的排期过于乐观，而且在升级过程中没有再进行修正，当然这是客观原因造成的，团队要在有限的需求空窗期内完成升级以避免同时维护两个版本，这导致的后果是团队必须每天比计划花更多的时间。 沟通 在服务端进行升级时，没有跟前端沟通具体的细节，而这次升级又是非完全向下兼容的，所以在联调的时候给造成前端一定的困扰和不便。 参考 Atom：https://ling.jd.com/atom Salak：https://salakjs.github.io/docs/docs/zh-cn/introduction.html RESTful API：http://www.ruanyifeng.com/blog/2014/05/restful_api.html","pubDate":"Tue, 21 Apr 2020 00:08:08 GMT","guid":"https://aotu.io/notes/2020/04/21/atom-services-upgrade/","category":"项目总结"},{"title":"Taro Next H5 跨框架组件库实践","link":"https://aotu.io/notes/2020/04/13/2020-4-13-taro-components/","description":"Taro 是一款多端开发框架。开发者只需编写一份代码，即可生成各小程序端、H5 以及 React Native 的应用。 Taro Next 近期已发布 beta 版本，全面完善对小程序以及 H5 的支持，欢迎体验！ 背景Taro Next 将支持使用多框架开发过去的 Taro 1 与 Taro 2 只能使用 React 语法进行开发，但下一代的 Taro 框架对整体架构进行了升级，支持使用 React、Vue、Nerv 等框架开发多端应用。 为了支持使用多框架进行开发，Taro 需要对自身的各端适配能力进行改造。本文将重点介绍对 Taro H5 端组件库的改造工作。 Taro H5Taro 遵循以微信小程序为主，其他小程序为辅的组件与 API 规范。 但浏览器并没有小程序规范的组件与 API 可供使用，例如我们不能在浏览器上使用小程序的 view 组件和 getSystemInfo API。因此我们需要在 H5 端实现一套基于小程序规范的组件库和 API 库。 Taro H5 架构图： 在 Taro 1 和 Taro 2 中，Taro H5 的组件库使用了 React 语法进行开发。但如果开发者在 Taro Next 中使用 Vue 开发 H5 应用，则不能和现有的 H5 组件库兼容。 所以本文需要面对的核心问题就是：我们需要在 H5 端实现 React、Vue 等框架都可以使用的组件库。 方案选择我们最先想到的是使用 Vue 再开发一套组件库，这样最为稳妥，工作量也没有特别大。 但考虑到以下两点，我们遂放弃了此思路： 组件库的可维护性和拓展性不足。每当有问题需要修复或新功能需要添加，我们需要分别对 React 和 Vue 版本的组件库进行改造。 Taro Next 的目标是支持使用任意框架开发多端应用。倘若将来支持使用 Angular 等框架进行开发，那么我们需要再开发对应支持 Angular 等框架的组件库。 那么是否存在着一种方案，使得只用一份代码构建的组件库能兼容所有的 web 开发框架呢？ 答案就是 Web Components。 但在组件库改造为 Web Components 的过程并不是一凡风顺的，我们也遇到了不少的问题，故借此文向大家娓娓道来。 Web Components 简介Web Components 由一系列的技术规范所组成，它让开发者可以开发出浏览器原生支持的组件。 技术规范Web Components 的主要技术规范为： Custom Elements Shadow DOM HTML Template Custom Elements 让开发者可以自定义带有特定行为的 HTML 标签。 Shadow DOM 对标签内的结构和样式进行一层包装。 &lt;template&gt; 标签为 Web Components 提供复用性，还可以配合 &lt;slot&gt; 标签提供灵活性。 示例定义模板： 123&lt;template id=\"template\"&gt; &lt;h1&gt;Hello World!&lt;/h1&gt;&lt;/template&gt; 构造 Custom Element： 1234567891011121314class App extends HTMLElement &#123; constructor () &#123; super(...arguments) // 开启 Shadow DOM const shadowRoot = this.attachShadow(&#123; mode: 'open' &#125;) // 复用 &lt;template&gt; 定义好的结构 const template = document.querySelector('#template') const node = template.content.cloneNode(true) shadowRoot.appendChild(node) &#125;&#125;window.customElements.define('my-app', App) 使用： 1&lt;my-app&gt;&lt;/my-app&gt; Stencil使用原生语法去编写 Web Components 相当繁琐，因此我们需要一个框架帮助我们提高开发效率和开发体验。 业界已经有很多成熟的 Web Components 框架，一番比较后我们最终选择了 Stencil，原因有二： Stencil 由 Ionic 团队打造，被用于构建 Ionic 的组件库，证明经受过业界考验。 Stencil 支持 JSX，能减少现有组件库的迁移成本。 Stencil 是一个可以生成 Web Components 的编译器。它糅合了业界前端框架的一些优秀概念，如支持 Typescript、JSX、虚拟 DOM 等。 示例：创建 Stencil Component： 123456789101112131415161718192021import &#123; Component, Prop, State, h &#125; from '@stencil/core'@Component(&#123; tag: 'my-component'&#125;)export class MyComponent &#123; @Prop() first = '' @State() last = 'JS' componentDidLoad () &#123; console.log('load') &#125; render () &#123; return ( &lt;div&gt; Hello, my name is &#123;this.first&#125; &#123;this.last&#125; &lt;/div&gt; ) &#125;&#125; 使用组件： 1&lt;my-component first='Taro' /&gt; 在 React 与 Vue 中使用 Stencil到目前为止一切都那么美好：使用 Stencil 编写出 Web Components，即可以在 React 和 Vue 中直接使用它们。 但实际使用上却会出现一些问题，Custom Elements Everywhere 通过一系列的测试用例，罗列出业界前端框架对 Web Components 的兼容问题及相关 issues。下面将简单介绍 Taro H5 组件库分别对 React 和 Vue 的兼容工作。 兼容 React1. Props1.1 问题React 使用 setAttribute 的形式给 Web Components 传递参数。当参数为原始类型时是可以运行的，但是如果参数为对象或数组时，由于 HTML 元素的 attribute 值只能为字符串或 null，最终给 WebComponents 设置的 attribute 会是 attr=&quot;[object Object]&quot;。 attribute 与 property 区别 1.2 解决方案采用 DOM Property 的方法传参。 我们可以把 Web Components 包装一层高阶组件，把高阶组件上的 props 设置为 Web Components 的 property： 1234567891011121314151617181920212223242526272829303132333435363738const reactifyWebComponent = WC =&gt; &#123; return class extends React.Component &#123; ref = React.createRef() update () &#123; Object.entries(this.props).forEach(([prop, val]) =&gt; &#123; if (prop === 'children' || prop === 'dangerouslySetInnerHTML') &#123; return &#125; if (prop === 'style' &amp;&amp; val &amp;&amp; typeof val === 'object') &#123; for (const key in val) &#123; this.ref.current.style[key] = val[key] &#125; return &#125; this.ref.current[prop] = val &#125;) &#125; componentDidUpdate () &#123; this.update() &#125; componentDidMount () &#123; this.update() &#125; render () &#123; const &#123; children, dangerouslySetInnerHTML &#125; = this.props return React.createElement(WC, &#123; ref: this.ref, dangerouslySetInnerHTML &#125;, children) &#125; &#125;&#125;const MyComponent = reactifyWebComponent('my-component') 注意： children、dangerouslySetInnerHTML 属性需要透传。 React 中 style 属性值可以接受对象形式，这里需要额外处理。 2. Events2.1 问题因为 React 有一套合成事件系统，所以它不能监听到 Web Components 发出的自定义事件。 以下 Web Component 的 onLongPress 回调不会被触发： 1&lt;my-view onLongPress=&#123;onLongPress&#125;&gt;view&lt;/my-view&gt; 2.2 解决方案通过 ref 取得 Web Component 元素，手动 addEventListener 绑定事件。 改造上述的高阶组件： 123456789101112131415161718192021222324252627282930313233const reactifyWebComponent = WC =&gt; &#123; return class Index extends React.Component &#123; ref = React.createRef() eventHandlers = [] update () &#123; this.clearEventHandlers() Object.entries(this.props).forEach(([prop, val]) =&gt; &#123; if (typeof val === 'function' &amp;&amp; prop.match(/^on[A-Z]/)) &#123; const event = prop.substr(2).toLowerCase() this.eventHandlers.push([event, val]) return this.ref.current.addEventListener(event, val) &#125; ... &#125;) &#125; clearEventHandlers () &#123; this.eventHandlers.forEach(([event, handler]) =&gt; &#123; this.ref.current.removeEventListener(event, handler) &#125;) this.eventHandlers = [] &#125; componentWillUnmount () &#123; this.clearEventHandlers() &#125; ... &#125;&#125; 3. Ref3.1 问题我们为了解决 Props 和 Events 的问题，引入了高阶组件。那么当开发者向高阶组件传入 ref 时，获取到的其实是高阶组件，但我们希望开发者能获取到对应的 Web Component。 domRef 会获取到 MyComponent，而不是 &lt;my-component&gt;&lt;/my-component&gt; 1&lt;MyComponent ref=&#123;domRef&#125; /&gt; 3.2 解决方案使用 forwardRef 传递 ref。 改造上述的高阶组件为 forwardRef 形式： 123456789101112131415const reactifyWebComponent = WC =&gt; &#123; class Index extends React.Component &#123; ... render () &#123; const &#123; children, forwardRef &#125; = this.props return React.createElement(WC, &#123; ref: forwardRef &#125;, children) &#125; &#125; return React.forwardRef((props, ref) =&gt; ( React.createElement(Index, &#123; ...props, forwardRef: ref &#125;) ))&#125; 4. Host’s className4.1 问题在 Stencil 里我们可以使用 Host 组件为 host element 添加类名。 1234567891011121314import &#123; Component, Host, h &#125; from '@stencil/core';@Component(&#123; tag: 'todo-list'&#125;)export class TodoList &#123; render () &#123; return ( &lt;Host class='todo-list'&gt; &lt;div&gt;todo&lt;/div&gt; &lt;/Host&gt; ) &#125;&#125; 然后在使用 &lt;todo-list&gt; 元素时会展示我们内置的类名 “todo-list” 和 Stencil 自动加入的类名 “hydrated”： 但如果我们在使用时设置了动态类名，如： &lt;todo-list class={this.state.cls}&gt;。那么在动态类名更新时，则会把内置的类名 “todo-list” 和 “hydrated” 抹除掉。 关于类名 “hydrated”： Stencil 会为所有 Web Components 加上 visibility: hidden; 的样式。然后在各 Web Component 初始化完成后加入类名 “hydrated”，将 visibility 改为 inherit。如果 “hydrated” 被抹除掉，Web Components 将不可见。 因此我们需要保证在类名更新时不会覆盖 Web Components 的内置类名。 4.2 解决方案高阶组件在使用 ref 为 Web Component 设置 className 属性时，对内置 class 进行合并。 改造上述的高阶组件： 123456789101112131415161718192021222324252627282930const reactifyWebComponent = WC =&gt; &#123; class Index extends React.Component &#123; update (prevProps) &#123; Object.entries(this.props).forEach(([prop, val]) =&gt; &#123; if (prop.toLowerCase() === 'classname') &#123; this.ref.current.className = prevProps // getClassName 在保留内置类名的情况下，返回最新的类名 ? getClassName(this.ref.current, prevProps, this.props) : val return &#125; ... &#125;) &#125; componentDidUpdate (prevProps) &#123; this.update(prevProps) &#125; componentDidMount () &#123; this.update() &#125; ... &#125; return React.forwardRef((props, ref) =&gt; ( React.createElement(Index, &#123; ...props, forwardRef: ref &#125;) ))&#125; 兼容 Vue不同于 React，虽然 Vue 在传递参数给 Web Components 时也是采用 setAttribute 的方式，但 v-bind 指令提供了 .prop 修饰符，它可以将参数作为 DOM property 来绑定。另外 Vue 也能监听 Web Components 发出的自定义事件。 因此 Vue 在 Props 和 Events 两个问题上都不需要额外处理，但在与 Stencil 的配合上还是有一些兼容问题，接下来将列出主要的三点。 1. Host’s className1.1 问题同上文兼容 React 第四部分，在 Vue 中更新 host element 的 class，也会覆盖内置 class。 1.2 解决方案同样的思路，需要在 Web Components 上包装一层 Vue 的自定义组件。 123456789101112131415161718function createComponent (name, classNames = []) &#123; return &#123; name, computed: &#123; listeners () &#123; return &#123; ...this.$listeners &#125; &#125; &#125;, render (createElement) &#123; return createElement(name, &#123; class: ['hydrated', ...classNames], on: this.listeners &#125;, this.$slots.default) &#125; &#125;&#125;Vue.component('todo-list', createComponent('todo-list', ['todo-list'])) 注意： 我们在自定义组件中重复声明了 Web Component 该有的内置类名。后续开发者为自定义组件设置类名时，Vue 将会自动对类名进行合并。 需要把自定义组件上绑定的事件通过 $listeners 透传给 Web Component。 2. Ref2.1 问题为了解决问题 1，我们给 Vue 中的 Web Components 都包装了一层自定义组件。同样地，开发者在使用 ref 时取到的是自定义组件，而不是 Web Component。 2.2 解决方案Vue 并没有 forwardRef 的概念，只可简单粗暴地修改 this.$parent.$refs。 为自定义组件增加一个 mixin： 1234567891011121314151617181920212223242526export const refs = &#123; mounted () &#123; if (Object.keys(this.$parent.$refs).length) &#123; const refs = this.$parent.$refs for (const key in refs) &#123; if (refs[key] === this) &#123; refs[key] = this.$el break &#125; &#125; &#125; &#125;, beforeDestroy () &#123; if (Object.keys(this.$parent.$refs).length) &#123; const refs = this.$parent.$refs for (const key in refs) &#123; if (refs[key] === this.$el) &#123; refs[key] = null break &#125; &#125; &#125; &#125;&#125; 注意： 上述代码没有处理循环 ref，循环 ref 还需要另外判断和处理。 3. v-model3.1 问题我们在自定义组件中使用了渲染函数进行渲染，因此对表单组件需要额外处理 v-model。 3.2 解决方案使用自定义组件上的 model 选项，定制组件使用 v-model 时的 prop 和 event。 改造上述的自定义组件： 1234567891011121314151617181920212223242526272829303132333435363738export default function createFormsComponent (name, event, modelValue = 'value', classNames = []) &#123; return &#123; name, computed: &#123; listeners () &#123; return &#123; ...this.$listeners &#125; &#125; &#125;, model: &#123; prop: modelValue, event: 'model' &#125;, methods: &#123; input (e) &#123; this.$emit('input', e) this.$emit('model', e.target.value) &#125;, change (e) &#123; this.$emit('change', e) this.$emit('model', e.target.value) &#125; &#125;, render (createElement) &#123; return createElement(name, &#123; class: ['hydrated', ...classNames], on: &#123; ...this.listeners, [event]: this[event] &#125; &#125;, this.$slots.default) &#125; &#125;&#125;const Input = createFormsComponent('taro-input', 'input')const Switch = createFormsComponent('taro-switch', 'change', 'checked')Vue.component('taro-input', Input)Vue.component('taro-switch', Switch) 总结当我们希望创建一些不拘泥于框架的组件时，Web Components 会是一个不错的选择。比如跨团队协作，双方的技术栈不同，但又需要公用部分组件时。 本次对 React 语法组件库进行 Web Components 化改造，工作量不下于重新搭建一个 Vue 组件库。但日后当 Taro 支持使用其他框架编写多端应用时，只需要针对对应框架与 Web Components 和 Stencil 的兼容问题编写一个胶水层即可，总体来看还是值得的。 关于胶水层，业界兼容 React 的方案颇多，只是兼容 Web Components 可以使用 reactify-wc，配合 Stencil 则可以使用官方提供的插件 Stencil DS Plugin。倘若 Vue 需要兼容 Stencil，或需要提高兼容时的灵活性，还是建议手工编写一个胶水层。 本文简单介绍了 Taro Next、Web Components、Stencil 以及基于 Stencil 的组件库改造历程，希望能为读者们带来一些帮助与启迪。","pubDate":"Mon, 13 Apr 2020 03:10:00 GMT","guid":"https://aotu.io/notes/2020/04/13/2020-4-13-taro-components/","category":"Web开发"},{"title":"Electron 在 Taro IDE 的开发实践","link":"https://aotu.io/notes/2020/04/07/electron-in-taro-ide/","description":"这是一些使用 Electron 开发的经验与感悟 背景Taro IDE 是一款我们正在精心打造的一站式移动端研发工作台。除了需要实现 Taro 从创建项目到预览、编译的全部能力，还需要打通用户测试、调试、监控等一系列流程。为了提升开发体验，仅仅一个命令行工具是远远不够的，我们需要开发一款桌面客户端，并同时提供 Windows、MacOS 等不同系统的版本。 Electron 最初是 Github 为 Atom 编辑器开发的桌面应用框架。Electron 将 Chromium 与 Node 合并到同个运行时环境中，赋予了 Web 代码与底层操作系统进行交互的能力，并在打包时生成 Windows、MacOS、Linux 等平台的桌面应用。比起原生的桌面应用开发框架，Electron 在性能、应用体积方面会稍逊一筹，但 Electron 支持打包多个平台的桌面应用，在业界已经有 VSCode、Atom、Slack 等综合体验拔群的成功案例，我们认为 Electron 完全满足我们的需求。 介绍 Electron如果只想体验一下 Electron，最快的方式是使用 Electron Fiddle，或者直接使用社区中提供的 脚手架。 最初接触 Electron，一般是被“使用前端技术栈生成多平台桌面应用”的特性吸引。但在后续的开发中，才会留意到 Electron 相比 NW.js 更为复杂的进程模型： Electron 的架构可以用下图来表示： Electron 项目中，运行 package.json 的 main 脚本的进程被称为主进程。主进程通过创建 web 页面来展示用户界面。这些用户界面都运行在彼此隔离的渲染进程中。 Electron 主进程支持 Node API，并且可直接与操作系统进行底层交互，弹出系统通知、文件系统读写、调用硬件设备等。 Electron 渲染进程默认只能与自身的 Web 内容进行交互。在打开 nodeIntegration 功能后，渲染进程也可以具备操作 Node 的能力。渲染进程也无法直接操作弹窗（Dialog）、系统通知（Notification）等，这些功能都需要通过 Electron 提供的 IPC/remote 机制在主进程中调用。 并且在后续 Electron 的升级中，这些约束也可能因为安全、性能的原因进行调整。可以说，Electron 的开发体验并不太美好，但正是这种开发体验与用户体验之间的博弈，保证了 Electron 应用在性能、安全方面的表现。 开发工作流我们使用社区提供的 electron-react-typescript 作为项目的初始脚手架。阅读 package.json 文件，我们可以了解到，这个项目使用 webpack 进行主进程和渲染进程的打包，src/main/main.ts 文件就是主进程的入口。 Electron 的 BrowserWindow 类负责创建和控制浏览器窗口，app 对象则可以控制应用程序的各个事件与生命周期。 主进程的代码大致如下： 1234567891011import &#123; app, BrowserWindow &#125; from 'electron'let winapp.on('ready', () =&gt; &#123; win = new BrowserWindow(&#123; width: 800, height: 600 &#125;); win.loadURL(`http://localhost:2003`); // xxx&#125;);app.on('activate', () =&gt; &#123;&#125;)app.on('window-all-closed', () =&gt; &#123;&#125;) 渲染进程 src/renderer/app.tsx 就一个普通的页面，这里不再赘述。安装依赖后，使用 yarn start-dev ，即可启动项目的预览服务。 这个项目使用 webpack 来打包项目代码，这样处理有两个好处。一是通过 webpack 处理，我们可以减少运行时的 require 调用，对 Electron 应用加载性能有一定帮助；二是借助 webpack 的 tree shaking 能力，未使用的代码也会被轻松移除，可以有效减少安装包体积。 为了打包 electron 项目，我们需要至少两份 webpack 配置文件，一份打包主进程文件，指定 target 为 electron-main，另一份打包渲染进程，target 设置为 electron-renderer。 为了辅助 Electron 项目的调试工作，我们可以安装 Devtron。Devtron 是 Electron 提供的开发调试插件。在开发者工具中加入 Devtron 后，项目中的 IPC 通信、查看项目依赖、事件等信息，都可以在开发者工具中直接查看。 如有需要，我们还可以安装其他的开发者工具扩展，例如 Redux、React 等，只需要在主进程中运行： 1234567891011121314151617// main.jsconst &#123; default: installExtension, REACT_DEVELOPER_TOOLS, REACT_PERF, REDUX_DEVTOOLS&#125; = require('electron-devtools-installer')const extensions = [REACT_DEVELOPER_TOOLS, REDUX_DEVTOOLS, REACT_PERF]extensions.forEach(extension =&gt; &#123; try &#123; installExtension(extension) &#125; catch (e) &#123; console.error(e) &#125;&#125;) 至此，我们的开发环境搭建完毕，可以开始进行业务代码的开发了。 优化业务代码开发完毕后，就到了优化的环节了。这里主要从 Electron 应用的性能与体积两方面来讲。 性能Electron 在性能方面一直受到广大开发者的诟病。窗口打开慢，加载时间长都是老生畅谈的话题。这些问题该如何解决呢？ 答案是预加载。在展示登录窗口时，我们可以提前将主窗口开启并设置隐藏，预加载主窗口的静态资源。用户登录后，再通过 IPC 消息通知主窗口展示，达到秒开的效果。这个过程可以用下图表示： 除了窗口加载，在 Electron 中，require Node 模块也是相当昂贵的操作。如果在渲染进程中直接使用大量的原生模块，会严重拖慢页面的打开时间，造成窗口可交互时间的延后，这对于桌面应用来说是灾难性的体验。Electron@5 之后的版本已经默认关闭了 BrowserWindow 的 nodeIntegration 功能，可以看出 Electron 团队也并不建议在渲染进程中直接使用原生模块。 在桌面应用中，等待是非常难以忍受的，性能上的些许欠缺都会让用户觉得这是个套壳的网页。如需使用原生模块，我们更建议使用异步的方式加载模块，或是使用异步 IPC 在主进程中调用。另外，为了优化用户的体验，我们还需要在小动画等方面下功夫，例如骨架屏等等。 Atom 团队通过使用 V8 snapshot 能力，在生产环境中去掉了低性能的 require 调用，将 Electron 应用的加载性能提升了 30%，同时还提升了应用的安全性能，这篇文章 How Atom Uses Chromium Snapshots 对他们的做法做了详细介绍。 启用骨架屏前后对比： 性能优化的方式并不局限于上面的方式。例如开启 electron-builder 的 asar 功能，在打包时将源码生成二进制的 asar 文件，降低 require 操作的代价的同时，也能稍许减少空间占用，代价是无法对 asar 内的文件使用 child_process.spawn ；需要密集计算的功能，可以开多一个渲染进程来跑，或是使用 require(&#39;child_process&#39;).spawn 开子进程来跑，避免阻塞主进程，造成应用卡死。 体积同样受到开发者诟病的，还有 Electron 应用的体积 。一个空 Electron 项目，在打包后就会占据近上百兆空间。Electron 的应用体积之所以大，除了自带的 Chromium 内核，还有大部分体积是来自用户安装的 node_modules。 使用 electron-builder 打包 Electron 应用时，如果不加处理，会将 node_modules 内的内容全数打包，导致应用体积偏大。针对这种情况，我们可以进行一系列优化： 使用 yarn autoclean 命令进行清理。node_modules 目录中，包含着大量的 README 文件、文档等内容，这部分文件在生产环境中并非必要。如果项目中使用 yarn 进行依赖管理，则可以使用 yarn autoclean 命令。这个命令会初始化一份默认的配置文件 .yarnclean 。yarn 在安装依赖后，将会自动根据 .yarnclean 进行依赖清理。 12345678910111213141516171819# 默认的 .yarnclean 文件大致如下：# test directories__tests__testtestspowered-test# asset directoriesdocsdocwebsiteassets# examplesexampleexamples... 使用双 package.json 架构。node_modules 目录中，除了生产环境需要用到的依赖，还存在着很多 devDependencies，这部分依赖是不应该被打包的。为了解决这个问题，electron-builder 提供了双 package.json 架构。具体来说，electron-builder 推荐用户将 Electron 应用依赖划分为两部分：开发依赖以及生产依赖。用户使用项目根目录的 package.json 来管理开发依赖，而使用项目的应用文件夹下的 package.json 管理生产依赖。electron-builder 仅会打包应用文件夹下的依赖。 在这个改动后，安装依赖时还需要通过 electron-builder install-app-deps 命令安装应用依赖。这个操作推荐放在 package.json 内的 post-install 脚本中。 electron-builder@8 后，并不会打包 devDependencies 内的依赖。这意味着我们可以通过这个途径来避免开发依赖被打包的问题。如果项目使用了 webpack 之类的工具进行打包，则需要注意将 webpack 已经打包过的资源从 dependencies 中排除，避免重复打包。 未来能力 Web 化目前，项目的大部分能力依然是基于 Electron 提供的能力实现的。这相当于与 Electron 严重耦合，不利于项目中个别能力的复用。未来，我们希望对项目的架构进行调整，对核心能力进行插件化改造，方便能力的移植与复用，甚至未来的研发上云，这有赖于项目核心能力的 Web 化。当然，Web 化也会带来额外的性能损耗，这会对我们项目的性能提出新的要求。 崩溃处理项目的稳定性也是未来需要努力的方向。我们有时会收到用户关于应用闪退、卡死等现象的反馈，却苦于无法复现，很多时候难以解决用户反馈的问题。未来，我们需要在项目中加入异常监控上报的机制，收集操作系统信息、内存使用量等关键信息，在 Crash 时进行上报，甚至推送告警消息。这有利于开发人员进一步了解用户的使用过程，方便问题的复现。 小结在开发桌面应用时，Electron 在效率上有很大的优势。几行 JS 代码就可以启动桌面客户端，大大降低了开发门槛。但 Electron 在性能、体积等方面也存在着软肋。如果在前期开发时没有经过充分思考，很有可能会在后期优化时付出惨痛的代价。在这个项目中，我们的优化工作还远远不够，后续有更多突破会分享给大家。zh 参考资料[1]Electron: https://www.electronjs.org/[2]Electron Fiddle: https://www.electronjs.org/fiddle[3]脚手架: https://github.com/search?q=electron+boilerplate&amp;ref=opensearch[4]NW.js: https://nwjs.io/[5]electron-react-typescript: https://github.com/Robinfr/electron-react-typescript[6]src/main/main.ts: https://github.com/Robinfr/electron-react-typescript/blob/b50263f06ecd518bfd43421a3c0bc3c3be308b64/src/main/main.ts[7]src/renderer/app.tsx: https://github.com/Robinfr/electron-react-typescript/blob/b50263f06ecd518bfd43421a3c0bc3c3be308b64/src/renderer/app.tsx#L1[8]Devtron: https://www.electronjs.org/devtron[9]How Atom Uses Chromium Snapshots: https://flight-manual.atom.io/behind-atom/sections/how-atom-uses-chromium-snapshots/","pubDate":"Tue, 07 Apr 2020 09:00:00 GMT","guid":"https://aotu.io/notes/2020/04/07/electron-in-taro-ide/","category":"Web开发"},{"title":"如何打造高性能小程序门户","link":"https://aotu.io/notes/2020/03/25/high-performance-miniprogram/","description":"本文阅读时长约15分钟。京喜小程序开发团队核心成员倾力之作，都是干货，读完一定会收获满满，请大家耐心阅读～ 背景京喜小程序自去年双十一上线微信购物一级入口后，时刻迎接着亿级用户量的挑战，细微的体验细节都有可能被无限放大，为此，“极致的页面性能”、“友好的产品体验” 和 “稳定的系统服务” 成为了我们开发团队的最基本执行原则。 首页作为小程序的门户，其性能表现和用户留存率息息相关。因此，我们对京喜首页进行了一次全方位的升级改造，从加载、渲染和感知体验几大维度深挖小程序的性能可塑性。 除此之外，京喜首页在微信小程序、H5、APP 三端都有落地场景，为了提高研发效率，我们使用了 Taro 框架实现多端统一，因此下文中有部分内容是和 Taro 框架息息相关的。 怎么定义高性能？提起互联网应用性能这个词，很多人在脑海中的词法解析就是，“是否足够快？”，似乎加载速度成为衡量系统性能的唯一指标。但这其实是不够准确的，试想一下，如果一个小程序加载速度非常快，用户花费很短时间就能看到页面的主体内容，但此时搜索框却无法输入内容，功能无法被流畅使用，用户可能就不会关心页面渲染有多快了。所以，我们不应该单纯考虑速度指标而忽略用户的感知体验，而应该全方位衡量用户在使用过程中能感知到的与应用加载相关的每个节点。 谷歌为 Web 应用定义了以用户为中心的性能指标体系，每个指标都与用户体验节点息息相关： 体验 指标 页面能否正常访问？ 首次内容绘制 (First Contentful Paint, FCP) 页面内容是否有用？ 首次有效绘制 (First Meaningful Paint, FMP) 页面功能是否可用？ 可交互时间 (Time to Interactive, TTI) 其中，“是否有用？” 这个问题是非常主观的，对于不同场景的系统可能会有完全不一样的回答，所以 FMP 是一个比较模糊的概念指标，不存在规范化的数值衡量。 小程序作为一个新的内容载体，衡量指标跟 Web 应用是非常类似的。对于大多数小程序而言，上述指标对应的含义为： FCP：白屏加载结束； FMP：首屏渲染完成； TTI：所有内容加载完成； 综上，我们已基本确定了高性能的概念指标，接下来就是如何利用数值指标来描绘性能表现。 小程序官方性能指标小程序官方针对小程序性能表现制订了权威的数值指标，主要围绕 渲染表现、setData 数据量、元素节点数 和 网络请求延时 这几个维度来给予定义（下面只列出部分关键指标）： 首屏时间不超过 5 秒； 渲染时间不超过 500ms； 每秒调用 setData 的次数不超过 20 次； setData 的数据在 JSON.stringify 后不超过 256kb； 页面 WXML 节点少于 1000 个，节点树深度少于 30 层，子节点数不大于 60 个； 所有网络请求都在 1 秒内返回结果； 详见 小程序性能评分规则 我们应该把这一系列的官方指标作为小程序的性能及格线，不断地打磨和提升小程序的整体体验，降低用户流失率。另外，这些指标会直接作为小程序体验评分工具的性能评分规则（体验评分工具会根据这些规则的权重和求和公式计算出体验得分）。 我们团队内部在官方性能指标的基础上，进一步浓缩优化指标系数，旨在对产品体验更高要求： 首屏时间不超过 2.5 秒； setData 的数据量不超过 100kb； 所有网络请求都在 1 秒内返回结果； 组件滑动、长列表滚动无卡顿感； 体验评分工具小程序提供了 体验评分工具（Audits 面板） 来测量上述的指标数据，其集成在开发者工具中，在小程序运行时实时检查相关问题点，并为开发者给出优化建议。 以上截图均来自小程序官方文档 体验评分工具是目前检测小程序性能问题最直接有效的途径，我们团队已经把体验评分作为页面/组件是否能达到精品门槛的重要考量手段之一。 小程序后台性能分析我们知道，体验评分工具是在本地运行小程序代码时进行分析，但性能数据往往需要在真实环境和大数据量下才更有说服力。恰巧，小程序管理平台 和 小程序助手 为开发者提供了大量的真实数据统计。其中，性能分析面板从 启动性能、运行性能 和 网络性能 这三个维度分析数据，开发者可以根据客户端系统、机型、网络环境和访问来源等条件做精细化分析，非常具有考量价值。 其中，启动总耗时 = 小程序环境初始化 + 代码包加载 + 代码执行 + 渲染耗时 第三方测速系统很多时候，宏观的耗时统计对于性能瓶颈点分析往往是杯水车薪，作用甚少，我们需要更细致地针对某个页面某些关键节点作测速统计，排查出暴露性能问题的代码区块，才能更有效地针对性优化。京喜小程序使用的是内部自研的测速系统，支持对地区、运营商、网络、客户端系统等多条件筛选，同时也支持数据可视化、同比分析数据等能力。京喜首页主要围绕 页面 onLoad、onReady、数据加载完成、首屏渲染完成、各业务组件首次渲染完成 等几个关键节点统计测速上报，旨在全链路监控性能表现。 另外，微信为开发者提供了 测速系统，也支持针对客户端系统、网络类型、用户地区等维度统计数据，有兴趣的可以尝试。 了解小程序底层架构为了更好地为小程序制订性能优化措施，我们有必要先了解小程序的底层架构，以及与 web 浏览器的差异性。 微信小程序是大前端跨平台技术的其中一种产物，与当下其他热门的技术 React Native、Weex、Flutter 等不同，小程序的最终渲染载体依然是浏览器内核，而不是原生客户端。 而对于传统的网页来说，UI 渲染和 JS 脚本是在同一个线程中执行，所以经常会出现 “阻塞” 行为。微信小程序基于性能的考虑，启用了双线程模型： 视图层：也就是 webview 线程，负责启用不同的 webview 来渲染不同的小程序页面； 逻辑层：一个单独的线程执行 JS 代码，可以控制视图层的逻辑； 上图来自小程序官方开发指南 然而，任何线程间的数据传输都是有延时的，这意味着逻辑层和视图层间通信是异步行为。除此之外，微信为小程序提供了很多客户端原生能力，在调用客户端原生能力的过程中，微信主线程和小程序双线程之间也会发生通信，这也是一种异步行为。这种异步延时的特性会使运行环境复杂化，稍不注意，就会产出效率低下的编码。 作为小程序开发者，我们常常会被下面几个问题所困扰： 小程序启动慢； 白屏时间长； 页面渲染慢； 运行内存不足； 接下来，我们会结合小程序的底层架构分析出这些问题的根本原因，并针对性地给出解决方案。 小程序启动太慢？小程序启动阶段，也就是如下图所示的展示加载界面的阶段。 在这个阶段中（包括启动前后的时机），微信会默默完成下面几项工作： 1. 准备运行环境： 在小程序启动前，微信会先启动双线程环境，并在线程中完成小程序基础库的初始化和预执行。 小程序基础库包括 WebView 基础库和 AppService 基础库，前者注入到视图层中，后者注入到逻辑层中，分别为所在层级提供其运行所需的基础框架能力。 2. 下载小程序代码包： 在小程序初次启动时，需要下载编译后的代码包到本地。如果启动了小程序分包，则只有主包的内容会被下载。另外，代码包会保留在缓存中，后续启动会优先读取缓存。 3. 加载小程序代码包： 小程序代码包下载好之后，会被加载到适当的线程中执行，基础库会完成所有页面的注册。 在此阶段，主包内的所有页面 JS 文件及其依赖文件都会被自动执行。 在页面注册过程中，基础库会调用页面 JS 文件的 Page 构造器方法，来记录页面的基础信息（包括初始数据、方法等）。 4. 初始化小程序首页： 在小程序代码包加载完之后，基础库会根据启动路径找到首页，根据首页的基础信息初始化一个页面实例，并把信息传递给视图层，视图层会结合 WXML 结构、WXSS 样式和初始数据来渲染界面。 综合考虑，为了节省小程序的“点点点”时间（小程序的启动动画是三个圆点循环跑马灯），除了给每位用户发一台高配 5G 手机并顺带提供千兆宽带网络之外，还可以尽量 控制代码包大小，缩小代码包的下载时间。 无用文件、函数、样式剔除经过多次业务迭代，无可避免的会存在一些弃用的组件/页面，以及不被调用的函数、样式规则，这些冗余代码会白白占据宝贵的代码包空间。而且，目前小程序的打包会将工程下所有文件都打入代码包内，并没有做依赖分析。 因此，我们需要及时地剔除不再使用的模块，以保证代码包空间利用率保持在较高水平。通过一些工具化手段可以有效地辅助完成这一工作。 文件依赖分析 在小程序中，所有页面的路径都需要在小程序代码根目录 app.json 中被声明，类似地，自定义组件也需要在页面配置文件 page.json 中被声明。另外，WXML、WXSS 和 JS 的模块化都需要特定的关键字来声明依赖引用关系。 WXML 中的 import 和 include： 12345678&lt;!-- A.wxml --&gt;&lt;template name='A'&gt; &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt;&lt;/template&gt;&lt;!-- B.wxml --&gt;&lt;import src=\"A.wxml\"/&gt;&lt;template is=\"A\" data=\"&#123;&#123;text: 'B'&#125;&#125;\"/&gt; 123456&lt;!-- A.wxml --&gt;&lt;text&gt; A &lt;/text&gt;&lt;!-- B.wxml --&gt;&lt;include src=\"A.wxml\"/&gt;&lt;text&gt; B &lt;/text&gt; WXSS 中的 @import： 1@import './A.wxss' JS 中的 require/import： 1const A = require('./A') 所以，可以说小程序里的所有依赖模块都是有迹可循的，我们只需要利用这些关键字信息递归查找，遍历出文件依赖树，然后把没用的模块剔除掉。 JS、CSS Tree-Shaking JS Tree-Shaking 的原理就是借助 Babel 把代码编译成抽象语法树（AST），通过 AST 获取到函数的调用关系，从而把未被调用的函数方法剔除掉。不过这需要依赖 ES module，而小程序最开始是遵循 CommonJS 规范的，这意味着是时候来一波“痛并快乐着”的改造了。 而 CSS 的 Tree-Shaking 可以利用 PurifyCSS 插件来完成。关于这两项技术，有兴趣的可以“谷歌一下”，这里就不铺开细讲了。 题外，京东的小程序团队已经把这一系列工程化能力集成在一套 CLI 工具中，有兴趣的可以看看这篇分享：小程序工程化探索。 减少代码包中的静态资源文件小程序代码包最终会经过 GZIP 压缩放在 CDN 上，但 GZIP 压缩对于图片资源来说效果非常低。如 JPG、PNG 等格式文件，本身已经被压缩过了，再使用 GZIP 压缩有可能体积更大，得不偿失。所以，除了部分用于容错的图片必须放在代码包（譬如网络异常提示）之外，建议开发者把图片、视频等静态资源都放在 CDN 上。 需要注意，Base64 格式本质上是长字符串，和 CDN 地址比起来也会更占空间。 逻辑后移，精简业务逻辑这是一个 “痛并快乐着” 的优化措施。“痛” 是因为需要给后台同学提改造需求，分分钟被打；“快乐” 则是因为享受删代码的过程，而且万一出 Bug 也不用背锅了…（开个玩笑） 通过让后台承担更多的业务逻辑，可以节省小程序前端代码量，同时线上问题还支持紧急修复，不需要经历小程序的提审、发布上线等繁琐过程。 总结得出，一般不涉及前端计算的展示类逻辑，都可以适当做后移。譬如京喜首页中的幕帘弹窗（如下图）逻辑，这里共有 10+ 种弹窗类型，以前的做法是前端从接口拉取 10+ 个不同字段，根据优先级和 “是否已展示”（该状态存储在本地缓存） 来决定展示哪一种，最后代码大概是这样的： 123456789101112131415161718192021// 检查每种弹窗类型是否已展示Promise.all([ check(popup_1), check(popup_2), // ... check(popup_n)]).then(result =&gt; &#123; // 优先级排序 const queue = [&#123; show: result.popup_1 data: data.popup_1 &#125;, &#123; show: result.popup_2 data: data.popup_2 &#125;, // ... &#123; show: result.popup_n data: data.popup_n &#125;]&#125;) 逻辑后移之后，前端只需负责拿幕帘字段做展示就可以了，代码变成这样： 123this.setData(&#123; popup: data.popup&#125;) 复用模板插件京喜首页作为电商系统的门户，需要应对各类频繁的营销活动、升级改版等，同时也要满足不同用户属性的界面个性化需求（俗称 “千人千面”）。如何既能减少为应对多样化场景而产生的代码量，又可以提升研发效率，成为燃眉之急。 类似于组件复用的理念，我们需要提供更丰富的可配置能力，实现更高的代码复用度。参考小时候很喜欢玩的 “乐高” 积木玩具，我们把首页模块的模板元素作颗粒度更细的划分，根据样式和功能抽象出一块块“积木”原料（称为插件元素）。当首页模块在处理接口数据时，会启动插件引擎逐个装载插件，最终输出个性化的模板样式，整个流程就好比堆积木。当后续产品/运营需要新增模板时，只要在插件库中挑选插件排列组合即可，不需要额外新增/修改组件内容，也更不会产生难以维护的 if / else 逻辑，so easy～ 当然，要完成这样的插件化改造免不了几个先决条件： 用户体验设计的统一。如果设计风格总是天差地别的，强行插件化只会成为累赘。 服务端接口的统一。同上，如果得浪费大量的精力来兼容不同模块间的接口字段差异，将会非常蛋疼。 下面为大家提供部分例程来辅助理解。其中，use 方法会接受各类处理钩子最终拼接出一个 Function，在对应模块处理数据时会被调用。 1234567891011121314151617181920212223242526272829303132333435// bi.helper.js/** * 插件引擎 * @param &#123;function&#125; options.formatName 标题处理钩子 * @param &#123;function&#125; options.validList 数据校验器钩子 */ const use = options =&gt; data =&gt; format(data)/** * 预置插件库 */ nameHelpers = &#123; text: data =&gt; data.text, icon: data =&gt; data.icon&#125;listHelpers = &#123; single: list =&gt; list.slice(0, 1), double: list =&gt; list.slice(0, 2)&#125;/** * “堆积木” */export default &#123; 1000: use(&#123; formatName: nameHelpers.text, validList: listHelpers.single &#125;), 1001: use(&#123; formatName: nameHelpers.icon, validList: listHelpers.double &#125;)&#125; 12345678910&lt;!-- bi.wxml --&gt;&lt;!-- 各模板节点实现 --&gt;&lt;template name=\"renderName\"&gt; &lt;view wx:if=\"&#123;&#123;type === 'text'&#125;&#125;\"&gt; text &lt;/view&gt; &lt;view wx:elif=\"&#123;&#123;type === 'icon'&#125;&#125;\"&gt; icon &lt;/view&gt;&lt;/template&gt;&lt;view class=\"bi__name\"&gt; &lt;template is=\"renderName\" data=\"&#123;&#123;...data.name&#125;\"/&gt;&lt;/view&gt; 12345678910// bi.jsComponent(&#123; ready() &#123; // 根据 tpl 值选择解析函数 const formatData = helper[data.tpl] this.setData(&#123; data: formatData(data) &#125;) &#125;&#125;) 分包加载小程序启动时只会下载主包/独立分包，启用分包可以有效减少下载时间。（独立）分包需要遵循一些原则，详细的可以看官方文档： 使用分包 独立分包 部分页面 h5 化小程序提供了 web-view 组件，支持在小程序环境内访问网页。当实在无法在小程序代码包中腾出多余空间时，可以考虑降级方案 —— 把部分页面 h5 化。 小程序和 h5 的通信可以通过 JSSDK 或 postMessage 通道来实现，详见 小程序开发文档。 白屏时间过长？白屏阶段，是指小程序代码包下载完（也就是启动界面结束）之后，页面完成首屏渲染的这一阶段，也就是 FMP (首次有效绘制)。 FMP 没法用标准化的指标定义，但对于大部分小程序来说，页面首屏展示的内容都需要依赖服务端的接口数据，那么影响白屏加载时间的主要由这两个元素构成： 网络资源加载时间； 渲染时间； 启用本地缓存小程序提供了读写本地缓存的接口，数据存储在设备硬盘上。由于本地 I/O 读写（毫秒级）会比网络请求（秒级）要快很多，所以在用户访问页面时，可以优先从缓存中取上一次接口调用成功的数据来渲染视图，待网络请求成功后再覆盖最新数据重新渲染。除此之外，缓存数据还可以作为兜底数据，避免出现接口请求失败时页面空窗，一石二鸟。 但并非所有场景都适合缓存策略，譬如对数据即时性要求非常高的场景（如抢购入口）来说，展示老数据可能会引发一些问题。 小程序默认会按照 不同小程序、不同微信用户 这两个维度对缓存空间进行隔离。诸如京喜小程序首页也采用了缓存策略，会进一步按照 数据版本号、用户属性 来对缓存进行再隔离，避免信息误展示。 数据预拉取小程序官方为开发者提供了一个在小程序冷启动时提前拉取第三方接口的能力：数据预拉取。 关于冷启动和热启动的定义可以看 这里 数据预拉取的原理其实很简单，就是在小程序启动时，微信服务器代理小程序客户端发起一个 HTTP 请求到第三方服务器来获取数据，并且把响应数据存储在本地客户端供小程序前端调取。当小程序加载完成后，只需调用微信提供的 API wx.getBackgroundFetchData 从本地缓存获取数据即可。这种做法可以充分利用小程序启动和初始化阶段的等待时间，使更快地完成页面渲染。 京喜小程序首页已经在生产环境实践过这个能力，从每日千万级的数据分析得出，预拉取使冷启动时获取到接口数据的时间节点从 2.5s 加速到 1s（提速了 60%）。虽然提升效果非常明显，但这个能力依然存在一些不成熟的地方： 预拉取的数据会被强缓存； 由于预拉取的请求最终是由微信的服务器发起的，也许是出于服务器资源限制的考虑，预拉取的数据会缓存在微信本地一段时间，缓存失效后才会重新发起请求。经过真机实测，在微信购物入口冷启动京喜小程序的场景下，预拉取缓存存活了 30 分钟以上，这对于数据实时性要求比较高的系统来说是非常致命的。 请求体和响应体都无法被拦截； 由于请求第三方服务器是从微信的服务器发起的，而不是从小程序客户端发起的，所以本地代理无法拦截到这一次真实请求，这会导致开发者无法通过拦截请求的方式来区分获取线上环境和开发环境的数据，给开发调试带来麻烦。 小程序内部接口的响应体类型都是 application/octet-stream，即数据格式未知，使本地代理无法正确解析。 微信服务器发起的请求没有提供区分线上版和开发版的参数，且没有提供用户 IP 等信息； 如果这几个问题点都不会影响到你的场景，那么可以尝试开启预拉取能力，这对于小程序首屏渲染速度是质的提升。 跳转时预拉取为了尽快获取到服务端数据，比较常见的做法是在页面 onLoad 钩子被触发时发起网络请求，但其实这并不是最快的方式。从发起页面跳转，到下一个页面 onLoad 的过程中，小程序需要完成一些环境初始化及页面实例化的工作，耗时大概为 300 ~ 400 毫秒。 实际上，我们可以在发起跳转前（如 wx.navigateTo 调用前），提前请求下一个页面的主接口并存储在全局 Promise 对象中，待下个页面加载完成后从 Promise 对象中读取数据即可。 这也是双线程模型所带来的优势之一，不同于多页面 web 应用在页面跳转/刷新时就销毁掉 window 对象。 分包预下载如果开启了分包加载能力，在用户访问到分包内某个页面时，小程序才会开始下载对应的分包。当处于分包下载阶段时，页面会维持在 “白屏” 的启动态，这用户体验是比较糟糕的。 幸好，小程序提供了 分包预下载 能力，开发者可以配置进入某个页面时预下载可能会用到的分包，避免在页面切换时僵持在 “白屏” 态。 非关键渲染数据延迟请求这是关键渲染路径优化的其中一个思路，从缩短网络请求时延的角度加快首屏渲染完成时间。 关键渲染路径（Critical Rendering Path） 是指在完成首屏渲染的过程中必须发生的事件。 以京喜小程序如此庞大的小程序项目为例，每个模块背后都可能有着海量的后台服务作支撑，而这些后台服务间的通信和数据交互都会存在一定的时延。我们根据京喜首页的页面结构，把所有模块划分成两类：主体模块（导航、商品轮播、商品豆腐块等）和 非主体模块（幕帘弹窗、右侧挂件等）。 在初始化首页时，小程序会发起一个聚合接口请求来获取主体模块的数据，而非主体模块的数据则从另一个接口获取，通过拆分的手段来降低主接口的调用时延，同时减少响应体的数据量，缩减网络传输时间。 分屏渲染这也是关键渲染路径优化思路之一，通过延迟非关键元素的渲染时机，为关键渲染路径腾出资源。 类似上一条措施，继续以京喜小程序首页为例，我们在 主体模块 的基础上再度划分出 首屏模块（商品豆腐块以上部分） 和 非首屏模块（商品豆腐块及以下部分）。当小程序获取到主体模块的数据后，会优先渲染首屏模块，在所有首屏模块都渲染完成后才会渲染非首屏模块和非主体模块，以此确保首屏内容以最快速度呈现。 为了更好地呈现效果，上面 gif 做了降速处理 接口聚合，请求合并在小程序中，发起网络请求是通过 wx.request 这个 API。我们知道，在 web 浏览器中，针对同一域名的 HTTP 并发请求数是有限制的；在小程序中也有类似的限制，但区别在于不是针对域名限制，而是针对 API 调用： wx.request （HTTP 连接）的最大并发限制是 10 个； wx.connectSocket （WebSocket 连接）的最大并发限制是 5 个； 超出并发限制数目的 HTTP 请求将会被阻塞，需要在队列中等待前面的请求完成，从而一定程度上增加了请求时延。因此，对于职责类似的网络请求，最好采用节流的方式，先在一定时间间隔内收集数据，再合并到一个请求体中发送给服务端。 图片资源优化图片资源一直是移动端系统中抢占大流量的部分，尤其是对于电商系统。优化图片资源的加载可以有效地加快页面响应时间，提升首屏渲染速度。 使用 WebP 格式 WebP 是 Google 推出的一种支持有损/无损压缩的图片文件格式，得益于更优的图像数据压缩算法，其与 JPG、PNG 等格式相比，在肉眼无差别的图片质量前提下具有更小的图片体积（据官方说明，WebP 无损压缩体积比 PNG 小 26%，有损压缩体积比 JPEG 小 25-34%）。 小程序的 image 组件 支持 JPG、PNG、SVG、WEBP、GIF 等格式。 图片裁剪&amp;降质 鉴于移动端设备的分辨率是有上限的，很多图片的尺寸常常远大于页面元素尺寸，这非常浪费网络资源（一般图片尺寸 2 倍于页面元素真实尺寸比较合适）。得益于京东内部强大的图片处理服务，我们可以通过资源的命名规则和请求参数来获取服务端优化后的图片： 裁剪成 100x100 的图片：https://{host}/s100x100_jfs/{file_path}； 降质 70%：https://{href}!q70； 图片懒加载、雪碧图（CSS Sprite）优化 这两者都是比较老生常谈的图片优化技术，这里就不打算细讲了。 小程序的 image 组件 自带 lazy-load 懒加载支持。雪碧图技术（CSS Sprite）可以参考 w3schools 的教程。 降级加载大图资源 在不得不使用大图资源的场景下，我们可以适当使用 “体验换速度” 的措施来提升渲染性能。 小程序会把已加载的静态资源缓存在本地，当短时间内再次发起请求时会直接从缓存中取资源（与浏览器行为一致）。因此，对于大图资源，我们可以先呈现高度压缩的模糊图片，同时利用一个隐藏的 &lt;image&gt; 节点来加载原图，待原图加载完成后再转移到真实节点上渲染。整个流程，从视觉上会感知到图片从模糊到高清的过程，但与对首屏渲染的提升效果相比，这点体验落差是可以接受的。 下面为大家提供部分例程： 12345678910&lt;!-- banner.wxml --&gt;&lt;image src=\"&#123;&#123;url&#125;&#125;\" /&gt;&lt;!-- 图片加载器 --&gt;&lt;image style=\"width:0;height:0;display:none\" src=\"&#123;&#123;preloadUrl&#125;&#125;\" bindload=\"onImgLoad\" binderror=\"onErrorLoad\"/&gt; 1234567891011121314151617// banner.jsComponent(&#123; ready() &#123; this.originUrl = 'https://path/to/picture' // 图片源地址 this.setData(&#123; url: compress(this.originUrl) // 加载压缩降质的图片 preloadUrl: this.originUrl // 预加载原图 &#125;) &#125;, methods: &#123; onImgLoad() &#123; this.setData(&#123; url: this.originUrl // 加载原图 &#125;) &#125; &#125;&#125;) 注意，具有 display: none 样式的 &lt;image&gt; 标签只会加载图片资源，但不渲染。 京喜首页的商品轮播模块也采用了这种降级加载方案，在首屏渲染时只会加载第一帧降质图片。以每帧原图 20~50kb 的大小计算，这一措施可以在初始化阶段节省掉几百 kb 的网络资源请求。 为了更好地呈现效果，上面 gif 做了降速处理 骨架屏一方面，我们可以从降低网络请求时延、减少关键渲染的节点数这两个角度出发，缩短完成 FMP（首次有效绘制）的时间。另一方面，我们也需要从用户感知的角度优化加载体验。 “白屏” 的加载体验对于首次访问的用户来说是难以接受的，我们可以使用尺寸稳定的骨架屏，来辅助实现真实模块占位和瞬间加载。 骨架屏目前在业界被广泛应用，京喜首页选择使用灰色豆腐块作为骨架屏的主元素，大致勾勒出各模块主体内容的样式布局。由于微信小程序不支持 SSR（服务端渲染），使动态渲染骨架屏的方案难以实现，因此京喜首页的骨架屏是通过 WXSS 样式静态渲染的。 有趣的是，京喜首页的骨架屏方案经历了 “统一管理” 和 “（组件）独立管理” 两个阶段。出于避免对组件的侵入性考虑，最初的骨架屏是由一个完整的骨架屏组件统一管理的： 12345&lt;!-- index.wxml --&gt;&lt;skeleton wx:if=\"&#123;&#123;isLoading&#125;&#125;\"&gt;&lt;/skeleton&gt;&lt;block wx:else&gt; 页面主体&lt;/block&gt; 但这种做法的维护成本比较高，每次页面主体模块更新迭代，都需要在骨架屏组件中的对应节点同步更新（譬如某个模块的尺寸被调整）。除此之外，感官上从骨架屏到真实模块的切换是跳跃式的，这是因为骨架屏组件和页面主体节点之间的关系是整体条件互斥的，只有当页面主体数据 Ready（或渲染完毕）时才会把骨架屏组件销毁，渲染（或展示）主体内容。 为了使用户感知体验更加丝滑，我们把骨架屏元素拆分放到各个业务组件中，骨架屏元素的显示/隐藏逻辑由业务组件内部独立管理，这就可以轻松实现 “谁跑得快，谁先出来” 的并行加载效果。除此之外，骨架屏元素与业务组件共用一套 WXML 节点，且相关样式由公共的 sass 模块集中管理，业务组件只需要在适当的节点挂上 skeleton 和 skeleton__block 样式块即可，极大地降低了维护成本。 1234&lt;!-- banner.wxml --&gt;&lt;view class=\"&#123;&#123;isLoading ? 'banner--skeleton' : ''&#125;&#125;\"&gt; &lt;view class=\"banner_wrapper\"&gt;&lt;/view&gt;&lt;/view&gt; 1234567// banner.scss.banner--skeleton &#123; @include skeleton; .banner_wrapper &#123; @include skeleton__block; &#125;&#125; 上面的 gif 在压缩过程有些小问题，大家可以直接访问【京喜】小程序体验骨架屏效果。 如何提升渲染性能？当调用 wx.navigateTo 打开一个新的小程序页面时，小程序框架会完成这几步工作： 1. 准备新的 webview 线程环境，包括基础库的初始化； 2. 从逻辑层到视图层的初始数据通信； 3. 视图层根据逻辑层的数据，结合 WXML 片段构建出节点树（包括节点属性、事件绑定等信息），最终与 WXSS 结合完成页面渲染； 由于微信会提前开始准备 webview 线程环境，所以小程序的渲染损耗主要在后两者 数据通信 和 节点树创建/更新 的流程中。相对应的，比较有效的渲染性能优化方向就是： 降低线程间通信频次； 减少线程间通信的数据量； 减少 WXML 节点数量； 合并 setData 调用尽可能地把多次 setData 调用合并成一次。 我们除了要从编码规范上践行这个原则，还可以通过一些技术手段降低 setData 的调用频次。譬如，把同一个时间片（事件循环）内的 setData 调用合并在一起，Taro 框架就使用了这个优化手段。 在 Taro 框架下，调用 setState 时提供的对象会被加入到一个数组中，当下一次事件循环执行的时候再把这些对象合并一起，通过 setData 传递给原生小程序。 12// 小程序里的时间片 APIconst nextTick = wx.nextTick ? wx.nextTick : setTimeout; 只把与界面渲染相关的数据放在 data 中不难得出，setData 传输的数据量越多，线程间通信的耗时越长，渲染速度就越慢。根据微信官方测得的数据，传输时间和数据量大体上呈正相关关系： 上图来自小程序官方开发指南 所以，与视图层渲染无关的数据尽量不要放在 data 中，可以放在页面（组件）类的其他字段下。 应用层的数据 diff每当调用 setData 更新数据时，会引起视图层的重新渲染，小程序会结合新的 data 数据和 WXML 片段构建出新的节点树，并与当前节点树进行比较得出最终需要更新的节点（属性）。 即使小程序在底层框架层面已经对节点树更新进行了 diff，但我们依旧可以优化这次 diff 的性能。譬如，在调用 setData 时，提前确保传递的所有新数据都是有变化的，也就是针对 data 提前做一次 diff。 Taro 框架内部做了这一层优化。在每次调用原生小程序的 setData 之前，Taro 会把最新的 state 和当前页面实例的 data 做一次 diff，筛选出有必要更新的数据再执行 setData。 附 Taro 框架的 数据 diff 规则 去掉不必要的事件绑定当用户事件（如 Click、Touch 事件等）被触发时，视图层会把事件信息反馈给逻辑层，这也是一个线程间通信的过程。但，如果没有在逻辑层中绑定事件的回调函数，通信将不会被触发。 所以，尽量减少不必要的事件绑定，尤其是像 onPageScroll 这种会被频繁触发的用户事件，会使通信过程频繁发生。 去掉不必要的节点属性组件节点支持附加自定义数据 dataset（见下面例子），当用户事件被触发时，视图层会把事件 target 和 dataset 数据传输给逻辑层。那么，当自定义数据量越大，事件通信的耗时就会越长，所以应该避免在自定义数据中设置太多数据。 12345678&lt;!-- wxml --&gt;&lt;view data-a='A' data-b='B' bindtap='bindViewTap'&gt; Click Me!&lt;/view&gt; 123456// jsPage(&#123; bindViewTap(e) &#123; console.log(e.currentTarget.dataset) &#125;&#125;) 适当的组件颗粒度小程序的组件模型与 Web Components 标准中的 ShadowDOM 非常类似，每个组件都有独立的节点树，拥有各自独立的逻辑空间（包括独立的数据、setData 调用、createSelectorQuery 执行域等）。 不难得出，如果自定义组件的颗粒度太粗，组件逻辑过重，会影响节点树构建和新/旧节点树 diff 的效率，从而影响到组件内 setData 的性能。另外，如果组件内使用了 createSelectorQuery 来查找节点，过于庞大的节点树结构也会影响查找效率。 我们来看一个场景，京喜首页的 “京东秒杀” 模块涉及到一个倒计时特性，是通过 setInterval 每秒调用 setData 来更新表盘时间。我们通过把倒计时抽离出一个基础组件，可以有效降低频繁 setData 时的性能影响。 适当的组件化，既可以减小数据更新时的影响范围，又能支持复用，何乐而不为？诚然，并非组件颗粒度越细越好，组件数量和小程序代码包大小是正相关的。尤其是对于使用编译型框架（如 Taro）的项目，每个组件编译后都会产生额外的运行时代码和环境 polyfill，so，为了代码包空间，请保持理智… 事件总线，替代组件间数据绑定的通信方式WXML 数据绑定是小程序中父组件向子组件传递动态数据的较为常见的方式，如下面例程所示：Component A 组件中的变量 a、b 通过组件属性传递给 Component B 组件。在此过程中，不可避免地需要经历一次 Component A 组件的 setData 调用方可完成任务，这就会产生线程间的通信。“合情合理”，但，如果传递给子组件的数据只有一部分是与视图渲染有关呢？ 12&lt;!-- Component A --&gt;&lt;component-b prop-a=\"&#123;&#123;a&#125;&#125;\" prop-b=\"&#123;&#123;b&#125;&#125;\" /&gt; 12345678910111213// Component BComponent(&#123; properties: &#123; propA: String, propB: String, &#125;, methods: &#123; onLoad: function() &#123; this.data.propA this.data.propB &#125; &#125;&#125;) 推荐一种特定场景下非常便捷的做法：通过事件总线（EventBus），也就是发布/订阅模式，来完成由父向子的数据传递。其构成非常简单（例程只提供关键代码…）： 一个全局的事件调度中心 1234567891011121314151617class EventBus &#123; constructor() &#123; this.events = &#123;&#125; &#125; on(key, cb) &#123; this.events[key].push(cb) &#125; trigger(key, args) &#123; this.events[key].forEach(function (cb) &#123; cb.call(this, ...args) &#125;) &#125; remove() &#123;&#125;&#125;const event = new EventBus() 事件订阅者 123456// 子组件Component(&#123; created() &#123; event.on('data-ready', (data) =&gt; &#123; this.setData(&#123; data &#125;) &#125;) &#125;&#125;) 事件发布者 123456// ParentComponent(&#123; ready() &#123; event.trigger('data-ready', data) &#125;&#125;) 子组件被创建时事先监听数据下发事件，当父组件获取到数据后触发事件把数据传递给子组件，这整个过程都是在小程序的逻辑层里同步执行，比数据绑定的方式速度更快。 但并非所有场景都适合这种做法。像京喜首页这种具有 “数据单向传递”、“展示型交互” 特性、且 一级子组件数量庞大 的场景，使用事件总线的效益将会非常高；但若是频繁 “双向数据流“ 的场景，用这种方式会导致事件交错难以维护。 题外话，Taro 框架在处理父子组件间数据传递时使用的是观察者模式，通过 Object.defineProperty 绑定父子组件关系，当父组件数据发生变化时，会递归通知所有后代组件检查并更新数据。这个通知的过程会同步触发数据 diff 和一些校验逻辑，每个组件跑一遍大概需要 5 ~ 10 ms 的时间。所以，如果组件量级比较大，整个流程下来时间损耗还是不小的，我们依旧可以尝试事件总线的方案。 组件层面的 diff我们可能会遇到这样的需求，多个组件之间位置不固定，支持随时随地灵活配置，京喜首页也存在类似的诉求。 京喜首页主体可被划分为若干个业务组件（如搜索框、导航栏、商品轮播等），这些业务组件的顺序是不固定的，今天是搜索框在最顶部，明天有可能变成导航栏在顶部了（夸张了…）。我们不可能针对多种顺序可能性提供多套实现，这就需要用到小程序的自定义模板 &lt;template&gt;。 实现一个支持调度所有业务组件的模板，根据后台下发的模块数组按序循环渲染模板，如下面例程所示。 123456789101112131415&lt;!-- index.wxml --&gt;&lt;template name=\"render-component\"&gt; &lt;search-bar wx:if=\"&#123;&#123;compId === 'SearchBar'&#125;&#125;\" floor-id=\"&#123;&#123;index&#125;&#125;\" /&gt; &lt;nav-bar wx:if=\"&#123;&#123;compId === 'NavBar'&#125;&#125;\" floor-id=\"&#123;&#123;index&#125;&#125;\" /&gt; &lt;banner wx:if=\"&#123;&#123;compId === 'Banner'&#125;&#125;\" floor-id=\"&#123;&#123;index&#125;&#125;\" /&gt; &lt;icon-nav wx:if=\"&#123;&#123;compId === 'IconNav'&#125;&#125;\" floor-id=\"&#123;&#123;index&#125;&#125;\" /&gt;&lt;/template&gt;&lt;view class=\"component-wrapper\" wx:for=\"&#123;&#123;comps&#125;&#125;\" wx:for-item=\"comp\"&gt; &lt;template is=\"render-component\" data=\"&#123;&#123;...comp&#125;&#125;\"/&gt;&lt;/view&gt; 1234567891011// search-bar.jsComponent(&#123; properties: &#123; floorId: Number, &#125;, created() &#123; event.on('data-ready', (comps) =&gt; &#123; const data = comps[this.data.floorId] // 根据楼层位置取数据 &#125;) &#125;&#125;) 貌似非常轻松地完成需求，但值得思考的是：如果组件顺序调整了，所有组件的生命周期会发生什么变化？ 假设，上一次渲染的组件顺序是 [&#39;search-bar&#39;，&#39;nav-bar&#39;，&#39;banner&#39;, &#39;icon-nav&#39;]，现在需要把 nav-bar 组件去掉，调整为 [&#39;search-bar&#39;，&#39;banner&#39;, &#39;icon-nav&#39;]。经实验得出，当某个组件节点发生变化时，其前面的组件不受影响，其后面的组件都会被销毁重新挂载。 原理很简单，每个组件都有各自隔离的节点树（ShadowTree），页面 body 也是一个节点树。在调整组件顺序时，小程序框架会遍历比较新/旧节点树的差异，于是发现新节点树的 nav-bar 组件节点不见了，就认为该（树）分支下从 nav-bar 节点起发生了变化，往后节点都需要重渲染。 但实际上，这里的组件顺序是没有变化的，丢失的组件按道理不应该影响到其他组件的正常渲染。所以，我们在 setData 前先进行了新旧组件列表 diff：如果 newList 里面的组件是 oldList 的子集，且相对顺序没有发生变化，则所有组件不重新挂载。除此之外，我们还要在接口数据的相应位置填充上空数据，把该组件隐藏掉，done。 通过组件 diff 的手段，可以有效降低视图层的渲染压力，如果有类似场景的朋友，也可以参考这种方案。 内存占用过高？想必没有什么会比小程序 Crash 更影响用户体验了。 当小程序占用系统资源过高，就有可能会被系统销毁或被微信客户端主动回收。应对这种尴尬场景，除了提示用户提升硬件性能之外（譬如来京东商城买新手机），还可以通过一系列的优化手段降低小程序的内存损耗。 内存预警小程序提供了监听内存不足告警事件的 API：wx.onMemoryWarning，旨在让开发者收到告警时及时释放内存资源避免小程序 Crash。然而对于小程序开发者来说，内存资源目前是无法直接触碰的，最多就是调用 wx.reLaunch 清理所有页面栈，重载当前页面，来降低内存负荷（此方案过于粗暴，别冲动，想想就好…）。 不过内存告警的信息收集倒是有意义的，我们可以把内存告警信息（包括页面路径、客户端版本、终端手机型号等）上报到日志系统，分析出哪些页面 Crash 率比较高，从而针对性地做优化，降低页面复杂度等等。 回收后台页面计时器根据双线程模型，小程序每一个页面都会独立一个 webview 线程，但逻辑层是单线程的，也就是所有的 webview 线程共享一个 JS 线程。以至于当页面切换到后台态时，仍然有可能抢占到逻辑层的资源，譬如没有销毁的 setInterval、setTimeout 定时器： 1234567// Page APage(&#123; onLoad() &#123; let i = 0 setInterval(() =&gt; &#123; i++ &#125;, 100) &#125;&#125;) 即使如小程序的 &lt;swiper&gt; 组件，在页面进入后台态时依然是会持续轮播的。 正确的做法是，在页面 onHide 的时候手动把定时器清理掉，有必要时再在 onShow 阶段恢复定时器。坦白讲，区区一个定时器回调函数的执行，对于系统的影响应该是微不足道的，但不容忽视的是回调函数里的代码逻辑，譬如在定时器回调里持续 setData 大量数据，这就非常难受了… 避免频发事件中的重度内存操作我们经常会遇到这样的需求：广告曝光、图片懒加载、导航栏吸顶等等，这些都需要我们在页面滚动事件触发时实时监听元素位置或更新视图。在了解小程序的双线程模型之后不难发现，页面滚动时 onPageScroll 被频发触发，会使逻辑层和视图层发生持续通信，若这时候再 “火上浇油” 调用 setData 传输大量数据，会导致内存使用率快速上升，使页面卡顿甚至 “假死”。所以，针对频发事件的监听，我们最好遵循以下原则： onPageScroll 事件回调使用节流； 避免 CPU 密集型操作，譬如复杂的计算； 避免调用 setData，或减小 setData 的数据量； 尽量使用 IntersectionObserver 来替代 SelectorQuery，前者对性能影响更小； 大图、长列表优化据 小程序官方文档 描述，大图片和长列表图片在 iOS 中会引起 WKWebView 的回收，导致小程序 Crash。 对于大图片资源（譬如满屏的 gif 图）来说，我们只能尽可能对图片进行降质或裁剪，当然不使用是最好的。 对于长列表，譬如瀑布流，这里提供一种思路：我们可以利用 IntersectionObserver 监听长列表内组件与视窗之间的相交状态，当组件距离视窗大于某个临界点时，销毁该组件释放内存空间，并用等尺寸的骨架图占坑；当距离小于临界点时，再取缓存数据重新加载该组件。 然而无可避免地，当用户快速滚动长列表时，被销毁的组件可能来不及加载完，视觉上就会出现短暂的白屏。我们可以适当地调整销毁阈值，或者优化骨架图的样式来尽可能提升体验感。 小程序官方提供了一个 长列表组件，可以通过 npm 包的方式引入，有兴趣的可以尝试。 总结结合上述的种种方法论，京喜小程序首页进行全方位升级改造之后给出了答卷： 1. Audits 审计工具的性能得分 86； 2. 优化后的首屏渲染完成时间（FMP）： 3. 优化前后的测速数据对比： 然而，业务迭代在持续推进，多样化的用户场景徒增不减，性能优化将成为我们日常开发中挥之不去的原则和主题。本文以微信小程序开发中与性能相关的问题为出发点，基于小程序的底层框架原理，探究小程序性能体验提升的各种可能性，希望能为各位小程序开发者带来参考价值。 参考 User-centric Performance Metrics Reduce JavaScript Payloads with Tree Shaking 小程序开发指南 小程序官方文档 Taro 官方文档 探究WebP一些事儿 京喜首页（微信购物入口）跨端开发与优化实践","pubDate":"Wed, 25 Mar 2020 10:00:00 GMT","guid":"https://aotu.io/notes/2020/03/25/high-performance-miniprogram/","category":"性能优化"},{"title":"直播回顾·程序媛的成长蜕变","link":"https://aotu.io/notes/2020/03/17/technological-growth/","description":"在平平淡淡的工作中，突然要准备一个直播分享，犹如平地一声雷。预知雷声大不大，请看下文&amp;视频完整版：B站回播地址、牛客网录播地址。 本次分享由腾讯犀牛鸟「云开发」校园技术布道师养成计划邀请，为年轻程序员解答，如何进入学习提升自己、如何找到最适合自己的技术路线以及如何才能在毕业后进入大厂等问题。 本文从两个模块展开，首先分享从小白时期成长为高级工程师的成长历程，然后探讨程序员应该从哪些方面着手，提升自身的技术实力。 一、成长历程分享我的成长历程大致分为 3 个阶段，重构开发阶段、前端开发阶段，然后到全栈开发。 重构开发2015 年处于重构开发阶段。 当时作为一个硬件转软件的大三实习生，实习工作前只学习了一个月前端相关的知识，基础薄弱，一开始每天的工作就是 HTML + CSS 写静态页面，或者就是直接扒网站，改改样式和文案。在项目前后端分离后，才开始做动画和交互的开发工作。 前端开发2016 - 2018 处于前端开发阶段。 2016 年是特别好找工作的一年，投简历有大把的面试，会 HTML + CSS + jQuery + 有项目经验就可以当一个初级的前端开发。在日常工作之余，每周会定一些任务看哪本书，看哪个技术的文档，也开始写技术博客。在工作中，参与开发公司的官网系统，在这个项目的参与过程中，前端构建工具 fis3、css 预编译工具 Sass，当时很流行的 CSS / HTML 框架 Bootstrap，模板引擎 ejs，这些技术都有了实战经验。后来又参与开发员工管理系统，在这个系统中开始用 Angular 搭建项目，有了这些积累，2017 年终于成为了中级前端开发。 初级和中级的不同，更多的差异是在于责任心的比重，初级一般只负责单一模块的开发，中级除了模块的开发，还需要更多承担起项目某一条业务线的管理职责。 技术发展得非常快，前端框架方面，Vue、React 对比 Angular 有更好的性能，Angular 也出到更高的版本，前端构建工具方面，Webpack 对比 fis3，开发更加便捷，扩展性强，在技术新趋势方面，还有小程序业务也越来越多，我也跟着继续学习新技术，根据项目场景进行运用。 题图引用自利用NLP分析三大前端框架的GitHub Issue 全栈开发2019 - 2020 处于全栈开发阶段。 在前端开发的过程中，我也一直想往全栈的方向走，学习 Python、Nodejs、MongoDB、Nginx，有了这些积累，我开始负责全栈项目，在职级上成为了高级前端开发工程师。 在这个过程中，我也从一开始的仅仅为了就业，到喜欢上这份工作，发现编程其实没有我想象中那么难和枯燥，相反，在编程的过程中，解决问题和实现需求都是非常有成就感的一件事情。 和大多数初学者一样，刚开始的时候我非常迷茫，没有做好职业规划就匆匆开始了实习。但是，我的建议是如果你没有想好自己要干什么，一定要先把眼前的事情做好。 二、如何提升技术实力如何提升技术实力，建议先做好这3点：注重基础、实践练习、在过程中多多思考。 基础首先，就我个人经历而言，我认为初学者应该特别注意这个点，要注重基础，应该不能急于求成，欲速则不达，要想快速提高，必须要以慢打快，才能更快。因为对于初学者而言，基础知识，编程语言必须要夯实，只有真正的懂了基础，才能够举一反三。 那么如何学习好基础呢？ 1. 视频教程网上有很多，我在初学阶段也是看的视频教程进行学习，但是但是这种学习方式效率比较低，一个 30 分钟的视频教程讲解的内容，如果是直接看书的话至少可以节省一半时间。不过初学阶段是可以看视频的，有老师讲解会比单看书看文档更加有趣。建议直接在网上搜上一套完整的教学视频，系统的去学。 2. 入门博客在各大论坛网站上去找或者直接百度搜，前端的同学推荐 阮一峰大神的博客、知乎专栏、凹凸官网，看博客对学习也是非常有帮助的。 3. 权威书籍如果想要把基础学扎实，还是推荐看书，尤其是权威书籍，因为书里不会遗漏重点，能提高对技术认知的深度，比如看入门博客，其实这是接受博主的二次传播，博主讲的是他对书对技术的理解，他的理解肯定没有写书的人的理解深，说不定还会遗漏一些重点。所以还不如直接看书。 比如前端的话就一定要去看 JavaScript 高级程序设计、或者 JavaScript 权威指南，这两本书都是学习前端的基石。JavaScript 高级程序设计我就看了很多遍，每一遍都会有新的收获，建议你们也把权威书籍多看几遍，看多了就知道原理了，而不是单单知道怎么敲代码实现。 4. 官方文档一定要学会怎么去看文档，开发的过程中肯定会遇到很多的问题，学会了看文档就可以提高自己解决问题的能力，也可以提高学习新技术的能力。 实践在学习基础知识的同时，也要实践练习。可以从下面 3 个方面着手。 1. 局部练习首先我们要做一些局部练习，比如小型实战、环境搭建、学习时遇到的例子，可以挑一个去实际做一下运行，因为有些东西你可能看的很模糊，这时候你必须得敲一点代码，实际的运行，看看效果，才能真正的理解，并且在实战中才能遇到问题，在解决问题的过程中才是真正的掌握这门技术，实战的过程中要及时记录遇到的问题和如何解决的，长远来看对自己的成长是非常有帮助的。 2. 上手实际项目做了一些小型实战之后，就是上手实际的项目，在实际项目中，可以真正的运用学到的知识，也可以找到自己不足的地方，有很多人不知道自己不知道哪些，做做项目就都知道了。很多在校的学生在学习过程中没有实际项目，没有关系，我们也可以从开源项目着手，从开源项目的源码的学习，是一种最高级的学习方式，也是最高效最能学到东西的，这种开源的学习方式。有个前提，就是前面基础要打牢固，包括计算机网络和数据结构的知识，这都是有能力去玩一个开源项目的基本素质。 3. 造轮子、撸源码学习到更深一层的时候，可以造轮子、出一些源码阅读的文章，或者视频，还可以把东西分享给别人，写一些深度的博客。让大家来参考。这一步是确实比较难达到，我自己也在不断的摸索中。 思考在这里还要再强调一遍学习最关键的一步，就是思考。 1. 学会记录学习的时候，要学会记录总结。在学习的过程中，老师讲的 demo，总结的知识点，自己记录到技术博客中，编程知识点太多，烂熟于心是不可能的，那就不如写博客记录下来。写在博客中，既能分享，又能方便自己查找，还能巩固自己的知识点。而且在博客积累的过程中，也能够为你累积流量，建立自己的 IP，这对找工作也是非常有帮助的。 2. 找到你的导师对于初学者来说还有一点非常重要，那就是给自己找一个老师，每个人都需要一个职场的导师，他可以是你第一份工作的导师，也可以是你认识的其他的前辈。你们需要维系一个非常长期的关系，不止于一家公司，最好贯穿你的整个职业生涯。每当你遇到疑惑的时候，都可以询求他的建议，这将是你最宝贵的一笔人脉财富。我在入行不久也遇到了这样一个老师，他会问我学得怎么样，给我目标，而且还给我开过一对一的课，当然他开课也是因为他自己想往教育这个方向去发展，但是不得不说对我的帮助非常大，我非常感激他。他也和我说过，他的导师对他的影响也很大。 每个人都明白人脉的重要性，但实际做起来却不容易。建议参加一些线下的活动，比如各个开发者大会或者沙龙，这可能是最直接的扩展人脉的方式之一。 三、总结本文分享了程序员的个人成长历程以及如何提升技术实力，程序员的成长之路并不孤单，我们是一个爱分享的群体，也有非常多的社区，看到这里的你，想必已经进入我们这个大社区了，希望本文能给你收获，在技术之路一起成长！","pubDate":"Tue, 17 Mar 2020 10:24:00 GMT","guid":"https://aotu.io/notes/2020/03/17/technological-growth/","category":"Web开发"},{"title":"Web 中文字体处理总结","link":"https://aotu.io/notes/2020/02/28/webfont-processing/","description":"背景介绍Web 项目中，使用一个合适的字体能给用户带来良好的体验。但是字体文件太多，如果想要查看字体效果，只能一个个打开，非常影响工作效率。因此，需要实现一个功能，能够根据固定文字以及用户输入预览字体。在实现这一功能的过程中主要解决两个问题： 中文字体体积太大导致加载时间过长 字体加载完成前不展示预览内容 现在将问题的解决以及我的思考总结成文。 使用 web 自定义字体在聊这两个问题之前，我们先简述怎样使用一个 Web 自定义字体。要想使用一个自定义字体，可以依赖 CSS Fonts Module Level 3 定义的 @font-face 规则。一种基本能够兼容所有浏览器的使用方法如下： 12345678910111213@font-face &#123; font-family: \"webfontFamily\"; /* 名字任意取 */ src: url('webfont.eot'); url('web.eot?#iefix') format(\"embedded-opentype\"), url(\"webfont.woff2\") format(\"woff2\"), url(\"webfont.woff\") format(\"woff\"), url(\"webfont.ttf\") format(\"truetype\"); font-style:normal; font-weight:normal;&#125;.webfont &#123; font-family: webfontFamily; /* @font-face里定义的名字 */&#125; 由于 woff2、woff、ttf 格式在大多数浏览器支持已经较好，因此上面的代码也可以写成： 12345678@font-face &#123; font-family: \"webfontFamily\"; /* 名字任意取 */ src: url(\"webfont.woff2\") format(\"woff2\"), url(\"webfont.woff\") format(\"woff\"), url(\"webfont.ttf\") format(\"truetype\"); font-style:normal; font-weight:normal;&#125; 有了@font-face 规则，我们只需要将字体源文件上传至 cdn，让 @font-face 规则的 url 值为该字体的地址，最后将这个规则应用在 Web 文字上，就可以实现字体的预览效果。 但这么做我们可以明显发现一个问题，字体体积太大导致的加载时间过长。我们打开浏览器的 Network 面板查看： 可以看到字体的体积为5.5 MB，加载时间为5.13 s。而夸克平台很多的中文字体大小在20～40 MB 之间，可以预想到加载时间会进一步增长。如果用户还处于弱网环境下，这个等待时间是不能接受的。 一、中文字体体积太大导致加载时间过长1. 分析原因那么中文字体相较于英文字体体积为什么这么大，这主要是两个方面的原因： 中文字体包含的字形数量很多，而英文字体仅包含26个字母以及一些其他符号。 中文字形的线条远比英文字形的线条复杂，用于控制中文字形线条的位置点比英文字形更多，因此数据量更大。 我们可以借助于 opentype.js，统计一个中文字体和一个英文字体在字形数量以及字形所占字节数的差异: 字体名称 字形数 字形所占字节数 FZQingFSJW_Cu.ttf 8731 4762272 JDZhengHT-Bold.ttf 122 18328 夸克平台字体预览需要满足两种方式，一种是固定字符预览, 另一种是根据用户输入的字符进行预览。但无论哪种预览方式，也仅仅会使用到该字体的少量字符，因此全量加载字体是没有必要的，所以我们需要对字体文件做精简。 2. 如何减小字体文件体积unicode-rangeunicode-range 属性一般配合 @font-face 规则使用，它用于控制特定字符使用特定字体。但是它并不能减小字体文件的大小，感兴趣的读者可以试试。 CSS unicode-range特定字符使用font-face自定义字体 fontminfontmin 是一个纯 JavaScript 实现的字体子集化方案。前文谈到，中文字体体积相较于英文字体更大的原因是其字形数量更多，那么精简一个字体文件的思路就是将无用的字形移除： 1234567// 伪代码const text = '字体预览'const unicodes = text.split('').map(str =&gt; str.charCodeAt(0))const font = loadFont(fontPath)font.glyf = font.glyf.map(g =&gt; &#123; // 根据unicodes获取对应的字形&#125;) 实际上的精简并没有这么简单，因为一个字体文件由许多表(table)构成，这些表之间是存在关联的，例如 maxp 表记录了字形数量，loca 表中存储了字形位置的偏移量。同时字体文件以 offset table(偏移表) 开头，offset table记录了字体所有表的信息，因此如果我们更改了 glyf 表，就要同时去更新其他表。 在讨论 fontmin 如何进行字体截取之前，我们先来了解一下字体文件的结构： 上面的结构限于字体文件只包含一种字体，且字形轮廓是基于 TrueType 格式（决定 sfntVersion 的取值）的情况，因此偏移表会从字体文件的0字节开始。如果字体文件包含多个字体，则每种字体的偏移表会在 TTCHeader 中指定，这种文件不在文章的讨论范围内。 偏移表(offset table)： Type Name Description uint32 sfntVersion 0x00010000 uint16 numTables Number of tables uint16 searchRange (Maximum power of 2 &lt;= numTables) x 16. uint16 entrySelector Log2(maximum power of 2 &lt;= numTables). uint16 rangeShift NumTables x 16-searchRange. 表记录(table record)： Type Name Description uint32 tableTag Table identifier uint32 checkSum CheckSum for this table uint32 offset Offset from beginning of TrueType font file uint32 length Length of this table 对于一个字体文件，无论其字形轮廓是 TrueType 格式还是基于 PostScript 语言的 CFF 格式，其必须包含的表有 cmap、head、hhea、htmx、maxp、name、OS/2、post。如果其字形轮廓是 TrueType 格式，还有cvt、fpgm、glyf、loca、prep、gasp 六张表会被用到。这六张表除了 glyf 和 loca 必选外，其它四个为可选表。 fontmin 截取字形原理fontmin 内部使用了 fonteditor-core，核心的字体处理交给这个依赖完成，fonteditor-core 的主要流程如下： 1. 初始化 Reader将字体文件转为 ArrayBuffer 用于后续读取数据。 2. 提取 Table Directory前文我们说到紧跟在 offset table(偏移表) 之后的结构就是 table record(表记录)，而多个 table record 叫做 Table Directory。fonteditor-core 会先读取原字体的 Table Directory，由上文表记录的结构我们知道，每一个 table record 有四个字段，每个字段占4个字节，因此可以很方便的利用 DataView 进行读取，最终得到一个字体文件的所有表信息如下： 3. 读取表数据在这一步会根据 Table Directory 记录的偏移和长度信息读取表数据。对于精简字体来说，glyf 表的内容是最重要的，但是 glyf 的 table record 仅仅告诉了我们 glyf 表的长度以及 glyf 表相对于整个字体文件的偏移量，那么我们如何得知 glyf 表中字形的数量、位置以及大小信息呢？这需要借助字体中的 maxp 表和 loca(glyphs location) 表，maxp 表的 numGlyphs 字段值指定了字形数量，而 loca 表记录了字体中所有字形相对于 glyf 表的偏移量，它的结构如下： Glyph Index Offset Glyph Length 0 0 100 1 100 150 2 250 0 … … … n-1 1170 120 extra 1290 0 根据规范，索引0指向缺失字符(missing character)，也就是字体中找不到某个字符时出现的字符，这个字符通常用空白框或者空格表示，当这个缺失字符不存在轮廓时，根据 loca 表的定义可以得到 loca[n] = loca[n+1]。我们可以发现上文表格中多出了 extra 一项，这是为了计算最后一个字形 loca[n-1] 的长度。 上述表格中 Offset 字段值的单位是字节，但是具体的字节数取决于字体 head 表的 indexToLocFormat 字段取值，当此值为0时，Offset 100 等于 200 个字节，当此值为1时，Offset 100 等于 100 个字节，这两种不同的情况对应于字体中的 Short version 和 Long version。 但是仅仅知道所有字形的偏移量还不够，我们没办法认出哪个字形才是我们需要的。假设我需要字体预览这四个字形，而字体文件有一万个字形，同时我们通过 loca 表得知了所有字形的偏移量，但这一万里面哪四个数据块代表了字体预览四个字符呢？因此我们还需要借助 cmap 表来确定具体的字形位置，cmap 表里记录了字符代码(unicode)到字形索引的映射，我们拿到对应的字形索引后，就可以根据索引获得该字形在 glyf 表中的偏移量。 而一个字形的数据结构以 Glyph Headers 开头： Type Name Description int16 numberOfContours the number of contours int16 xMin Minimum x for coordinate data int16 yMin Maximum y for coordinate data int16 xMax Minimum x for coordinate data int16 yMax Maximum x for coordinate data numberOfContours 字段指定了这个字形的轮廓数量，紧跟在 Glyph Headers 后面的数据结构为 Glyph Table。 在字体的定义中，轮廓是由一个个位置点构成的，并且每个位置点具有编号，这些编号从0开始按升序排列。因此我们读取指定的字形就是读取 Glyph Headers 中的各项值以及轮廓的位置点坐标。 在 Glyph Table 中，存放了每个轮廓的最后一个位置点编号构成的数组，从这个数组中就可以求得这个字形一共存在几个位置点。例如这个数组的值为[3, 6, 9, 15]，可以得知第四个轮廓上最后一个位置点的编号是15，那么这个字形一共有16个位置点，所以我们只需要以16为循环次数进行遍历访问 ArrayBuffer 就可以得到每个位置点的坐标信息，从而提取出了我们想要的字形，这也就是 fontmin 在截取字形时的原理。 另外，在提取坐标信息时，除了第一个位置点，其他位置点的坐标值并不是绝对值，例如第一个点的坐标为[100, 100]，第二个读取到的值为[200, 200]，那么该点位置坐标并不是[200, 200]，而是基于第一个点的坐标进行增量，因此第二点的实际坐标为[300, 300] 因为一个字体涉及的表实在太多，并且每个表的数据结构也不一样。这里无法一一列举 fonteditor-core 是如何处理每个表的。 4. 关联glyf信息在使用了 TrueType 轮廓的字体中，每个字形都提供了 xMin、xMax、yMin 和 yMax 的值，这四个值也就是下图的Bounding Box。除了这四个值，还需要 advanceWidth 和 leftSideBearing 两个字段，这两个字段并不在 glyf 表中，因此在截取字形信息的时候无法获取。在这个步骤，fonteditor-core 会读取字体的 hmtx 表获取这两个字段。 5. 写入字体在这一步会重新计算字体文件的大小，并且更新偏移表(Offset table)和表记录(Table record)有关的值, 然后依次将偏移表、表记录、表数据写入文件中。有一点需要注意的是，在写入表记录时，必须按照表名排序进行写入。例如有四张表分别是 prep、hmtx、glyf、head、则写入的顺序应为 glyf -&gt; head -&gt; hmtx -&gt; prep，而表数据没有这个要求。 fontmin 不足之处fonteditor-core 在截取字体的过程中只会对前文提到的十四张表进行处理，其余表丢弃。每个字体通常还会包含 vhea 和 vmtx 两张表，它们用于控制字体在垂直布局时的间距等信息，如果用 fontmin 进行字体截取后，会丢失这部分信息，可以在文本垂直显示时看出差异（右边为截取后）： fontmin 使用方法在了解了 fontmin 的原理后，我们就可以愉快的使用它啦。服务器接受到客户端发来的请求后，通过 fontmin 截取字体，fontmin 会返回截取后的字体文件对应的 Buffer，别忘了 @font-face 规则中字体路径是支持 base64 格式的，因此我们只需要将 Buffer 转为 base64 格式嵌入在 @font-face 中返回给客户端，然后客户端将该 @font-face 以 CSS 形式插入 &lt;head&gt;&lt;/head&gt; 标签中即可。 对于固定的预览内容，我们也可以先生成字体文件保存在 CDN 上，但是这个方式的缺点在于如果 CDN 不稳定就会造成字体加载失败。如果用上面的方法，每一个截取后的字体以 base64 字符串形式存在，则可以在服务端做一个缓存，就没有这个问题。利用 fontmin 生成字体子集代码如下： 123456789101112131415const Fontmin = require('fontmin')const Promise = require('bluebird')async function extractFontData (fontPath) &#123; const fontmin = new Fontmin() .src('./font/senty.ttf') .use(Fontmin.glyph(&#123; text: '字体预览' &#125;)) .use(Fontmin.ttf2woff2()) .dest('./dist') await Promise.promisify(fontmin.run, &#123; context: fontmin &#125;)()&#125;extractFontData() 对于固定预览内容我们可以预先生成好分割后的字体，对于用户输入的动态预览内容，我们当然也可以按照这个流程： 获取输入 -&gt; 截取字形 -&gt; 上传 CDN -&gt; 生成 @font-face -&gt; 插入页面 按照这个流程来客户端需要请求两次才能获取字体资源（别忘了在 @font-face 插入页面后才会去真正请求字体），并且截取字形和上传 CDN 这两步时间消耗也比较长，有没有更好的办法呢？我们知道字形的轮廓是由一系列位置点确定的，因此我们可以获取 glyf 表中的位置点坐标，通过 SVG 图像将特定字形直接绘制出来。 SVG 是一种强大的图像格式，可以使用 CSS 和 JavaScript 与它们进行交互，在这里主要应用了 path 元素 获取位置信息以及生成 path 标签我们可以借助 opentype.js 完成，客户端得到输入字形的 path 元素后，只需要遍历生成 SVG 标签即可。 3. 减小字体文件体积的优势下面附上字体截取后文件大小和加载速度对比表格。可以看出，相较于全量加载，对字体进行截取后加载速度快了145 倍。 fontmin 是支持生成 woff2 文件的，但是官方文档并没有更新，最开始我使用的 woff 文件，但是 woff2 格式文件体积更小并且浏览器支持不错 字体名称 大小 时间 HanyiSentyWoodcut.ttf 48.2MB 17.41s HanyiSentyWoodcut.woff 21.7KB 0.19s HanyiSentyWoodcut.woff2 12.2KB 0.12s 二、字体加载完成前不展示预览内容这是在实现预览功能过程中的第二个问题。 在浏览器的字体显示行为中存在阻塞期和交换期两个概念，以 Chrome 为例，在字体加载完成前，会有一段时间显示空白，这段时间被称为阻塞期。如果在阻塞期内仍然没有加载完成，就会先显示后备字体，进入交换期，等待字体加载完成后替换。这就会导致页面字体出现闪烁，与我想要的效果不符。而 font-display 属性控制浏览器的这个行为，是否可以更换 font-display 属性的取值来达到我们的目的呢？ font-display Block Period Swap Period block Short Infinite swap None Infinite fallback Extremely Short Short optional Extremely Short None 字体的显示策略和 font-display 的取值有关，浏览器默认的 font-display 值为 auto，它的行为和取值 block 较为接近。 第一种策略是 FOIT(Flash of Invisible Text)，FOIT 是浏览器在加载字体的时候的默认表现形式，其规则如前文所说。 第二种策略是 FOUT(Flash of Unstyled Text)，FOUT 会指示浏览器使用后备字体直至自定义字体加载完成，对应的取值为 swap。 两种不同策略的应用：Google Fonts FOIT&emsp;汉仪字库 FOUT 在夸克项目中，我希望的效果是字体加载完成前不展示预览内容，FOIT 策略最为接近。但是 FOIT 文本内容不可见的最长时间大约是3s， 如果用户网络状况不太好，那么3s过后还是会先显示后备字体，导致页面字体闪烁，因此 font-display 属性不满足要求。 查阅资料得知，CSS Font Loading API 在 JavaScript 层面上也提供了解决方案： FontFace、FontFaceSet先看看它们的兼容性： 又是 IE，IE 没有用户不用管 我们可以通过 FontFace 构造函数构造出一个 FontFace 对象： const fontFace = new FontFace(family, source, descriptors) family 字体名称，指定一个名称作为 CSS 属性 font-family 的值， source 字体来源，可以是一个 url 或者 ArrayBuffer descriptors optional style：font-style weight：font-weight stretch：font-stretch display: font-display （这个值可以设置，但不会生效） unicodeRange：@font-face 规则的 unicode-ranges variant：font-variant featureSettings：font-feature-settings 构造出一个 fontFace 后并不会加载字体，必须执行 fontFace 的 load 方法。load 方法返回一个 promise，promise 的 resolve 值就是加载成功后的字体。但是仅仅加载成功还不会使这个字体生效，还需要将返回的 fontFace 添加到 fontFaceSet。 使用方法如下： 12345678/** * @param &#123;string&#125; path 字体文件路径 */async function loadFont(path) &#123; const fontFaceSet = document.fonts const fontFace = await new FontFace('fontFamily', `url('$&#123;path&#125;') format('woff2')`).load() fontFaceSet.add(fontFace)&#125; 因此，在客户端我们可以先设置文字内容的 CSS 为 opacity: 0，等待 await loadFont(path) 执行完毕后，再将 CSS 设置为 opacity: 1, 这样就可以控制在自定义字体加载未完成前不显示内容。 最后总结本文介绍了在开发字体预览功能时遇到的问题和解决方案，限于 OpenType 规范条目很多，在介绍 fontmin 原理部分，仅描述了对 glyf 表的处理，对此感兴趣的读者可进一步学习。 本次工作的回顾和总结过程中，也在思考更好的实现，如果你有建议欢迎和我交流。同时文章的内容是我个人的理解，存在错误难以避免，如果发现错误欢迎指正。 感谢阅读！ 参考 前端字体截取 Scalable Vector Graphics FontFace FontFaceSet fontmin fonteditor-core TrueType-Reference-Manual OpenType-Font-File","pubDate":"Fri, 28 Feb 2020 04:00:00 GMT","guid":"https://aotu.io/notes/2020/02/28/webfont-processing/","category":"Web开发"},{"title":"JDRD开发小结","link":"https://aotu.io/notes/2020/02/21/jdrd-summary/","description":"经过一个月的时间，在我遇到了很多“这个我不会做啊？”，“这个到底怎么做“的问题后，它终于成功上线了！下面总结一下整整一个月的时间我是如何开发JDRD，遇到的各种问题以及解决方案。 JDR DESIGN 是京东零售设计中台的门户站点，展示京东零售设计服务平台的产品以及应用场景，特点是动效丰富、图片细节多、要求整站文案和外链可配置。项目最大的困难就是动效开发复杂和开发排期紧凑的问题。 这是我入职以来负责的第一个项目，需要花大量时间来熟悉新的开发流程，项目排期非常紧凑，并且在排期完后又新增了窄版、骨架屏、首页图标动效、入场动画、产品页头部动效等新的需求，每天高强度的加班，回想起来虽然很难，但是非常有挑战性，非常有收获。 项目架构技术选型作为一个 9012 年的 PC 端项目，我们自然也需要非常先进的技术选型来帮助我们提升研发生产力，所以一个优秀的前端框架和一个高效的前端工程化工具，自然是必不可缺的选择。选择团队自研的 Nerv 进行开发，Nerv 是一个基于 virtual dom 的类 Reac t组件框架，比 React 更小的体积更高的性能，还保持了对 IE 浏览器的兼容，满足了 JDRD 需要兼容IE10的要求。 自动化前端构建工具选择了团队自研的前端工程化工具 Athena，简化 webpack 配置工作，帮助我们在项目中实现自动化编译、代码处理、依赖分析、文件压缩、文件 MD5 戳等需求。 项目整体架构在前端架构方面，根据上述的技术选型以及常见的前端体系，基于本项目的需求进行了些调整，整体架构设计如下： Athena 和 Nerv 上文已经介绍过，下面介绍一下另外几个： 通用工具库：基于以往的项目建立的公共函数库，包括 Slider、Lazyimg、Lazyload、Nerv-loadable 等。 NEOS 管理平台：将整站的文案和外链数据放在 NEOS 平台进行管理，简化文案修改等工作。 兜底展示： 在请求到错误链接时重定向到 error.html 页面 图片加载失败时展示兜底图 MTA 数据分析：将网站的所有点击事件添加埋点进行数据上报，根据实时数据统计分析服务，监控版本质量、渠道状况、用户画像属性及用户细分行为。 开发过程整个开发流程总结如下图所示： 既然是总结，开发过程中的流程当然没有这么完整，漏掉了一部分（已红色标注），导致开发到后面因为前面漏掉的环节，浪费了很多的时间。 整站设计规范：由于开发和设计是同时进行的，开始开发时只有首页定稿，没有其他页面的设计稿，以及窄版的规范，我们应该在开发前和设计师明确整站的设计规范，根据设计规范建立通用样式表，整站引入。 页面&amp;楼层结构：楼层的结构设计对于后续做楼层懒加载非常重要，根据设计稿的功能结构区分楼层。 兼容 IE：JDRD 是需要兼容 IE 的，一些不兼容 IE 的 API 和样式属性应该尽量避免使用。 骨架屏：骨架屏的高度和楼层间隔和内容是一致的，应该建立公共类，定义骨架屏和内容一致的样式，在后续调整内容时，不需要再去调整一遍骨架屏的样式。 数据埋点：交互稿其实有详细介绍哪些地方需要点击跳转的事件，开发时应该在定义点击跳转时就给数据埋点传参。 除了在开发流程中的问题外，最头疼的就是动效的开发了，下文会详细介绍。 项目优化性能优化性能优化的初衷就是加快网站的加载速度，让用户能够更快的看到内容，上面介绍到前端工程化工具 Athena 已经做到合并、压缩了静态资源文件，那还有什么方法能够缩小请求的静态资源体积，加快首屏的加载速度呢，我们尝试了以下性能优化手段。 楼层懒加载楼层懒加载就是按楼层划分组件，并进行代码切割，在页面滚动时按需加载组件。 Nerv-loadable 是一个专门用于动态 import 的 React 高阶组件，你可以把任何组件改写为支持动态 import 的形式，利用 import() 来进行动态加载。 1234567const NewsBannerLoadable = Loadable(&#123; loader: () =&gt; import(/* webpackChunkName: \"news_banner\" */ './news_banner'), loading: loadingPlaceholder.bind(null, loadingBlock), delay: 0&#125;); 上面的代码在首次加载时，会先展示一个 loadingBlock，然后动态加载 news_banner 的代码，组件代码加载完毕之后，便会替换掉 loadingBlock。Lazyload 通过监听 window 对象或者父级对象的 scroll 事件，触发 load，实现懒加载，让组件进入页面可视区时才加载该组件。需要注意的是 lazyload 需要设置高度，才会撑起懒加载的区域。 123&lt;Lazyload &#123;...this.lazyloadOptions&#125; height=&#123;this.floorHeight.newsBanner&#125;&gt; &lt;NewsBannerLoadable /&gt;&lt;/Lazyload&gt; 以首页为例，有四处组件是不需要首次加载的，而是使用动态加载：多端适配、物料、应用场景、设计思考。首次加载实际上只需要加载首屏的头部、视频、banner 即可。切分之后，首屏 js 体积缩减了 50KB。 图片懒加载整站图片非常多，为了保持清晰度而且全部采用二倍图引入，消耗资源比较大，为了加快加载速度，我们选择让滚动条滚动到图片的可视区后才加载该图片。 使用 Lazyload 实现，和上述组件懒加载介绍的一样， 包裹着需要懒加载的图片，就可以实现图片懒加载。 图片懒加载之外还有个优化，就是图片加载中、加载失败、加载成功的状态的判断，根据不同状态展示图片的内容。 使用 Lazyimg 实现这个功能： 使用 new Image() 创建一个新的 HTMLImageElement 实例 img.onload()，img.onerror() 捕获到图片加载成功或者失败的状态 加载中：显示兜底图 加载成功：显示加载到的图片 加载失败：显示兜底图 其他优化手段除了上面两点外，还可以从 webpack 打包进行性能优化，webpack 打包后会生成一个或多个包含源代码最终版本的“打包好的文件”，它们由 chunks 组成，SplitChunks 插件可以将公共依赖项提取到现有的 entry chunk 或全新的代码块中，进行代码切割，减小 chunks 包的大小。 体验优化骨架屏以往的传统网站一般会在加载中展示一个 loading 态，也可以达到占位的效果，但是 loading 动画和真实模块耦合度低，界面效果不够优美，JDRD 则是选用骨架屏进行占位，以灰色豆腐块的形式尽量缩小真实模块结构与加载占位之间的视觉差异。 骨架屏的两个用途： 组件加载完之前的占位 使用 Lazyload 懒加载楼层组件，加载中使用 Loadable 提前占位，占位符设置为骨架屏。 数据加载完之前的占位 设置组件的 state.loaded 初始值为 false ，数据加载成功时 state.loaded = true ，render 函数里如果 loaded === false ，则显示骨架屏。 骨架屏的实现方式有两种，一是下载并引入骨架屏插件（如 antd ），根据不同模块引入对应的骨架屏组件，这种方式和 loading 动画一样，耦合度低，但是全局通用，节省代码量。二是根据视觉稿写骨架屏的样式。JDRD 选择的是第二种，骨架屏和真实模块实现高度耦合。每个页面结构不一样，对应的骨架屏也是完全不同，骨架屏暂时不能抽成公共组件全局通用。 宽窄版首页定稿设定的宽度为 1240px ，对小屏不够友好，我们增加了一版窄版样式兼容小屏。 宽版和窄版开发的重点是定好通用的变量，包括字号粗细、宽窄版宽度、窄版尺寸比。这些通用样式规范需要和设计师统一规范，兼容窄版的开发就会变得非常简单。 只需要在两个地方判断宽窄版，给最顶层的标签加上 wide/narraw 类，在 narrow 下添加窄版的自定义样式。 在页面刚加载到时判断宽窄版，在加载到样式表之前给 html 标签添加 wide/narraw 123456789101112131415!function(e) &#123; window.pageConfig = &#123;&#125;; pageConfig.isWide = function() &#123; var n = e, i = document, o = i.documentElement, t = i.getElementsByTagName(\"body\")[0], a = n.innerWidth || o.clientWidth || t.clientWidth; return a &gt;= 1300 &#125; (); var n = []; pageConfig.isWide ? (n.push(\"wide\")) : n.push(\"narrow\"); var i = document.getElementsByTagName(\"html\")[0]; i.className = n.join(\" \")&#125; (window, void 0); 文档视图调整大小时判断宽窄版，修改 html 标签的 className 先引入 Events.js ，然后在 componentDidMount 里生命周期函数里绑定 ‘ isWideChange ‘ 事件，在文档视图宽度达到宽窄版临界点时调用。 1234567componentDidMount() &#123; window._.eventCenter.on('isWideChange', evt =&gt; &#123; this.setState(&#123;//更新state,更新视图 isWide: evt.detail.isWide &#125;); &#125;);&#125; 动效开发首页图标动效为了突出设计理念，首页图标动效包含大量位移、旋转、缩放、形变、路径动画等细节，由始末动画+循环动画合成，传统做法是 css3 实现，这需要逐帧写动画细节，工作量非常大，我们尝试使用 Lottie 直接解析从 AE 导出的 json 格式的动画（方案由燕婷提出），发现能够完全还原AE动画。 Lottie 是 Airbnb 开源的一套跨平台的完整的动画效果解决方案，可实时渲染 After Effects 动画，从而使应用程序可以像使用静态图像一样轻松地使用动画。这样实现起来就非常简单了。分以下两步： 在 AE 软件中用 bodymovin 插件将动画导出为 json 文件 在项目中使用 lottie-web 将 json 格式的动画解析为 SVG（使用文档） lottie-web 文档中的方法非常全面，JDRD 图标动效使用加载动画、播放指定帧区间、反向播放动画方法，就实现了起始动画 20 帧+循环动画 60 帧+起始动画反向播放 20 帧的动画合成操作。 项目示例代码如下： 1234567891011121314npm install lottie-web //安装lottie-webimport lottie from 'lottie-web' //引入lottie-web到项目中//lottie-web常用方法this.anim = lottie.loadAnimation(&#123; //加载动画 container: element, renderer: 'svg', loop: true, autoplay: true, path: 'data.json'&#125;);this.anim.playSegments([[0,60]], true); //播放指定帧区间this.anim.setDirection(-1);//动画反向播放this.anim.play();//播放动画this.anim.pause()//暂停动画 经过以上两步，Lottie 已经将一个 AE 格式的动画渲染在 web 页面上。 这里有 2 个需要注意的点： json 文件的引入要使用 CDN，引入本地 json 文件会解析失败。 如果动画源文件中有引入图片文件，bodymovin 导出的动画为 json+img。图片动画的兼容性有待确认。 以上就是用 Lottie 实现的动画，看到这里，是不是觉得 so easy，但是 Lottie 并不是万能的，不能解析所有的动画特性，开发前需要先看下支持列表。并和设计师确认是否都支持。 入场动画JDRD 整站采用了骨架屏占位，那么入场动画最大的问题就是如何让它不和骨架屏冲突，解决方法就是楼层懒加载里面，再加一层入场动画的组件懒加载，两层懒加载的设置 offset 差，就可以做到在可视区外加载楼层组件，在可视区内播放入场动画。具体实现如下： 楼层懒加载，在页面滚动时按需加载楼层组件 12345678// 在距离底部200px时，加载楼层组件getMaterialLoadable()&#123; return this.getFloor( &lt;Lazyload lazyloadOptions=&#123;offset: 200&#125; height=&#123;1000&#125;&gt; &lt;MaterialLoadable /&gt; &lt;/Lazyload&gt; );&#125; 楼层中的入场动画组件懒加载 1234567// 在距离底部-200px时，加载入场动画组件，这时因为楼层组件已经加载过了，页面显示是真实组件而不是骨架屏&lt;Lazyload lazyloadOptions=&#123;offset: -200&#125;&gt; &lt;div className=\"w\"&gt; &lt;IndexTitle showLine=&#123;true&#125; title=&#123;this.state.title&#125;&gt;&lt;/IndexTitle&gt; &#123;this.renderMaterial()&#125; &lt;/div&gt;&lt;/Lazyload&gt; 另外一个难点是序列动画的效果，序列动画就是将列表元素的动画执行时机错开，具体实现参考css3 animation 属性众妙。实现代码如下： 12345@for $i from 1 to 6 &#123; .list__item:nth-child(#&#123;$i&#125;) &#123; animation-delay: (-1+$i)*0.1s; /*计算每个元素的 animation-delay */ &#125;&#125; 产品页头部动效产品页的头部动效分两部分，氛围动效 + 波浪动效。 氛围动效 氛围动效的实现比较简单，也是使用 Lottie 实现，这里遇到了 Lottie 不支持的特性，就是渐变，对于不支持的特性，我们可以拿到需要自定义样式的标签的 id，自定义样式，如图所示： 12345678#__lottie_element_369 &#123; stop[offset=\"0%\"] &#123; stop-color: #FDFDFF; &#125; stop[offset=\"100%\"] &#123; stop-color: #F7F7FB; &#125;&#125; 自定义样式的时候，这里有个坑一定要注意，SVG 的 ID 是会变的，例如开发时，这个 ID 是 100，测试时这个 ID 有可能变成 101，这个是偶现的，目前还没有找到 ID 值 + 1 的原因，但是为了让自定义的样式生效，需要给 ID 为 100 和 ID 为 101 的标签都加上样式。 波浪动效 通过引入正弦波浪动效库 sine_wave 实现。sine_wave 使用 canvas 元素生成多个可配置的正弦波，这样我们就可以通过配置参数得到想要的正弦波浪，具体实现如下： 1234567891011121314151617181920212223new SineWaves(&#123; el: document.getElementById( `waves`),//dom speed: 0.75,//速度 width: function() &#123;//canvas宽度 return document.body.clientWidth; &#125;, height: 68,//canvas高度 ease: 'Linear',//动画曲线 waves: [//需要配置的正弦波浪 &#123; \"timeModifier\":1,//速度 \"lineWidth\":1,//线条宽度 \"amplitude\":30 * window.devicePixelRatio,//波浪高度 \"wavelength\":125 * window.devicePixelRatio,//波长 \"strokeStyle\":\"rgba(221,221,233,1)\",//颜色 \"type\": function(x, waves) &#123;//自定义波浪类型 return waves.sine(x); // Combine two together &#125; &#125; ], rotate: 0,//旋转角度 wavesWidth: '400%',//波浪宽度&#125;); 根据文档介绍的参数来看，有两个参数是实现 3D 旋转波浪效果的关键： type，自定义波浪的类型，可以修改 x 轴的位移，让 3 根波浪错位，实现旋转的效果。 123type: function(x, waves) &#123; return waves.sine(x+8); // Combine two together&#125; wavelength，波浪长度，3 根弧度一模一样的波浪明显是不符合要求的，只需要将红色的波浪的弧长加长，就可以实现一根波浪环绕另外两根波浪的效果。 开发过程中发现 sine_waves 的一个显示问题，它以默认二倍屏的方式定义的 canvas，这样在一倍屏下波浪是有问题的，解决方法是在参数波浪高度 amplitude 和波长 wavelength 根据 window.devicePixelRatio 来定义。 1234&#123; \"amplitude\":30 * window.devicePixelRatio,//波浪高度 \"wavelength\":125 * window.devicePixelRatio,//波长&#125; 全局细节动效最后介绍的就是全局细节动效的优化，为了让整站的动效流畅，平滑的过渡，做了以下工作： 用 SASS 变量 $common_animation 管理通用动画，让整站动画一致化 图标动效和边框动效采用 SVG 实现，实现动画组件化的同时，矢量元素不失真 需要过渡的元素，用 visibility 代替 display 控制元素的显示隐藏 整体总结本文从项目架构、开发流程、项目优化 3 个方面阐述 JDRD 官网的开发过程，中间遇到了太多问题，在问题的解决过程中记录和总结，是收获满满的喜悦，也发现了一些可以优化的模块，让下次能够做得更好，在开发过程中的多些思考和探究，最优化的设计项目。 感谢阅读！","pubDate":"Fri, 21 Feb 2020 07:24:00 GMT","guid":"https://aotu.io/notes/2020/02/21/jdrd-summary/","category":"项目总结"},{"title":"Taro Next 发布预览版：同时支持 React / Vue / Nerv","link":"https://aotu.io/notes/2020/02/03/taro-next-alpha/","description":"自 Taro 2.0 起，我们将会启动对整个 Taro 系统架构的革新，这次革新我们将其称之为 Taro Next。Taro Next 革新完成之后，Taro 本身的拓展性、稳定性、可维护性都会大幅提高，相应地，使用 Taro 的开发者也会获得更好的开发体验，降低更多开发成本和学习成本。 我们目前已经完成了编译系统和小程序端的重构，通过 npm i -g @tarojs/cli@next 安装 Taro CLI 预览（alpha）版之后，使用 taro init 创建新项目即可体验 Taro Next 的新特性： 同时支持 React/Vue/Nerv 三种框架在旧版本的 Taro，我们以微信小程序的开发规范为基准，使用 React/JSX 的方式来进行开发。而在 Taro Next，我们把这一思路量化为一个编程模型： 设微信小程序生命周期为一个 interface，不同的框架实例的生命周期虽然不尽相同，但我们可以根据框架生命周期分别新建一个 class 去 implements 小程序生命周期的 interface。相应地，小程序的组件/API/路由规范可以使用同样的思路和模型让不同框架的代码，运行在不同的端上： 不限制语言、语法由于 Taro Next 的架构出现了变化，表面上来看 Taro 从一个编译型框架变成了一个运行时框架。但究其内核是整体的设计思路出现了变化：从前是「模拟（mock）」，现在是「实现（implements）」。在 Taro Next 我们实现了 React 在小程序中的完整支持，因此这类曾经的 Taro 无法运行的代码在 Taro Next 中完全没有压力： 12345import &#123; View &#125; from '@tarojs/components'function Page (props) &#123; const view = React.createElement(View, null, props.text) return [view, React.Children.only(this.props.children)]&#125; 在旧版本的 Taro 中我们对 JavaScript 和 TypeScript 进行了 First Class 的支持，Taro Next 我们更进一步，原理上最终可以编译到 JavaScript 的语言都可以用来构建 Taro 项目，以下是一个在 Vue 中使用 CoffeeScript 的例子： 12345678910111213// config.js&#123; webpackChain (chain) &#123; chain.merge(&#123; module: &#123; rule: &#123; test: /\\.coffee$/, use: [ 'coffee-loader' ] &#125; &#125; &#125;) &#125;&#125; 123456789101112131415&lt;template&gt; &lt;view&gt;&#123;&#123; title &#125;&#125;&lt;/view&gt; &lt;view&gt;&#123;&#123; text &#125;&#125;&lt;/view&gt; &lt;input v-model='text' /&gt;&lt;/template&gt;&lt;script lang=\"coffee\"&gt;export default props: title: type: String required: true data: -&gt; text: 'text'&lt;/script&gt; 更快的运行速度运行时性能主要分为两个部分，一是更新性能，二是初始化性能。 对于更新性能而言，旧版本的 Taro 会把开发者 setState 的数据进行一次全量的 diff，最终返回给小程序是按路径更新的 data。而在 Taro Next 中 diff 的工作交给了开发者使用的框架（React/Nerv/Vue），而框架 diff 之后的数据也会通过 Taro 按路径去最小化更新。因此开发者可以根据使用框架的特性进行更多更细微的性能优化。 初始化性能则是 Taro Next 的痛点。原生小程序或编译型框架的初始数据可以直接用于渲染，但 Taro Next 在初始化时会把框架的渲染数据转化为小程序的渲染数据，多了一次 setData 开销。 为了解决这个问题，Taro 从服务端渲染受到启发，在 Taro CLI 将页面初始化的状态直接渲染为无状态的 wxml，在框架和业务逻辑运行之前执行渲染流程。我们将这一技术称之为预渲染（Prerender），经过 Prerender 的页面初始渲染速度通常会和原生小程序一致甚至更快。 更快的构建速度和 source-map 支持作为一个编译型框架，旧版本的 Taro 会进行大量的 AST 操作，这类操作显著地拖慢了 Taro CLI 的编译速度。而在 Taro Next 中不会操作任何开发者代码的 AST，因此编译速度得到了大幅的提高。 正因为 AST 操作的取消，Taro Next 也轻松地实现了 source-map 的支持。这对于开发体验是一个巨大的提升： 不忘初心在做到以上各项特性的同时，我们也没有丢掉原来就已经支持的特性： 支持微信小程序、百度智能小程序、支付宝小程序、QQ 小程序、字节跳动小程序 使用原生小程序第三方组件/插件 多端条件编译 跨端 API 和样式处理 这些特性基本涉及到了小程序开发的方方面面，虽然是预览版，但 Taro Next 已经具备了开发生产级小程序的准备，在 Taro 团队内部和兄弟团队也有多款小程序正在使用 Taro Next 进行开发。而在 Taro Next 的 H5 端和移动端，我们还在进行紧张的开发。当 Taro Next 测试（beta）版发布时，使用 Taro Next 构建的一套代码，就可以同时运行在各种小程序、快应用、H5 和移动端当中。在未来，我们还会把 Taro Next 的能力开放出去，让开发者只要写少量的接入代码，就可以使用自己喜欢的任意框架（Angular, Flutter, svelte…）开发小程序或多端应用。 牢记使命正如我们在 Taro 2.0 发布时所言： 节物风光不相待，桑田碧海须臾改。 20 年代呼啸而来，下一个 10 年，很多框架都会死去，很多技术也会焕然而生，没有什么是不变的，唯一不变的只有变化，我们能做的也只能是拥抱变化。 前端技术一直在高速发展，流行的技术和框架每年都各不相同。但我们始终没有忘记开发 Taro 的初心和使命：降低开发成本，提高开发体验和开发效率。 「不忘初心，牢记使命。」 这就是 Taro 团队拥抱变化的方式。 参考资料[1] 小程序跨框架开发的探索与实践: https://www.infoq.cn/article/TMqBzVFTSiQTUbgxydPm [2] Taro Next 旧版本迁移指南：https://taro-docs.jd.com/taro/next/docs/migration.html [3] Prerender: https://taro-docs.jd.com/taro/next/docs/prerender.html [4] 性能测试：https://github.com/NervJS/taro-benchmark/tree/next [5] 与其它新型小程序的对比：https://taro-docs.jd.com/taro/next/docs/difference-to-others.html","pubDate":"Mon, 03 Feb 2020 05:50:00 GMT","guid":"https://aotu.io/notes/2020/02/03/taro-next-alpha/","category":"Web开发"},{"title":"Taro 2.0：拥抱社区，拥抱变化","link":"https://aotu.io/notes/2020/01/08/taro-2-0/","description":"缘起Taro 1.x 版本自去年 9 月份发布以来，已经陪伴大家度过了一年多的时间，在此期间 Taro 一直保持高速成长，发布了多个具有重大意义的版本，让 Taro 成为如今一个功能完善，拥有众多忠实拥趸的多端统一开发框架。 尽管 Taro 一直保持超高的迭代速度，Taro 的整体架构设计没有发生太大变化，这让 Taro 在这个时刻在变化的时代稍显佛系，且对于一个时刻想要突破自己的技术团队来说，常规性质的维护工作，显然无法安抚我们躁动的心，毕竟人的梦想，是永远不会停止的，所以我们决定启动一系列的颠覆式重构设计。 2.0我们首先从 CLI 开始入手进行改造，大家都知道，原来 Taro CLI 的编译构建系统是自研的，整个构建系统逻辑复杂，要考虑的边际条件众多，这就导致了以下问题： 维护困难，每次需要新增一个功能，例如支持解析 Markdown 文件，就需要直接改动 CLI，不够灵活 难以共建，CLI 的代码非常复杂，而且逻辑分支众多，让很多想要一起共建的人难以入手 可扩展性偏低，自研的构建系统，设计之初没有考虑到后续的扩展性，导致开发者想要添加自定义的功能无从下手 基于以上问题，我们决定使用 Webpack 来实现编译构建，于是诞生了 2.0。 Taro 2.0 的 CLI 将会变得非常轻量，只会做区分编译平台、处理不同平台编译入参等操作，随后再调用对应平台的 runner 编译器 做代码编译操作，而原来大量的 AST 语法操作将会改造成 Webpack Plugin 以及 Loader，交给 Webpack 来处理。 相较于旧的构建系统，新的小程序编译带来了以下优势： 利于维护，大量的逻辑交由 Webpack 来处理，我们只需要维护一些插件 更加稳定，相较于自研的构建系统，新的构建会更加稳定，降低一些奇怪错误的出现概率 可扩展性强，可以通过自行加入 Webpack Loader 与 Plugin 的方式做自己想要的扩展 各端编译统一，接入 Webpack 后，Taro 各端的编译配置可以实现非常大程度的统一 可以看到新的构建系统会有很大的进步。同时，更重要的是，基于 Webpack，我们可以在小程序中尝试更多的特性与技术，例如通过 tree shaking 来优化代码包大小等等，让小程序开发更加与业界发展同步，让 Taro 更加拥抱社区。 Migrate to 2.0编译配置调整2.0 整体上与 1.0 是完全兼容的，但是在基于 Webpack 重构后，我们对部分编译配置做了优化调整，所以如果想要将基于 1.x 的旧项目迁移至 2.0，首先需要对编译配置进行调整。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const config = &#123; projectName: 'taro-framework', date: '2019-11-2', designWidth: 750, deviceRatio: &#123; 640: 2.34 / 2, 750: 1, 828: 1.81 / 2 &#125;, sourceRoot: 'src', outputRoot: 'dist', // babel、csso、uglify 等配置从 plugins 配置中移出来 babel: &#123; sourceMap: true, presets: [['env', &#123; modules: false &#125;]],, plugins: [ 'transform-decorators-legacy', 'transform-class-properties', 'transform-object-rest-spread' ] &#125;, // 小程序配置从 weapp 改为 mini，可以删掉很多小配置 mini: &#123; webpackChain (chain, webpack) &#123;&#125;, cssLoaderOption: &#123;&#125;, postcss: &#123; pxtransform: &#123; enable: true, config: &#123;&#125; &#125;, url: &#123; enable: true, config: &#123; limit: 10240 // 设定转换尺寸上限 &#125; &#125; &#125; &#125;, // 可以删掉很多小配置 h5: &#123; publicPath: '/', staticDirectory: 'static', webpackChain (chain, webpack) &#123;&#125;, postcss: &#123; autoprefixer: &#123; enable: true, config: &#123; browsers: [ 'last 3 versions', 'Android &gt;= 4.1', 'ios &gt;= 8' ] &#125; &#125; &#125; &#125;&#125;module.exports = function (merge) &#123; if (process.env.NODE_ENV === 'development') &#123; return merge(&#123;&#125;, config, require('./dev')) &#125; return merge(&#123;&#125;, config, require('./prod'))&#125; 具体编译配置请参考 编译配置文档。 异步编程调整Taro 2.0 中开启 async functions 支持不再需要安装 @tarojs/async-await，而是直接通过 babel 插件来获得支持。 在项目根目录下安装包 babel-plugin-transform-runtime 和 babel-runtime。 12$ yarn add babel-plugin-transform-runtime --dev$ yarn add babel-runtime 随后修改项目 babel 配置，配置插件 babel-plugin-transform-runtime。 123456789101112131415babel: &#123; sourceMap: true, presets: [['env', &#123; modules: false &#125;]], plugins: [ 'transform-decorators-legacy', 'transform-class-properties', 'transform-object-rest-spread', ['transform-runtime', &#123; \"helpers\": false, \"polyfill\": false, \"regenerator\": true, \"moduleName\": 'babel-runtime' &#125;] ]&#125; 新特性尝鲜在基于 Webpack 改造后带来全面提升的同时，2.0 也为我们带来了以下新的特性。 主编译流程钩子在 2.0 中，CLI 编译的主流程已经基于 Tapable 进行改造，并且对外暴露了 hooks 以供使用，在 Taro 编译配置中可以通过 plugins 来配置编译过程插件，调用这些 hooks 来实现自己的需求。 目前编译主流程暴露了两个钩子 beforeBuild 和 afterBuild，其中，beforeBuild 将在整体编译前触发，可以获取到编译的相关配置，同时也能进行修改；afterBuild 将在 Webpack 编译完后执行，可以获取到编译后的结果。具体使用方式如下。 首先定义一个插件 1234567891011class BuildPlugin &#123; apply (builder) &#123; builder.hooks.beforeBuild.tap('BuildPlugin', (config) =&gt; &#123; console.log(config) &#125;) builder.hooks.afterBuild.tap('BuildPlugin', (stats) =&gt; &#123; console.log(stats) &#125;) &#125;&#125; 接下来在 plugins 字段中进行配置 1234567const config = &#123; ... plugins: [ new BuildPlugin() ] ...&#125; 为小程序编译添加 Loader我们有时候可能会面临在小程序中展示 Markdown 语法文件的需求，在 WEB 开发的时候我们可以借助 Webpack 及其 Loader，实现直接引入 md 文件并读取其内容，而在小程序开发中，通过借助 Taro 2.0，我们也能很轻松地实现这一需求。 一般我们会以如下的方式，来引入一个 .md 文件。 1import mdTxt from '../../some_markdown.md' 而 .md 文件默认是不能直接被识别的，我们需要通过配置相应的 Loader 来实现对这类文件的加载解析，在 Taro 中可以通过 mini.webpackChain 来为小程序配置自定义 Webpack 配置，我们也可以通过它来配置 Loader。 12345678910111213141516171819const config = &#123; mini: &#123; webpackChain (chain) &#123; chain.merge(&#123; module: &#123; rule: &#123; myloader: &#123; test: /\\.md$/, use: [&#123; loader: 'raw-loader', options: &#123;&#125; &#125;] &#125; &#125; &#125; &#125;) &#125; &#125;&#125; 为小程序编译添加 Plugin当我们要把打包后的小程序进行发布的时候，可能会遇到小程序过大的问题，那么我们肯定迫切希望可以看到到底是哪些文件的大小造成了这个影响，我们可以通过使用 webpack-bundle-analyzer 插件对打包体积进行分析。 在 mini.webpackChain 中添加如下配置。 12345678const config = &#123; mini: &#123; webpackChain (chain, webpack) &#123; chain.plugin('analyzer') .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin, []) &#125; &#125;&#125; 在运行之后，我们就能在浏览器里看到如下分析效果。 Taro RN 依赖升级到 0.59.9在 2.0 中我们将 RN 端 React 依赖升级到 16.8.0，React Native 依赖升级到 0.59.9。主要原因： Google 要求所有 Google Play 应用支持 64 位 so 库，而现有 RN 0.55.4 依无法支持 64 位库，为配合 64 位升级，Taro RN 端的 React Native 依赖需要同步升级 React 16.8.0 是第一个支持 Hook 的版本，React Native 从 0.59 版本开始支持 Hook，此前社区一直在呼吁对 RN 0.55.4 进行升级以直接支持 Hook 的写法 本次 RN 端属于无缝升级，原有的写法和配置均不变，如果使用 taro-native-shell 的，选择 0.59.9 分支即可；在原生应用集成 RN 的，需要自行升级 React Native 依赖到 0.59.9。 未来与展望正如前文所提到的，Taro 2.0 只是一个开始。 在 10 年代最后一场 GMTC 全球大前端技术大会上，Taro 团队向大家展示了 小程序跨框架开发的探索与实践 的艰辛旅程，同时也提前曝光了正在紧密开发中的 Taro Next。 那是一个完全区别于以往的版本，一条与现在 Taro 截然不同的道路，预示着 Taro 正在革自己的命。 节物风光不相待，桑田碧海须臾改。 20 年代呼啸而来，下一个 10 年，很多框架都会死去，很多技术也会焕然而生，没有什么是不变的，唯一不变的只有变化，我们能做的也只能是拥抱变化。","pubDate":"Wed, 08 Jan 2020 12:05:00 GMT","guid":"https://aotu.io/notes/2020/01/08/taro-2-0/","category":"Web开发"},{"title":"GMTC |《小程序跨框架开发的探索与实践》演讲全文","link":"https://aotu.io/notes/2020/01/02/gmtc/","description":"前言：随着小程序开发的热度上升，小程序开发框架也层出不穷。但目前每个框架都会绑定一个专属 DSL，如类 React 或者类 Vue，在一个框架内，开发者无法根据团队技术栈自由选择 DSL，同时也无法共享框架本身的生态与工具。 本次分享将为大家介绍 Taro 如何将各种语法的前端框架运行在小程序上，讨论一个框架支持多 DSL 的实现探索，使得开发者可以使用任意热门框架/语法/DSL 来编写小程序应用，同时复用相关生态。 小程序开发的历程2017 年 1 月 9 日凌晨，万众期待的微信小程序正式上线。 在此之前，京东投入一个前端小团队，经过一个月的封闭式开发，以一周一个版本的速度进行迭代，终于在第一时间发布了自己的 「京东购物」 小程序，尽管功能和界面现在看起来有些简陋，但在当时是完全符合微信小程序「触手可及，用完即走」的理念。 当然，随着整个项目的不断迭代，现在的 「京东购物」小程序在设计、交互以及功能复杂度已经全面向 APP 端看齐，这里面的工程化实践已经由 刘慧敏 老师在 GMTC 全球大前端技术大会（北京站）2019 进行过分享，有兴趣的可以下载 PPT：京东购物小程序工程化之路。 当时的微信小程序的开发存在一些缺点，比如依赖管理混乱、工程化流程落后、ES Next 支持不完善、命名规范不统一等。这些问题在现在看来都已经有了各种官方或非官方的解决办法，但是在当时小程序开发的探索阶段，这些问题都是一些痛点问题。 有句话我个人特别喜欢，那就是「当一门语言的能力不足，而用户的运行环境又不支持其它选择的时候，这门语言就会沦为 “编译目标” 语言」。 纵观整个前端的历史，无论是 CSS 预处理器的大行其道、各种模版的流行，还是 CoffeeScript 乃至 TypeScript 的诞生，都印证了这个说法，微信小程序这里也不例外。因此，各种小程序开发框架如百花齐放，层出不穷。 这些小程序开发框架最主要的区别是 DSL，这点从 logo 颜色上就可以看出来，除了滴滴的 Chameleon 是自定义 DSL 外，其余的绿色的 logo 是遵循了 Vue 语法（如 mpvue ），蓝色的 logo 是遵循了 React 的语法（如 Taro）。 在微信小程序之后，各大厂商纷纷发布了自己的小程序平台，比如：支付宝、百度、头条、QQ等，再加上快应用、网易、360、京东等，小程序的赛道越来越拥挤，开发人员需要适配的小程序平台越来越多，因此，各大小程序开发框架也纷纷进行了多端适配。 因此，站在这个时间节点反过来回顾整个小程序开发框架的进程，你会发现整个 2018 年乃至 2019 年初，小程序的开发框架主要的区别和重心在于：DSL 以及 多端适配。 Taro 的起源与初心正所谓「业务孵化技术，技术服务业务」，Taro 的诞生源自于业务需求的增加，当时我们的团队需要同时负责：京东购物，TOPLIFE 等业。团队人力资源捉襟见肘，与此同时，以上的业务都或多或少存在多端的需求，比如 微信小程序、H5、React Native(京东的主流 APP基本都内置了 React Native 渲染引擎)，而且可以预见的是，以后很有可能需要适配更多的小程序平台，而每个端开发一套代码又不现实，会导致：研发成本上升，代码维护困难。 当时我们团队自研了一款 类React 框架：Nervjs, 整个团队的技术栈因此全部转向了 React ，而当时市面上又没有一款遵循 React 语法的小程序框架，因此，我们开发了 Taro，希望能够使用 React 语法写小程序的同时，通过「Write once Run anywhere」来实现跨端的。 整个 Taro 框架从 2018 年 6 月 7 日开源至今，一致保持着高速迭代，这些迭代主要集中在三个方面： 多端适配：从一个端到多个端 开发体验：如支持 React Hooks、CSS Modules、Mobx 等 社区共建：如 Taro 论坛、Taro物料市场 等平台，以及后面发布的 社区共建计划 经过团队 一年多的努力，Taro 得到了社区的广泛认可，截止 2019年 12 月 18日，Taro 已拥有 22254 Stars 和 250 名 Contributors，社区主动提交的开发案例 150+：taro-user-cases，其中不乏多端案例。 但是尽管如此，Taro 还是存在一些问题无法解决，或者说：没那么好解决。比如：和 React DSL 强绑定、JSX 适配工作量大、社区贡献复杂等。这些问题归根到底，很大一部分是 Taro 的架构问题。 因此我们团队也一直在等待一次合适的机会，对整个架构进行一次提升，同时修复一些项目快速迭代欠下的技术债。 最主要的是，单纯的项目维护迭代已经满足不了我们团队躁动的心，我们渴望借此机会进行一次技术突破。 小程序跨框架开发的探索在讲 Taro 架构之前，我们先来回顾一下小程序的架构。 微信小程序主要分为 逻辑层 和 视图层，以及在他们之下的原生部分。逻辑层主要负责 JS 运行，视图层主要负责页面的渲染，它们之间主要通过 Event 和 Data 进行通信，同时通过 JSBridge 调用原生的 API。这也是以微信小程序为首的大多数小程序的架构。 由于原生部分对于前端开发者来说就像是一个黑盒，因此，整个架构图的原生部分可以省略。同时，我们我们对 逻辑层 和 视图层 也做一下简化，最后可以得到小程序架构图的极简版： 也就是说，只需要在逻辑层调用对应的 App()/Page() 方法，且在方法里面处理 data、提供生命周期/事件函数等，同时在视图层提供对应的模版及样式供渲染就能运行小程序了。这也是大多数小程序开发框架重点考虑和处理的部分。 Taro 当前架构Taro 当前的架构主要分为：编译时 和 运行时。 其中编译时主要是将 Taro 代码通过 Babel 转换成 小程序的代码，如：JS、WXML、WXSS、JSON。 运行时主要是进行一些：生命周期、事件、data 等部分的处理和对接。 Taro 编译时有过 Babel 插件开发经验的应该对一下流程十分熟悉，Taro 的编译时也是遵循了此流程，使用 babel-parser 将 Taro 代码解析成抽象语法树，然后通过 babel-types 对抽象语法树进行一系列修改、转换操作，最后再通过 babel-generate 生成对应的目标代码。 详情可以参考：babel-handbook 整个编译时最复杂的部分在于 JSX 编译。 我们都知道 JSX 是一个 JavaScript 的语法扩展，它的写法千变万化，十分灵活。这里我们是采用 穷举 的方式对 JSX 可能的写法进行了一一适配，这一部分工作量很大，实际上 Taro 有大量的 Commit 都是为了更完善的支持 JSX 的各种写法。 但尽管如此，我们也不可能完全覆盖所有的情况，因此还是推荐大家按照官方规范书写 React 代码，同时，我们也提供了丰富的 ESlint 插件来辅助大家书写规范的代码。 这一块我们团队内部一直有个梗：如果你使用 Taro 开发感觉 Bug 少，那说明你的 React 代码写得很规范。 Taro 运行时接下来，我们可以对比一下编译后的代码，可以发现，编译后的代码中，React 的核心 render 方法 没有了。同时代码里增加了 BaseComponent 和 createComponent ,它们是 Taro 运行时的核心。 1234567891011121314151617181920212223242526272829303132333435// 编译前import Taro, &#123; Component &#125; from '@tarojs/taro'import &#123; View, Text &#125; from '@tarojs/components'import './index.scss'export default class Index extends Component &#123; config = &#123; navigationBarTitleText: '首页' &#125; componentDidMount () &#123; &#125; render () &#123; return ( &lt;View className=‘index' onClick=&#123;this.onClick&#125;&gt; &lt;Text&gt;Hello world!&lt;/Text&gt; &lt;/View&gt; ) &#125;&#125;// 编译后import &#123;BaseComponent, createComponent&#125; from '@tarojs/taro-weapp'class Index extends BaseComponent &#123;// ... _createDate()&#123; //process state and props &#125;&#125;export default createComponent(Index) BaseComponent 大概的 UML 图如下，主要是对 React 的一些核心方法：setState、forceUpdate 等进行了替换和重写，结合前面编译后 render 方法被替换，大家不难猜出：Taro 当前架构只是在开发时遵循了 React 的语法，在代码编译之后实际运行时，和 React 并没有关系。 而 createComponent 主要作用是调用 Component() 构建页面；对接事件、生命周期等；进行 Diff Data 并调用 setData 方法更新数据。 总结因此，整个 Taro 当前架构的特点是： 重编译时，轻运行时：这从两边代码行数的对比就可见一斑。 编译后代码与 React 无关：Taro 只是在开发时遵循了 React 的语法。 直接使用 Babel 进行编译：这也导致当前 Taro 在工程化和插件方面的羸弱。 其它解决方案的架构小程序开发框架百花齐放，我们也从社区里得到了不少启发。 接下来我们来看看 遵循 vue 语法的小程序开发框架的代表：mpvue 是怎样实现的。 看过 Vue 源码的同学对上面的文件夹和架构肯定熟悉，本质上，mpvue 就是 fork 了一份 `vuejs/vue@2.4.1` 的代码，保留了 Vue runtime 能力，同时添加了小程序平台的支持。 具体在源码中的表现就是：在 Vue 源码的 platforms 文件夹下面增加了 mp 目录，在里面实现了 complier（编译时） 和 runtime （运行时）支持。 mpvue 的实现同样分为：编译时和运行时。 mpvue 编译时其中编译时做的事情和 Taro 很类似：将 Vue SFC 写法的代码编译成 小程序代码文件（JS、WXML、WXSS、JSON）。 最大的区别是 Taro 将 JSX 编译成 小程序模版，而 mpvue 是将 Vue 模版编译成 小程序模版。但是由于 Vue 模版和 小程序模版的相似性，mpvue 在这一块的工作量比 Taro 少得多。 mpvue 运行时而 mpvue 的运行时和 Vue 的运行时是强关联的，首先我们来看看 Vue 的运行时。 一个 .vue 的单文件由三部分构成: template, script, style 。 橙色路径部分, template 会在编译的过程中，在 vue-loader 中通过 ast 进行分析，最终生成一段 render 函数，执行 render 函数会生成虚拟dom树，虚拟 DOM 树是对真实 DOM 树的抽象，树中的节点被称作 vnode 。 Vue 拿到 虚拟 DOM 树之后，就可以去和上次老的 虚拟 DOM 树 做 patch diff 对比。patch 阶段之后，vue 就会使用真实的操作DOM 的方法（比如说 insertBefore , appendChild 之类的），去操作DOM结点，更新视图。 同时，绿色路径的部分，在实例化 Vue 的时候，会对数据 data 做响应式的处理，在监测到 data 发生改变时，会调用 render 函数，生成最新的虚拟 DOM 树， 接着对比老的虚拟 DOM 树进行 patch, 找出最小修改代价的 vnode 节点进行修改。 而 mpvue 的运行时，会首先将 patch 阶段的 DOM 操作相关方法置空，也就是什么都不做。其次，在创建 Vue 实例的同时，还会偷偷的调用 Page() 用于生成了小程序的 page 实例。然后 运行时的 patch 阶段会直接调用 $updateDataToMp() 方法，这个方法会获取挂在在 page 实例上维护的数据 ，然后通过 setData 方法更新到视图层。 mpvue 整体原理图也就如下： 一些总结与思考因此，和 Taro 重编译时轻运行时不同，mpvue 算是：半编译时，半运行时。这点从代码量的对比也能大致反映出来。 mpvue 的 WXML 模版和 Taro 一样，也是通过代码编译得到的；不同于 Taro 运行时和 React 无关，mpvue 本质上还是将 Vue 运行在了小程序，且实现了 `Vue@2.4.1绝大部分特性（只有极少数特性由于小程序模版的限制未能实现，如 ：filter、slot、v-html`）；且整个框架基于 Webpack 实现了较为完善的工程化。 其他小程序框架的实现原理和效果上的差异性，也带来了我们的一些思考： 编译时 OR 运行时：当初 Taro 选择重编译时的主要原因是处于性能考虑，毕竟同等条件下，编译时做的工作越多，也就意味着运行时做的工作越少，性能会更好；另外，重编译时也保证了 Taro 的代码在编译之后的可读性。但是从长远来看，计算机硬件的性能越来越冗余，如果在牺牲一点可以容忍的性能的情况下换来整个框架更大的灵活性和更好的适配性，我们认为是值得的。 模版静态编译 OR 动态构建：尽管 Taro 和 mpvue 的模版都是通过静态编译生成的，但是社区也不乏动态构建的例子，比如：Remax。 DSL 限制：我们能否实现一个小程序开发框架，摆脱 DSL 的限制？ 新架构 Taro Next 的适配与实现这一次，我们站在浏览器的角度来思考前端的本质：无论开发这是用的是什么框架，React 也好，Vue 也罢，最终代码经过运行之后都是调用了浏览器的那几个 BOM/DOM 的 API ，如：createElement、appendChild、removeChild 等。 因此，我们创建了 taro-runtime 的包，然后在这个包中实现了 一套 高效、精简版的 DOM/BOM API（下面的 UML 图只是反映了几个主要的类的结构和关系）： 然后，我们通过 Webpack 的 ProvidePlugin 插件，注入到小程序的逻辑层。 这样，在小程序的运行时，就有了 一套高效、精简版的 DOM/BOM API。 React 实现在 DOM/BOM 注入之后，理论上来说，Nerv/Preact 就可以直接运行了。但是 React 有点特殊，因为 React-DOM 包含大量浏览器兼容类的代码，导致包太大，而这部分代码我们是不需要的，因此我们需要做一些定制和优化。 在 React 16+ ，React 的架构如下： 最上层是 React 的核心部分 react-core ，中间是 react-reconciler，其的职责是维护 VirtualDOM 树，内部实现了 Diff/Fiber 算法，决定什么时候更新、以及要更新什么。 而 Renderer 负责具体平台的渲染工作，它会提供宿主组件、处理事件等等。例如 React-DOM 就是一个渲染器，负责 DOM 节点的渲染和 DOM 事件处理。 因此，我们实现了 taro-react 包，用来连接 react-reconciler 和 taro-runtime 的 BOM/DOM API： 具体的实现主要分为两步： 实现 react-reconciler 的 hostConfig 配置，即在 hostConfig 的方法中调用对应的 Taro BOM/DOM 的 API。 实现 render 函数（类似于 ReactDOM.render）方法，可以看成是创建 Taro DOM Tree 的容器。 经过上面的步骤，React 代码实际上就可以在小程序的运行时正常运行了，并且会生成 Taro DOM Tree，那么偌大的 Taro DOM Tree 怎样更新到页面呢？ 首先，我们将小程序的所有组件挨个进行模版化处理，从而得到小程序组件对应的模版，如下图就是小程序的 view 组件经过模版化处理后的样子： 然后，我们会：基于组件的 template，动态 “递归” 渲染整棵树。 具体流程为先去遍历 Taro DOM Tree 根节点的子元素，再根据每个子元素的类型选择对应的模板来渲染子元素，然后在每个模板中我们又会去遍历当前元素的子元素，以此把整个节点树递归遍历出来。 整个 Taro Next 的 React 实现流程图如下： Vue 实现别看 React 和 Vue 在开发时区别那么大，其实在实现了 BOM/DOM API 之后，它们之间的区别就很小了。 Vue 和 React 最大的区别就在于运行时的 CreateVuePage 方法，这个方法里进行了一些运行时的处理，比如：生命周期的对齐。 其他的部分，如通过 BOM/DOM 方法构建、修改 DOM Tree 及渲染原理，都是和 React 一致的。 Flutter 实现提到 Flutter ，就不得不提 Flutter Web ，Flutter Web 是在标准浏览器 API 之上实现 Flutter 的核心绘图层，本质上也是最终调用了 BOM/DOM API。因此，理论来说，也是可以进行适配的，但这一块我们并不会投入太多的精力，最终会像快应用一样交给社区来实现和维护。 更多细节接下来和大家展开聊一下 Taro Next 更多的细节实现，比如：事件、更新、生命周期。 事件首先的 Taro Next 事件，具体的实现方式如下： 在 小程序组件的模版化过程中，将所有事件方法全部指定为 调用 ev 函数，如：bindtap、bindchange、bindsubmit 等。 在 运行时实现 eventHandler 函数，和 eh 方法绑定，收集所有的小程序事件 通过 document.getElementById() 方法获取触发事件对应的 TaroNode 通过 createEvent() 创建符合规范的 TaroEvent 调用 TaroNode.dispatchEvent 重新触发事件 可以看到，Taro Next 事件本质上是基于 Taro DOM 实现了一套自己的事件机制，这样做的好处之一是，无论小程序是否支持事件的冒泡与捕获，Taro 都能支持。 更新无论是 React 还是 Vue ，最终都会调用 Taro DOM 方法，如：appendChild、insertChild 等。 这些方法在修改 Taro DOM Tree 的同时，还会调用 enqueueUpdate 方法，这个方法能获取到每一个 DOM 方法最终修改的节点路径和值，如：{root.cn.[0].cn.[4].value: &quot;1&quot;}，并通过 setData 方法更新到视图层。 可以看到，这里更新的粒度是 DOM 级别，只有最终发生改变的 DOM 才会被更新过去，相对于之前 data 级别的更新会更加精准，性能更好。 生命周期相对与其他部分大刀阔斧的升级改造，生命周期可能是变动最小的部分之一。和之前类似，生命周期的实现是在运行时维护的 App 实例 / Page 实例进行了生命周期方法的一一对应。 123456789101112131415161718const config: PageInstance = &#123; onLoad (this: MpInstance, options) &#123; //... &#125;, onUnload () &#123; //... &#125;, onShow () &#123; safeExecute('onShow') &#125;, onHide () &#123; safeExecute('onHide') &#125;, onPullDownRefresh () &#123; safeExecute('onPullDownRefresh') &#125; //...&#125; 新架构特点和之前的架构不同，Taro Next 是 近乎全运行。 新的架构基本解决了之前的遗留问题： 无 DSL 限制：无论是你们团队是 React 还是 Vue 技术栈，都能够使用 Taro 开发 模版动态构建：和之前模版通过编译生成的不同，Taro Next 的模版是固定的，然后基于组件的 template，动态 “递归” 渲染整棵 Taro DOM 树。 新特性无缝支持：由于 Taro Next 本质上是将 React/Vue 运行在小程序上，因此，各种新特性也就无缝支持了。 社区贡献更简单：错误栈将和 React/Vue 一致，团队只需要维护核心的 taro-runtime。 基于 Webpack：Taro Next 基于 Webpack 实现了多端的工程化，提供了插件功能。 性能优化前面提到，同等条件下，编译时做的工作越多，也就意味着运行时做的工作越少，性能会更好。Taro Next 的新架构变成 近乎全运行 之后，花了很多精力在性能优化上面。 再这之前。可以先看一下 Taro Next 的流程和原生小程序的流程对比。 可以发现，相比原生小程序，Taro Next 多了红色部分的带来的性能隐患，如：引入React/Vue 带来的 包的 Size 增加，运行时的损耗、Taro DOM Tree 的构建和更新、DOM data 初始化和更新。 而我们真正能做的，只有绿色部分，也就是：Taro DOM Tree 的构建和更新、DOM data 初始化和更新。 Size首先我们来看包 Size，下面的表格是 TodoMVC 的例子，在原生、Taro Old、Taro Next 等情况下的包大小对比，可以看到，引入 React/Vue 后，包大小在 Gzip 情况下大概增加了 30k 左右。 不过我们在前面一再强调：和之前模版通过编译生成的不同，Taro Next 的模版是固定的，然后基于组件的 template，动态 “递归” 渲染整棵 Taro DOM 树。也就是说，Taro Next 的 WXML 大小是有上限的。 随着项目的增加，页面越来越多，原生的项目 WXML 体积会不断增加，而 Taro Next 不会。也就是说，当页面的数量超过一个临界点时，Taro Next 的包体积可能会更小。因此，包 Size 的问题不足为虑。 DOM Tree在 Taro DOM Tree 的构建和更新阶段，我们实现了一套仅实现了高效的、精简版 DOM/BOM API，而且仅仅实现了必要的。 Github上有一个仓库 jsdom，基本上是在 Node.js 上实现了一套 Web 标准的 DOM/BOM ，这个仓库的代码在压缩前大概有 2.1M，而 Taro Next 的核心的 DOM/BOM API 代码才 1000 行不到。 因此，我们最大限度的保证了 Taro DOM Tree 构建和更新阶段的性能。 Update Date在数据更新阶段，首先前面有提到过，Taro Next 的更新是 DOM 级别的，比 Data 级别的更新更加高效，因为 Data 粒度更新实际上是有冗余的，并不是所有的 Data 的改变最后都会引起 DOM 的更新。 其次，Taro 在更新的时候将 Taro DOM Tree 的 path 进行压缩，这点也极大的提升了性能。 最终的结果是：在某些业务场景写，add、select 数据，Taro Next 的性能比原生的还要好。 taro-benchmark当然，实验的数据总归会有缺陷，最终具体的性能表现，还要靠各种复杂业务场景的检验。大家如果对 Taro Next 的性能感兴趣的，可以自行跑一下 taro-benchmark 包，对比一下结果。 我们也在一直持续的全方位优化 Taro Next 的性能，具体可以关注 Taro Next 的最新的 Commit 。 总结及展望Taro 未来规划Taro Next 将会在不久之后的 3.0 版本正式发布，支持使用 React/Vue 开发跨端小程序，然后在会在后续的迭代中拓展至其他端，并完善对应的生态。 Taro 团队还是会将支持的重点放在 React/Vue，Flutter 和 Angular 会像快应用一样，交给社区来适配和维护，快应用就是华为的 Qiyu8 和 Issacpeng 在帮我们进行适配，非常感谢他们。 同时，我们还打造了 「Taro 移动端一站式研发平台」，将先前积累的多端开发工作流和工程化的方案进行了统一，并内置了数据监控、组件市场以及可视化搭建，当前正处于内测阶段。 一点思考 业务孵化技术，技术服务业务：这也是整个 Taro 项目从创建到迭代至今最重要的、感受最深的一点。 自上而下 OR 自下而上：从开发者的角度自上而下看，React/Vue 的代码书写方式差异挺大的；然而站在浏览器的角度自下而上的看，它们的差别其实没那么大，都是调用了 BOM/DOM 那几个常用的 API。如果我们再往底层一点，站在渲染层的角度，不同平台之间的差异会不会也没那么大？比如：Flutter。 Learn Once Write AnyWhere &amp; Write Once Run AnyWhere：很多开发者更喜欢 React 提出的Learn Once Write AnyWhere，而我们 Taro 的口号是 Write Once Run AnyWhere，这一点也导致我们经常被人喷，这里说一点我自己的想法：Learn Once Write AnyWhere其实本质上对开发者更友好，比如开发者只需要学习 React 技术栈，就可以开发 Web/移动端 应用，但是对项目就没那么友好了，每个项目都得维护一份代码；而 Write Once Run AnyWhere 是对开发者没那么友好（适配的端越多，适配的成本必然也会水涨船高，对开发者要求也很变高），但是根据我们的实践，对项目会更友好，「一套代码，多端适配」。当然，这里适配的粒度，并不一定是项目级别的，其实在我们的具体实践中，有相当一部分是：业务级甚至是页面级的。 写在最后正所谓「单丝不成线，独木不成林」，Taro 发展至今早已不在属于单一团队的项目了，而是整个 Taro 开发社区共同的项目。 最后，还是借此机会感谢一些社区所有帮助过 Taro 的成长的人，特别是 Taro 的贡献者们，非常感谢！ 同时也感谢受邀成为 TaroUI 核心维护人员的 Garfield550 (小姐姐)、梁音、ShaoQian Liu，他们将支撑起 TaroUI 的后续迭代与维护。 当然还有在社区中乐于助人、积极贡献的 zacksleo 、Jay Fong、loveonelong、lolipop99、波仔糕、原罪、lentoo 、白领夏公子 、YuanQuan、 tourze、 lingxiaoZhu 等等。 此外，还要感谢一直默默为 Taro 发展提供宝贵建议的研发团队：腾讯云、数字广东、腾讯CDC、网易严选、华为开源团队、招联消费金融等等。 长风破浪会有时，直挂云帆济沧海。 欢迎关注凹凸实验室博客：aotu.io 或者关注凹凸实验室公众号（AOTULabs），不定时推送文章：","pubDate":"Thu, 02 Jan 2020 10:00:00 GMT","guid":"https://aotu.io/notes/2020/01/02/gmtc/","category":"Web开发"},{"title":"羚珑项目自动化测试方案实践","link":"https://aotu.io/notes/2019/12/05/ling-testing-project/","description":"分享内容及技术栈本文将分享结合羚珑项目自身情况搭建的测试工作流的实践经验，针对于 Node.js 服务端应用的工具方法和接口的单元测试、集成测试等。实践经验能给你带来： 利用 Jest 搭建一套开发体验友好的测试工作流。 书写一个高效的单元测试用例，及集成测试用例。 利用封装技术实现模块间的分离，简化测试代码。 使用 SuperTest 完成应用进程与测试进程的合并。 创建高效的数据库内存服务，实现彼此隔离的测试套件运行机制。 了解模拟（Mock）、快照（snapshot）与测试覆盖率等功能的使用。 理解 TDD 与 BDD。 … 文中涉及的基础技术栈有（需要了解的知识）： TypeScript: JavaScript 语言的超集，提供类型系统和新 ES 语法支持。 SuperTest: HTTP 代理及断言工具。 MongoDB: NoSQL 分布式文件存储数据库。 Mongoose: MongoDB 对象关系映射操作库（ORM）。 Koa: 基础 Web 应用程序框架。 Jest: 功能丰富的 JavaScript 测试框架。 lodash: JavaScript 工具函数库。 关于羚珑 羚珑是京东旗下智能设计平台，提供在线设计服务，主要包括大类如： 图片设计：快速合成广告图，主图，公众号配图，海报，传单，物流面单等线上与线下设计服务。 视频设计：快速合成主图视频，抖音短视频，自定义视频等设计服务。 页面设计：快速搭建活动页，营销页，小游戏，小程序等设计服务。 实用工具：批量抠图、改尺寸、配色、加水印等。 基于行业领先技术，为商家、用户提供丰富的设计能力，实现快速产出。 羚珑架构及测试框架选型先介绍下羚珑项目的架构，方便后续的描述和理解。羚珑项目采用前后端分离的机制，前端采用 React Family 的基础架构，再加上 Next.js 服务端渲染以提供更好的用户体验及 SEO 排名。后端架构则如下图所示，流程大概是浏览器或第三方应用访问项目 Nginx 集群，Nginx 集群再通过负载均衡转发到羚珑应用服务器，应用服务器再通过对接外部服务或内部服务等，或读写缓存、数据库，逻辑处理后通过 HTTP 返回到前端正确的数据。 主流测试框架对比接下来，根据项目所需我们对比下当下 Node.js 端主流的测试框架。 Jest Mocha AVA Jasmine GitHub Stars 28.5K 18.7K 17.1K 14.6K GitHub Used by 1.5M 926K 46.6K 5.3K 文档友好 优秀 良好 良好 良好 模拟功能（Mock） 支持 外置 外置 外置 快照功能（Snapshot） 支持 外置 支持 外置 支持 TypeScript ts-jest ts-mocha ts-node jasmine-ts 详细的错误输出 支持 支持 支持 未知 支持并行与串行 支持 外置 支持 外置 每个测试进程隔离 支持 不支持 支持 未知 *文档友好：文档结构组织有序，API 阐述完整，以及示例丰富。 分析： 之所以 Mocha GitHub 使用率很高，很有可能是因为出现的最早（2011年），并由 Node.js 届顶级开发者 TJ 领导开发的（后转向Go语言），所以早期项目选择了 Mocha 做为测试框架，而 Jest、AVA 则是后起之秀（2014年），并且 Stars 数量都在攀升，预计新项目都会在这两个框架中挑选。 相比外置功能，内置支持可能会与框架融合的更好，理念更趋近，维护更频繁，使用更省心。 Jest 模拟功能可以实现方法模拟，定时器模拟，模块/文件依赖模拟，在实际编写测试用例中，模拟模块功能（mock modules）被常常用到，它可以确保测试用例快速响应并且不会变化无常。下文也会谈到如何使用它，为什么需要使用它。 综上，我们选择了 Jest 作为基础测试框架。 从0到1落地实践Jest 框架配置接下来，我们从 0 到 1 开始实践，首先是搭建测试流，虽然 Jest 可以达到开箱即用，然而项目架构不尽相同，大多时候需要根据实际情况做些基础配置工作。以下是根据羚珑项目提取出来的简化版项目目录结构，如下。 123456789101112├─ dist # TS 编译结果目录├─ src # TS 源码目录│ ├─ app.ts # 应用主文件，类似 Express 框架的 /app.js 文件│ └─ index.ts # 应用启动文件，类似 Express 框架的 /bin/www 文件├─ test # 测试文件目录│ ├─ @fixtures # 测试固定数据│ ├─ @helpers # 测试工具方法│ ├─ module1 # 模块1的测试套件集合│ │ └─ test-suite.ts # 测试套件，一类测试用例集合│ └─ module2 # 模块2的测试套件集合├─ package.json └─ yarn.lock 这里有两个小点： 以 @ 开头的目录，我们定义为特殊文件目录，用于提供些测试辅助工具方法、配置文件等，平级的其他目录则是测试用例所在的目录，按业务模块或功能划分。以 @ 开头可以清晰的显示在同级目录最上方，很容易开发定位，凑巧也方便了编写正则匹配。 test-suite.ts 是项目内最小测试文件单元，我们称之为测试套件，表示同一类测试用例的集合，可以是某个通用函数的多个测试用例集合，也可以是一个系列的单元测试用例集合。 首先安装测试框架。 1yarn add --dev jest ts-jest @types/jest 因为项目是用 TypeScript 编写，所以这里同时安装 ts-jest @types/jest。然后在根目录新建 jest.config.js 配置文件，并做如下小许配置。 123456789101112131415module.exports = &#123; // preset: 'ts-jest', globals: &#123; 'ts-jest': &#123; tsConfig: 'tsconfig.test.json', &#125;, &#125;, testEnvironment: 'node', roots: ['&lt;rootDir&gt;/src/', '&lt;rootDir&gt;/test/'], testMatch: ['&lt;rootDir&gt;/test/**/*.ts'], testPathIgnorePatterns: ['&lt;rootDir&gt;/test/@.+/'], moduleNameMapper: &#123; '^~/(.*)': '&lt;rootDir&gt;/src/$1', &#125;,&#125; preset: 预设测试运行环境，多数情况设置为 ts-jest 即可，如果需要为 ts-jest 指定些参数，如上面指定 TS 配置为 tsconfig.test.json，则需要像上面这样的写法，将 ts-jest 挂载到 globals 属性上，更多配置可以移步其官方文档，这里。 testEnvironment: 基于预设再设置测试环境，Node.js 需要设置为 node，因为默认值为浏览器环境 jsdom。 roots: 用于设定测试监听的目录，如果匹配到的目录的文件有所改动，就会自动运行测试用例。&lt;rootDir&gt; 表示项目根目录，即与 package.json 同级的目录。这里我们监听 src 和 test 两个目录。 testMatch: Glob 模式设置匹配的测试文件，当然也可以是正则模式，这里我们匹配 test 目录下的所有文件，匹配到的文件才会当做测试用例执行。 testPathIgnorePatterns: 设置已经匹配到的但需要被忽略的文件，这里我们设置以 @ 开头的目录及其所有文件都不当做测试用例。 moduleNameMapper: 这个与 TS paths 和 Webpack alias 雷同，用于设置目录别名，可以减少引用文件时的出错率并且提高开发效率。这里我们设置以 ~ 开头的模块名指向 src 目录。 第一个单元测试用例搭建好测试运行环境，于是便可着手编写测试用例了，下面我们编写一个接口单元测试用例，比方说测试首页轮播图接口的正确性。我们将测试用例放在 test/homepage/carousel.ts 文件内，代码如下。 1234567891011121314151617181920212223242526import &#123; forEach, isArray &#125; from 'lodash’import &#123; JFSRegex, URLRegex &#125; from '~/utils/regex'import request from 'request-promise'const baseUrl = 'http://ling-dev.jd.com/server/api'// 声明一个测试用例test('轮播图个数应该返回 5，并且数据正确', async () =&gt; &#123; // 对接口发送 HTTP 请求 const res = await request.get(baseUrl + '/carousel/pictures') // 校验返回状态码为 200 expect(res.statusCode).toBe(200) // 校验返回数据是数组并且长度为 5 expect(isArray(res.body)).toBe(true) expect(res.body.length).toBe(5) // 校验数据每一项都是包含正确的 url, href 属性的对象 forEach(res.body, picture =&gt; &#123; expect(picture).toMatchObject(&#123; url: expect.stringMatching(JFSRegex), href: expect.stringMatching(URLRegex), &#125;) &#125;)&#125;) 编写好测试用例后，第一步需要启动应用服务器： 第二步运行测试，在命令行窗口输入：npx jest，如下图可以看到用例测试通过。 当然最佳实践则是把命令封装到 package.json 里，如下： 123456&#123; \"scripts\": &#123; \"test\": \"jest\", \"test:watch\": \"jest --watch\", &#125;&#125; 之后便可使用 yarn test 来运行测试，通过 yarn test:watch 来启动监听式测试服务。 SuperTest 增强虽然上面已经完成基本的测试流程开发，但很明显的一个问题是每次运行测试，我们需要先启动应用服务，共启动两个进程，并且需要提前配置 ling-dev.jd.com 指向 127.0.0.1:3800，这是一个繁琐的过程。所以我们引入了 SuperTest，它可以把应用服务集成到测试服务一起启动，并且不需要指定 HTTP 请求的主机地址。 我们封装一个公共的 request 方法，将它放在 @helpers/agent.ts 文件内，如下。 12345import http from 'http'import supertest from 'supertest'import app from '~/app'export const request = supertest(http.createServer(app.callback())) 解释： 使用 app.callback() 而不是 app.listen()，是因为它可以将同一个 app 同时作为 HTTP 和 HTTPS 或多个地址。app.callback() 返回适用于 http.createServer() 方法的回调函数来处理请求。 之后，http.createServer() 创建一个未监听的 HTTP 对象给 SuperTest，当然 SuperTest 内部也会调用 listen(0) 这样的特殊端口，让操作系统提供可用的随机端口来启动应用服务器。 所以上面的测试用例我们可以改写成这样： 1234567891011import &#123; forEach, isArray &#125; from 'lodash’import &#123; JFSRegex, URLRegex &#125; from '~/utils/regex'// 引入公共的 request 方法import &#123; request &#125; from '../@helpers/agent'test('轮播图个数应该返回 5，并且数据正确', async () =&gt; &#123; const res = await request.get('/api/carousel/pictures') expect(res.status).toBe(200) // 同样的校验...&#125;) 因为 SuperTest 内部已经帮我们包装好了主机地址并自动启动应用服务，所以请求接口时只需书写具体的接口，如 /api/carousel/pictures，也只需运行一条命令 yarn test，就可以完成整个测试工作。 数据库内存服务项目架构中可以看到数据库使用的是 MongoDB，在测试时，几乎所有的接口都需要与数据库连接。此时可通过环境变量区分并新建 test 数据库，用于运行测试用例。有点不好的是测试套件执行完成后需要对 test 数据库进行清空，以避免脏数据影响下个测试套件，尤其是在并发运行时，需要保持数据隔离。 使用 MongoDB Memory Server 是更好的选择，它会启动独立的 MongoDB 实例（每个实例大约占用非常低的 7MB 内存），而测试套件将运行在这个独立的实例里。假如并发为 3，那就创建 3 个实例分别运行 3 个测试套件，这样可以很好的保持数据隔离，并且数据都保存在内存中，这使得运行速度会非常快，当测试套件完成后则自动销毁实例。 接下来我们把 MongoDB Memory Server 引入实际测试中，最佳方式是把它写进 Jest 环境配置里，这样只需要一次书写，自动运行在每个测试套件中。所以替换 jest.config.js 配置文件的 testEnvironment 为自定义环境 &lt;rootDir&gt;/test/@helpers/jest-env.js。 编写自定义环境 @helpers/jest-env.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445const NodeEnvironment = require('jest-environment-node')const &#123; MongoMemoryServer &#125; = require('mongodb-memory-server')const child_process = require('child_process')// 继承 Node 环境class CustomEnvironment extends NodeEnvironment &#123; // 在测试套件启动前，获取本地开发 MongoDB Uri 并注入 global 对象 async setup() &#123; const uri = await getMongoUri() this.global.testConfig = &#123; mongo: &#123; uri &#125;, &#125; await super.setup() &#125;&#125;async function getMongoUri() &#123; // 通过 which mongod 命令拿到本地 MongoDB 二进制文件路径 const mongodPath = await new Promise((resolve, reject) =&gt; &#123; child_process.exec( 'which mongod', &#123; encoding: 'utf8' &#125;, (err, stdout, stderr) =&gt; &#123; if (err || stderr) &#123; return reject( new Error('找不到系统的 mongod，请确保 `which mongod` 可以指向 mongod') ) &#125; resolve(stdout.trim()) &#125; ) &#125;) // 使用本地 MongoDB 二进制文件创建内存服务实例 const mongod = new MongoMemoryServer(&#123; binary: &#123; systemBinary: mongodPath &#125;, &#125;) // 得到创建成功的实例 Uri 地址 const uri = await mongod.getConnectionString() return uri&#125;// 导出自定义环境类module.exports = CustomEnvironment Mongoose 中便可以这样连接： 1234await mongoose.connect((global as any).testConfig.mongo.uri, &#123; useNewUrlParser: true, useUnifiedTopology: true,&#125;) 当然在 package.json 里需要禁用 MongoDB Memory Server 去下载二进制包，因为上面已经使用了本地二进制包。 12345678\"config\": &#123; \"mongodbMemoryServer\": &#123; \"version\": \"4.0\", // 禁止在 yarn install 时下载二进制包 \"disablePostinstall\": \"1\", \"md5Check\": \"1\" &#125;&#125; 登录功能封装与使用大多时候接口是需要登录后才能访问的，所以我们需要把整块登录功能抽离出来，封装成通用方法，同时借此初始化一些测试专用数据。 为了使 API 易用，我希望登录 API 长这样： 1234567891011import &#123; login &#125; from '../@helpers/login'// 调用登录方法，根据传递的角色创建用户，并返回该用户登录的 request 对象。// 支持多参数，根据参数不同自动初始化测试数据。const request = await login(&#123; role: 'user',&#125;)// 使用已登录的 request 对象访问需要登录的用户接口，// 应当是登录态，并正确返回当前登录的用户信息。const res = await request.get('/api/user/info') 开发登录方法： 123456// @helpers/agent.ts // 新添加 makeAgent 方法export function makeAgent() &#123; // 使用 supertest.agent 支持 cookie 持久化 return supertest.agent(http.createServer(app.callback()))&#125; 123456789101112131415161718192021222324252627282930// @helpers/login.tsimport &#123; assign, cloneDeep, pick &#125; from 'lodash'import &#123; makeAgent &#125; from './agent'export async function login(userData: UserDataType): Promise&lt;RequestAgent&gt; &#123; userData = cloneDeep(userData) // 如果没有用户名，自动创建用户名 if (!userData.username) &#123; userData.username = chance.word(&#123; length: 8 &#125;) &#125; // 如果没有昵称，自动创建昵称 if (!userData.nickname) &#123; userData.nickname = chance.word(&#123; length: 8 &#125;) &#125; // 得到支持 cookie 持久化的 request 对象 const request: any = makeAgent() // 发送登录请求，这里为测试专门设计一个登录接口 // 包含正常登录功能，但还会根据传参不同初始化测试专用数据 const res = await request.post('/api/login-test').send(userData) // 将登录返回的数据赋值到 request 对象上 assign(request, pick(res.body, ['user', 'otherValidKey...'])) // 返回 request 对象 return request as RequestAgent&#125; 实际用例中就像上面示例方式使用。 模拟功能使用从项目架构中可以看到项目也会调用较多外部服务。比方说创建文件夹的接口，内部代码需要调用外部服务去鉴定文件夹名称是否包含敏感词，就像这样： 1234567import &#123; detectText &#125; from '~/utils/detect'// 调用外部服务检测文件夹名称是否包含敏感词const &#123; ok, sensitiveWords &#125; = await detectText(folderName)if (!ok) &#123; throw new Error(`检测到敏感词: $&#123;sensitiveWords&#125;`)&#125; 实际测试的时候并不需要所有测试用例运行时都调用外部服务，这样会拖慢测试用例的响应时间以及不稳定性。我们可以建立个更好的机制，新建一个测试套件专门用于验证 detectText 工具方法的正确性，而其他测试套件运行时 detectText 方法直接返回 OK 即可，这样既保证了 detectText 方法被验证到，也保证了其他测试套件得到快速响应。 模拟功能（Mock）就是为这样的情景而诞生的。我们只需要在 detectText 方法的路径 utils/detect.ts 同级新建__mocks__/detect.ts 模拟文件即可，内容如下，直接返回结果： 123456export async function detectText( text: string): Promise&lt;&#123; ok: boolean; sensitive: boolean; sensitiveWords?: string &#125;&gt; &#123; // 删除所有代码，直接返回 OK return &#123; ok: true, sensitive: false &#125;&#125; 之后每个需要模拟的测试套件顶部加上下面一句代码即可。 1jest.mock('~/utils/detect.ts') 在验证 detectText 工具方法的测试套件里，则只需 jest.unmock 即可恢复真实的方法。 1jest.unmock('~/utils/detect.ts') 当然应该把 jest.mock 写在 setupFiles 配置里，因为需要模拟的测试套件占绝大多数，写在配置里会让它们在运行前自动加载该文件，这样开发就不必每处测试套件都加上一段同样的代码，可以有效提高开发效率。 12// jest.config.jssetupFiles: ['&lt;rootDir&gt;/test/@helpers/jest-setup.ts'] 12// @helpers/jest-setup.tsjest.mock('~/utils/detect.ts') 模拟功能还有方法模拟，定时器模拟等，可以查阅其文档了解更多示例。 快照功能使用快照功能（Snapshot）可以帮我们测试大型对象，从而简化测试用例。 举个例子，项目的模板解析接口，该接口会将 PSD 模板文件进行解析，然后吐出一个较大的 JSON 数据，如果挨个校验对象的属性是否正确可能很不理想，所以可以使用快照功能，就是第一次运行测试用例时，会把 JSON 数据存储到本地文件，称之为快照文件，第二次运行时，就会将第二次返回的数据与快照文件进行比较，如果两个快照匹配，则表示测试成功，反之测试失败。 而使用方式很简单： 12345// 请求模板解析接口const res = await request.post('/api/secret/parser')// 断言快照是否匹配expect(res.body).toMatchSnapshot() 更新快照也是敏捷的，运行命令 jest --updateSnapshot 或在监听模式输入 u 来更新。 集成测试集成测试的概念是在单元测试的基础上，将所有模块按照一定要求或流程关系进行串联测试。比方说，一些模块虽然能够单独工作，但并不能保证连接起来也能正常工作，一些局部反映不出来的问题，在全局上很可能暴露出来。 因为测试框架 Jest 对于每个测试套件是并行运行的，而套件内的用例则是串行运行的，所以编写集成测试很方便，下面我们用文件夹的使用流程示例如何完成集成测试的编写。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import &#123; request &#125; from '../@helpers/agent'import &#123; login &#125; from '../@helpers/login'const urlCreateFolder = '/api/secret/folder' // POSTconst urlFolderDetails = '/api/secret/folder' // GETconst urlFetchFolders = '/api/secret/folders' // GETconst urlDeleteFolder = '/api/secret/folder' // DELETEconst urlRenameFolder = '/api/secret/folder/rename' // PUTconst folders: ObjectAny[] = []let globalReq: ObjectAnytest('没有权限创建文件夹应该返回 403 错误', async () =&gt; &#123; const res = await request.post(urlCreateFolder).send(&#123; name: '我的文件夹', &#125;) expect(res.status).toBe(403)&#125;)test('确保创建 3 个文件夹', async () =&gt; &#123; // 登录有权限创建文件夹的用户，比如设计师 globalReq = await login(&#123; role: 'designer' &#125;) for (let i = 0; i &lt; 3; i++) &#123; const res = await globalReq.post(urlCreateFolder).send(&#123; name: '我的文件夹' + i, &#125;) // 将创建成功的文件夹置入 folders 常量里 folders.push(res.body) expect(res.status).toBe(200) // 更多验证规则... &#125;&#125;)test('重命名第 2 个文件夹', async () =&gt; &#123; const res = await globalReq.put(urlRenameFolder).send(&#123; id: folders[1].id, name: '新文件夹名称', &#125;) expect(res.status).toBe(200)&#125;)test('第 2 个文件夹的名称应该是【新文件夹名称】', async () =&gt; &#123; const res = await globalReq.get(urlFolderDetails).query(&#123; id: folders[1].id, &#125;) expect(res.status).toBe(200) expect(res.body.name).toBe('新文件夹名称') // 更多验证规则...&#125;)test('获取文件夹列表应该返回 3 条数据', async () =&gt; &#123; // 与上雷同，鉴于代码过多，先行省略...&#125;)test('删除最后一个文件夹', async () =&gt; &#123; // 与上雷同，鉴于代码过多，先行省略...&#125;)test('再次获取文件夹列表应该返回 2 条数据', async () =&gt; &#123; // 与上雷同，鉴于代码过多，先行省略...&#125;) 测试覆盖率测试覆盖率是对测试完成程度的评测，基于文件被测试的情况来反馈测试的质量。 运行命令 jest --coverage 即可生成测试覆盖率报告，打开生成的 coverage/lcov-report/index.html 文件，各项指标一览无余。因为 Jest 内部使用 Istanbul 生成覆盖率报告，所以各项指标依然参考 Istanbul。 持续集成写完这么多测试用例之后，或者是开发完功能代码后，我们是不是希望每次将代码推送到托管平台，如 GitLab，托管平台能自动帮我们运行所有测试用例，如果测试失败就邮件通知我们修复，如果测试通过则把开发分支合并到主分支？ 答案是必须的。这就与持续集成（Continuous Integration）不谋而合，通俗的讲就是经常性地将代码合并到主干分支，每次合并前都需要运行自动化测试以验证代码的正确性。 所以我们配置一些自动化测试任务，按顺序执行安装、编译、测试等命令，测试命令则是运行编写好的测试用例。一个 GitLab 的配置任务（.gitlab-ci.yml）可能像下面这样，仅作参考。 123456789101112131415161718192021222324252627# 每个 job 之前执行的命令before_script: - echo \"`whoami` ($0 $SHELL)\" - echo \"`which node` (`node -v`)\" - echo $CI_PROJECT_DIR# 定义 job 所属 test 阶段及执行的命令等test: stage: test except: - test cache: paths: - node_modules/ script: - yarn - yarn lint - yarn test# 定义 job 所属 deploy 阶段及执行的命令等deploy-stage: stage: deploy only: - test script: - cd /app - make BRANCH=origin/$&#123;CI_COMMIT_REF_NAME&#125; deploy-stage 持续集成的好处： 快速发现错误。 防止分支大幅偏离主干分支。 让产品可以快速迭代，同时还能保持高质量。 TDD与BDD引入TDD 全称测试驱动开发（Test-driven development），是敏捷开发中的一种设计方法论，强调先将需求转换为具体的测试用例，然后再开发代码以使测试通过。 BDD 全称行为驱动开发（Behavior-driven development），也是一种敏捷开发设计方法论，它没有强调具体的形式如何，而是强调【作为什么角色，想要什么功能，以便收益什么】这样的用户故事指定行为的论点。 两者都是很好的开发模式，结合实际情况，我们的测试更像是 BDD，不过并没有完全摒弃 TDD，我们的建议是如果觉得先写测试可以帮助更快的写好代码，那就先写测试，如果觉得先写代码再写测试，或一边开发一边测试更好，则采用自己的方式，而结果是编码功能和测试用例都需要完成，并且运行通过，最后通过 Code Review 对代码质量做进一步审查与把控。 笔者称之为【师夷长技，聚于自身】：结合项目自身的实际情况，灵活变通，形成一套适合自身项目发展的模式驱动开发。 结论自动化测试提供了一种有保障的机制检测整个系统，可以频繁地进行回归测试，有效提高系统稳定性。当然编写与维护测试用例需要耗费一定的成本，需要考虑投入与产出效益之间的平衡。","pubDate":"Thu, 05 Dec 2019 02:00:00 GMT","guid":"https://aotu.io/notes/2019/12/05/ling-testing-project/","category":"Web开发"},{"title":"前端也要懂一点 MongoDB Schema 设计","link":"https://aotu.io/notes/2019/12/04/6-Rules-of-Thumb-for-MongoDB-Schema-Design/","description":"翻译自 MongoDB 官方博客： 6 Rules of Thumb for MongoDB Schema Design: Part 1 6 Rules of Thumb for MongoDB Schema Design: Part 2 6 Rules of Thumb for MongoDB Schema Design: Part 3 时间仓促，水平有限，难免有遗漏和不足，还请不吝指正。 “我有很多 SQL 的开发经验，但是对于 MongoDB 来说，我只是个初学者。 我该如何在数据库里实现 One-to-N 的关系? ” 这是我从参加 MongoDB office hours 的用户那里得到的最常见的问题之一。 对于这个问题，我无法提供一个简单明了的答案，因为在 MongoDB 里，有很多种方法可以实现 One-to-N 关系。 Mongodb 拥有丰富且细致入微的词汇表，用来表达在 SQL 中精简的术语 One-to-N 所包含的内容。接下来让我带你遍历一下 使用 Mongodb 实现 One-to-N 关系的各种方式。 这一块涉及到的内容很多，因此我把它分成三部分。 在第一部分中，我将讨论建立 One-to-N 关系模型的三种基本方法。 在第二部分中，我将介绍更复杂的模式设计（schema designs），包括 反规范化（denormalization）和 双向引用（two-way referencing）。 在最后一部分，我将回顾一系列的选型，并给出一些建议和原则，保证你在创建 One-to-N 关系时，从成千上万的选择中做出正确的选择。 Part 1许多初学者认为，在 MongoDB 中建立 One-to-N 模型的唯一方法是在父文档中嵌入一组 子文档（sub-documents），但事实并非如此。 你可以嵌入一个文档，并不意味着你应该嵌入一个文档。（PS：这也是我们写代码的原则之一：You can doesn’t mean you should ） 在设计 MongoDB 模式时，您需要先考虑在使用 SQL 时从未考虑过的问题：关系（relationship）的基数（cardinality）是什么？ 简而言之: 你需要用更细微的差别来描述你的 One-to-N 关系: 是 one-to-few、one-to-many 还是 one-to-squillions ？ 根据它是哪一个，你可以使用不同的方式来进行关系建模。 Basics: Modeling One-to-Fewone-to-few 的一个例子通常是一个人的地址。 这是一个典型的使用 嵌入（embedding）的例子 – 你可以把地址放在 Person 对象的数组中： 123456789&gt; db.person.findOne()&#123; name: 'Kate Monster', ssn: '123-456-7890', addresses : [ &#123; street: '123 Sesame St', city: 'Anytown', cc: 'USA' &#125;, &#123; street: '123 Avenue Q', city: 'New York', cc: 'USA' &#125; ]&#125; 这种设计具有嵌入的所有优点和缺点：主要优点是不必执行单独的查询来获取嵌入的详细信息；主要缺点是无法将嵌入的详细信息作为 独立实体（stand-alone entities）来访问。 例如，如果您为一个任务跟踪系统建模，每个 Person 都会有一些分配给他们的任务。 在 Person 文档中嵌入任务会使 “显示明天到期的所有任务” 这样的查询比实际需要的要困难得多。 Basics: One-to-Many“one-to-many” 的一个例子可能是替换零件（parts）订购系统中的产品（products）的零部件。 每个产品可能有多达几百个替换零件，但从来没有超过几千（所有不同尺寸的螺栓、垫圈和垫圈加起来）。 这是一个很好的使用 引用（referencing）的例子 —— 您可以将零件的 ObjectIDs 放在产品文档的数组中。 (示例使用 2 字节的 ObjectIDs，以方便阅读) 每个零件都有自己的 document: 123456789&gt; db.parts.findOne()&#123; _id : ObjectID('AAAA'), partno : '123-aff-456', name : '#4 grommet', qty: 94, cost: 0.94, price: 3.99&#125; 每个产品也有自己的 document，其中包含对组成产品的各个零件的一系列 ObjectID 引用： 123456789101112&gt; db.products.findOne()&#123; name : 'left-handed smoke shifter', manufacturer : 'Acme Corp', catalog_number: 1234, parts : [ // array of references to Part documents ObjectID('AAAA'), // reference to the #4 grommet above ObjectID('F17C'), // reference to a different Part ObjectID('D2AA'), // etc ] ... 然后，您可以使用 应用程序级别的联接（application-level join）来检索特定产品的零件： 1234 // Fetch the Product document identified by this catalog number&gt; product = db.products.findOne(&#123;catalog_number: 1234&#125;); // Fetch all the Parts that are linked to this Product&gt; product_parts = db.parts.find(&#123;_id: &#123; $in : product.parts &#125; &#125; ).toArray() ; 为了高效运行，您需要在 products.catalog_number 上添加索引。 注意，零件上总是有一个索引 parts._id，这样查询通常效率很高。 这种类型的 引用（referencing）和 嵌入（embedding）相比有一系列的优点和缺点：每个零件都是一个独立的文档，因此很容易对它们进行搜索和单独更新。 使用这个模式的一个弊端是必须执行两次查询来获取有关产品零件的详细信息。 (但是在我们进入第二部分的 反规范化（denormalizing）之前，请保持这种想法。) 作为一个额外的好处，这个模式允许一个单独的零件被多个产品 使用，因此您的 One-to-N 模式就变成了 N-to-N 模式，而不需要任何 联接表（join table）！ Basics: One-to-Squillionsone-to-squillions 的一个典型例子是为不同机器收集日志消息的事件日志系统。 任何给定的 主机（hosts）都可以生成足够的日志信息（logmsg），从而超过溢出 document 16 MB 的限制，即使数组中存储的所有内容都是 ObjectID。这就是 父引用(parent-referencing) 的经典案例 —— 你有一个 host document，然后将主机的 ObjectID 存储在日志信息的 document 中。 12345678910111213&gt; db.hosts.findOne()&#123; _id : ObjectID('AAAB'), name : 'goofy.example.com', ipaddr : '127.66.66.66'&#125;&gt;db.logmsg.findOne()&#123; time : ISODate(\"2014-03-28T09:42:41.382Z\"), message : 'cpu is on fire!', host: ObjectID('AAAB') // Reference to the Host document&#125; 您可以使用（略有不同的） 应用程序级别的联接（application-level join）来查找主机最近的 5,000 条消息： 1234 // find the parent ‘host’ document&gt; host = db.hosts.findOne(&#123;ipaddr : '127.66.66.66'&#125;); // assumes unique index // find the most recent 5000 log message documents linked to that host&gt; last_5k_msg = db.logmsg.find(&#123;host: host._id&#125;).sort(&#123;time : -1&#125;).limit(5000).toArray() 回顾因此，即使在这个基本层次上，在设计 MongoDB Schema 时也需要比在设计类似的 关系模式（ Relational Schema）时考虑更多的问题。 你需要考虑两个因素： One-to-N 中 N-side 的实体是否需要独立存在？ 这种关系的基数性是什么：one-to-few 、 one-to-many、 还是 one-to-squillions ？ 基于这些因素，您可以从三种基本的 One-to-N 模式设计中选择一种： 如果基数是 one-to-few，并且不需要访问父对象上下文之外的 嵌入对象（embedded object），则将 N-side 嵌入父对象 如果基数是 one-to-many ，或者如果 N-side 对象因为任何原因应该单独存在，则使用 N-side 对象的引用数组 如果基数是 one-to-squillions，则使用 N-side 对象中对 One-side 的引用 Part 2这是我们在 MongoDB 中构建 One-to-N 关系的第二站。 上次我介绍了三种基本的模式设计: 嵌入（embedding）、子引用（child-referencing）和父引用（parent-referencing）。 我还提到了在选择这些设计时要考虑的两个因素： One-to-N 中 N-side 的实体是否需要独立存在？ 这种关系的基数性是什么: 是 one-to-few、one-to-many 还是 one-to-squillions？ 有了这些基本技术，我可以继续讨论更复杂的模式设计，包括 双向引用（two-way referencing）和 反规范化（denormalization）。 Intermediate: Two-Way Referencing如果您希望获得一些更好的引用，那么可以结合两种技术，并在 Schema 中包含两种引用样式，既有从 “one” side 到 “one” side 的引用，也有从 “many”side 到 “one” side 的引用。 例如，让我们回到任务跟踪系统。 有一个 “people” 的 collection 用于保存 Person documents，一个 “tasks” collection 用于保存 Task documents，以及来自 Person -&gt; Task 的 One-to-N 关系。 应用程序需要跟踪 Person 拥有的所有任务，因此我们需要引用 Person -&gt; Task。 使用对 Task documents 的引用数组，单个 Person document 可能看起来像这样: 1234567891011db.person.findOne()&#123; _id: ObjectID(\"AAF1\"), name: \"Kate Monster\", tasks [ // array of references to Task documents ObjectID(\"ADF9\"), ObjectID(\"AE02\"), ObjectID(\"AE73\") // etc ]&#125; 另一方面，在其他一些上下文中，这个应用程序将显示一个 Tasks 列表（例如，一个多人项目中的所有 Tasks） ，它将需要快速查找哪个人负责哪个任务。 您可以通过在 Task document 中添加对 Person 的附加引用来优化此操作。 1234567db.tasks.findOne()&#123; _id: ObjectID(\"ADF9\"), description: \"Write lesson plan\", due_date: ISODate(\"2014-04-01\"), owner: ObjectID(\"AAF1\") // Reference to Person document&#125; 这种设计具有 One-to-Many 模式的所有优点和缺点，但添加了一些内容。 在 Task document 中添加额外的 owner 引用意味着可以快速简单地找到任务的所有者，但是这也意味着如果你需要将任务重新分配给其他人，你需要执行两个更新而不是一个。 具体来说，您必须同时更新从 Person 到 Task 文档的引用，以及从 Task 到 Person 的引用。 (对于正在阅读这篇文章的关系专家来说，您是对的: 使用这种模式设计意味着不再可能通过单个 原子更新（atomic update）将一个任务重新分配给一个新的 Person。 这对于我们的任务跟踪系统来说是可行的: 您需要考虑这是否适用于您的特定场景。) Intermediate: Denormalizing With “One-To-Many” Relationships除了对关系的各种类型进行建模之外，您还可以在模式中添加 反规范化（denormalization）。 这可以消除在某些情况下执行 应用程序级联接（application-level join）的需要，但代价是在执行更新时会增加一些复杂性。 举个例子就可以说明这一点。 Denormalizing from Many -&gt; One对于产品-零件示例，您可以将零件的名称非规范化为“parts[]”数组。 作为比较，下面是未采用 反规范化（denormalization）的 Product document 版本。 123456789101112&gt; db.products.findOne()&#123; name : 'left-handed smoke shifter', manufacturer : 'Acme Corp', catalog_number: 1234, parts : [ // array of references to Part documents ObjectID('AAAA'), // reference to the #4 grommet above ObjectID('F17C'), // reference to a different Part ObjectID('D2AA'), // etc ]&#125; 而 反规范化（Denormalizing）意味着在显示 Product 的所有 Part 名称时不必执行应用程序级联接（application-level join），但是如果需要关于某个部件的任何其他信息，则必须执行该联接。 123456789101112&gt; db.products.findOne()&#123; name : 'left-handed smoke shifter', manufacturer : 'Acme Corp', catalog_number: 1234, parts : [ &#123; id : ObjectID('AAAA'), name : '#4 grommet' &#125;, // Part name is denormalized &#123; id: ObjectID('F17C'), name : 'fan blade assembly' &#125;, &#123; id: ObjectID('D2AA'), name : 'power switch' &#125;, // etc ]&#125; 虽然这样可以更容易地获得零件名称，但只需要在 应用程序级别的联接（application-level join）中增加一点 客户端（client-side）工作: 123456// Fetch the product document&gt; product = db.products.findOne(&#123;catalog_number: 1234&#125;); // Create an array of ObjectID()s containing *just* the part numbers&gt; part_ids = product.parts.map( function(doc) &#123; return doc.id &#125; ); // Fetch all the Parts that are linked to this Product&gt; product_parts = db.parts.find(&#123;_id: &#123; $in : part_ids &#125; &#125; ).toArray() ; 只有当读取和更新的比例很高时，反规范化（Denormalizing）才有意义。 如果你经常阅读非标准化（denormalized）的数据，但是很少更新，那么为了得到更有效的查询，付出更慢的更新和更复杂的更新的代价是有意义的。 随着相对于查询的更新变得越来越频繁，非规范化节省的开销会越来越少。 例如: 假设零件名称不经常更改，但手头的数量经常更改。 这意味着，尽管在 Product document 中对零件名称进行 反规范化（Denormalizing）是有意义的，但是对数量进行 反规范化（Denormalizing） 是没有意义的。 还要注意，如果对 字段（field）进行 反规范化（Denormalizing），将失去对该 字段（field）执行原子（atomic）更新和 独立（isolated）更新的能力。 就像上面的 双向引用（two-way referencing）示例一样，如果你先在 Part document 中更新零件名称，然后在 Product 文档中更新零件名称，那么将会有一个 sub-second 的时间间隔，在这个间隔中，Product document 中 反规范化（Denormalizing）的 “name”将不会是 Part document 中新的更新值。 Denormalizing from One -&gt; Many你还可以将字段从 “One” 到 “Many” 进行 反规范化（denormalize）: 1234567891011&gt; db.parts.findOne()&#123; _id : ObjectID('AAAA'), partno : '123-aff-456', name : '#4 grommet', product_name : 'left-handed smoke shifter', // Denormalized from the ‘Product’ document product_catalog_number: 1234, // Ditto qty: 94, cost: 0.94, price: 3.99&#125; 但是，如果您已经将 Product 名称 反规范化（denormalize）到 Part document 中，那么在更新 Product 名称时，您还必须更新 ‘parts’ collection 中出现的所有位置。 这可能是一个更昂贵的更新，因为您正在更新多个零件，而不是单个产品。 因此，在这种方式去规范化时，考虑 读写比（ read-to-write ratio ） 显得更为重要。 Intermediate: Denormalizing With “One-To-Squillions” Relationships你还可以对“one-to-squillions”示例进行 反规范化（denormalize）。 这可以通过两种方式之一来实现: 您可以将关于 “one” side 的信息(‘hosts’ document)放入“squillions” side(log entries) ，或者将来自 “squillions” side 的摘要信息放入 “one” side。 下面是一个将 反规范化（denormalize）转化为“squillions”的例子。 我将把主机的 IP 地址(from the ‘one’ side)添加到单独的日志消息中: 1234567&gt; db.logmsg.findOne()&#123; time : ISODate(\"2014-03-28T09:42:41.382Z\"), message : 'cpu is on fire!', ipaddr : '127.66.66.66', host: ObjectID('AAAB')&#125; 你现在查询来自某个特定 IP 地址的最新消息变得更容易了: 现在只有一个查询，而不是两个。 1&gt; last_5k_msg = db.logmsg.find(&#123;ipaddr : '127.66.66.66'&#125;).sort(&#123;time : -1&#125;).limit(5000).toArray() 事实上，如果你只想在 “one” side 存储有限数量的信息，你可以把它们全部 反规范化（denormalize）为 “squillions” side ，从而完全摆脱 “one” collection： 1234567&gt; db.logmsg.findOne()&#123; time : ISODate(\"2014-03-28T09:42:41.382Z\"), message : 'cpu is on fire!', ipaddr : '127.66.66.66', hostname : 'goofy.example.com',&#125; 另一方面，你也可以 反规范化（denormalize）到 “one” side。 让我们假设你希望在 ‘hosts’ document 中保留来自主机的最后 1000 条消息。 你可以使用 MongoDB 2.4中引入的 $each / $slice 功能来保持列表排序，并且只保留最后的1000条消息： 日志消息保存在 ‘logmsg’ collection 中以及 ‘hosts’ document 中的反规范化列表中: 这样，当消息超出 ‘hosts.logmsgs’ 数组时，它就不会丢失。 1234567891011121314151617 // Get log message from monitoring systemlogmsg = get_log_msg();log_message_here = logmsg.msg;log_ip = logmsg.ipaddr; // Get current timestampnow = new Date() // Find the _id for the host I’m updatinghost_doc = db.hosts.findOne(&#123;ipaddr : log_ip &#125;,&#123;_id:1&#125;); // Don’t return the whole documenthost_id = host_doc._id; // Insert the log message, the parent reference, and the denormalized data into the ‘many’ sidedb.logmsg.save(&#123;time : now, message : log_message_here, ipaddr : log_ip, host : host_id ) &#125;); // Push the denormalized log message onto the ‘one’ sidedb.hosts.update( &#123;_id: host_id &#125;, &#123;$push : &#123;logmsgs : &#123; $each: [ &#123; time : now, message : log_message_here &#125; ], $sort: &#123; time : 1 &#125;, // Only keep the latest ones $slice: -1000 &#125; // Only keep the latest 1000 &#125;&#125; ); 请注意，使用 projection specification ({ _id: 1}) 可以防止 MongoDB 通过网络发布整个 ‘hosts’ document。 通过告诉 MongoDB 只返回 _id 字段，我将网络开销减少到仅存储该字段所需的几个字节（再加上一点 wire protocol 开销）。 正如在 “One-to-Many” 的情况下的反规范化一样，你需要考虑读取与更新的比率。 只有当日志消息的频率与应用程序查看单个主机的所有消息的次数相关时，将日志消息反规范化到 Host 文档才有意义。 如果您希望查看数据的频率低于更新数据的频率，那么这种特殊的反规范化是一个坏主意。 回顾在这篇文章中，我已经介绍了嵌入（embed）、子引用（child-reference）和父引用（ parent-reference）的基础知识之外的其他选择。 如果使用双向引用优化了 Schema，并且愿意为不进行 原子更新（atomic updates）付出代价，那么可以使用双向引用 如果正在引用，可以将数据从 “One” side 到 “N” side，或者从 “N” side 到 “One” side 进行反规范化（denormalize） 在决定是否否否定标准时，应考虑以下因素： 无法对 反规范化（denormalization）的数据执行原子更新（atomic update） 只有当读写比例很高时，反规范化（denormalization）才有意义 下一次，我会给你一些指导方针，让你在所有这些选项中做出选择。 Part 3这是我们在 MongoDB 中建模 One-to-N 关系的最后一站。 在第一篇文章中，我介绍了建立 One-to-N 关系模型的三种基本方法。 上篇文章中，我介绍了这些基础知识的一些扩展: 双向引用（two-way referencing）和反规范化（denormalization）。 反规范化（denormalization）允许你避免某些 应用程序级别的连接（ application-level joins），但代价是要进行更复杂和昂贵的更新。 如果这些字段的读取频率远高于更新频率，则对一个或多个字段进行 反规范化（denormalization）是有意义的。 那么，我们来回顾一下: 你可以嵌入（embed）、引用（reference）“one” side，或 “N” side，或混合使用这些技术 你可以将任意多的字段反规范化（denormalize）到 “one” side 或 “N” side 特别是反规范化，给了你很多选择: 如果一段关系中有 8 个 反规范化（denormalization）的候选字段，那么有 2 的 8 次方（1024）种不同的方法去反规范化（包括根本不去进行反规范化）。 再乘以三种不同的引用方式，你就有了 3000 多种不同的方式来建立关系模型。 你猜怎么着？ 你现在陷入了 “选择悖论” —— 因为你有很多潜在的方法来建立 one-to-N 的关系模型，你选择如何建立模型只是变得更难了。。。 Rules of Thumb: Your Guide Through the Rainbow这里有一些“经验法则”来指导你进行选择： One：首选嵌入（embedding），除非有足够的的理由不这样做 Two：需要独立访问对象是不嵌入对象的一个令人信服的理由 Three：数组不应该无限制地增长。 如果在 “many” side 有几百个以上的 documents，不要嵌入它们; 如果在 “many” side 有几千个以上的文档，不要使用一个 ObjectID 引用数组。 高基数数组是不嵌入的一个令人信服的理由 Four：不要害怕 应用程序级别的连接（application-level joins）： 如果正确地使用索引并使用 projection specifier(如第2部分所示) ，那么 应用程序级别的连接（application-level joins）几乎不会比关系数据库 的 服务器端连接（server-side joins ）更昂贵 Five：考虑反规范化时的 读/写比率。 一个大多数时候会被读取但很少更新的字段是反规范化的好候选者: 如果你对一个频繁更新的字段进行反规范化，那么查找和更新所有实例的额外工作很可能会超过你从非规范化中节省的开销 Six：如何对数据建模完全取决于特定应用程序的数据访问模式。 您希望根据应用程序查询和更新数据的方式对数据进行结构化 Your Guide To The Rainbow在 MongoDB 中建模 “One-to-N” 关系时，你有各种各样的选择，因此必须仔细考虑数据的结构。 你需要考虑的主要标准是: 这种关系的基数是什么: 是 one-to-few, one-to-many 还是 one-to-squillions？ 你需要单独访问 “N” side 的对象，还是仅在父对象的上下文中访问？ 特定字段的更新与读取的比率是多少？ 你的数据结构的主要选择是： 对于 one-to-few，可以使用嵌入文档的数组 对于 one-to-many ，或者在 “N” side 必须单独存在的情况下，应该使用一个引用数组。 如果优化了数据访问模式，还可以在 “N” side 使用 父引用（parent-reference） 对于 one-to-squillions，你应该在存储 “N” side 的文档中使用 父引用（parent-reference） 一旦你确定了数据的总体结构，那么你可以通过将数据从 “One” side 反规范化到 “N” side，或者从 “N” side 反规范化到 “One” side 来反规范化跨多个文档的数据。 只有那些经常被阅读、被阅读的频率远高于被更新的频率的字段，以及那些不需要 强一致性（strong consistency）的字段，才需要这样做，因为更新非标准化的值更慢、更昂贵，而且不是原子的。 Productivity and Flexibility因此，MongoDB 使你能设计满足应用程序的需求的数据库 Schema。 你可以在 MongoDB 中构造你的数据，让它就可以很容易地适应更改，并支持你需要的查询和更新，以便最大限度地方便你的开发应用程序。 更多资料 Schema Design Consulting Services Thinking in Documents (recorded webinar) Schema Design for Time-Series Data (recorded webinar) Socialite, the Open Source Status Feed - Storing a Social Graph (recorded webinar)","pubDate":"Wed, 04 Dec 2019 08:35:59 GMT","guid":"https://aotu.io/notes/2019/12/04/6-Rules-of-Thumb-for-MongoDB-Schema-Design/","category":"全栈开发"},{"title":"京喜首页（微信购物入口）跨端开发与优化实践","link":"https://aotu.io/notes/2019/12/03/jingxi-index/","description":"背景介绍随着今年的双十一落下帷幕，京喜（原京东拼购）也迎来了首捷。双十一前夕微信购物一级入口切换为京喜小程序，项目顺利通过近亿级的流量考验，在此与大家分享一点自己参与的工作。","pubDate":"Tue, 03 Dec 2019 11:25:00 GMT","guid":"https://aotu.io/notes/2019/12/03/jingxi-index/","category":"Web开发"},{"title":"Sketch 插件开发实践","link":"https://aotu.io/notes/2019/10/31/sketch-plugin/","description":"Sketch 是非常流行的 UI 设计工具，2014年随着 Sketch V43 版本增加 Symbols 功能、开放开发者权限，吸引了大批开发者的关注。 目前 Sketch 开发有两大热门课题：① React 组件渲染成 sketch 由 airbnb 团队发起，② 使用 skpm 构建开发 Sketch 插件。 Sketch 插件开发相关资料较少且不太完善，我们开发插件过程中可以重点参考官方文档，只是有些陈旧。官方有提供 JavaScript API 借助 CocoaScript bridge 访问内部 Sketch API 和 macOS 框架进行开发插件（Sketch 53~56 版 JS API 在 native MacOS 和 Sketch API 暴露的特殊环境中运行），提供的底层 API 功能有些薄弱，更深入的就需要了解掌握 Objective-C 、 CocoaScript 、AppKit、Sketch-Headers。 Sketch 插件结构Sketch Plugin 是一个或多个 scripts 的集合，每个 script 定义一个或多个 commands。Sketch Plugin 是以 .sketchplugin 扩展名的文件夹，包含文件和子文件夹。严格来说，Plugin 实际上是 OS X package，用作为 OS X bundle。 Bundle 具有标准化分层结构的目录，其保存可执行代码和该代码使用的资源。 Plugin Bundle 文件夹结构Bundles 包含一个 manifest.json 文件，一个或多个 scripts 文件（包含用 CocoaScript 或 JavaScript 编写的脚本），它实现了 Plugins 菜单中显示的命令，以及任意数量的共享库脚本和资源文件。 12345678910mrwalker.sketchplugin Contents/ Sketch/ manifest.json shared.js Select Circles.cocoascript Select Rectangles.cocoascript Resources/ Screenshot.png Icon.png 最关键的文件是 manifest.json 文件，提供有关插件的信息。 小贴士： Sketch 插件包可以使用 skpm 在构建过程中生成，skpm 提供 Sketch 官方插件模版: skpm/skpm - The simplest possible plugin setup. (default) skpm/with-prettier - A plugin setup featuring linting with ESLint and code formatting with Prettier. skpm/with-datasupplier - A template to create DataSupplier plugins (check our blog for more info) skpm/with-webview - A template to create plugins displaying some rich UI in a WebView (check sketch-module-web-view for more info) 💁 Tip: Any Github repo with a ‘template’ folder can be used as a custom template: skpm create &lt;project-name&gt; --template=&lt;username&gt;/&lt;repository&gt; Manifest manifest.json 文件提供有关插件的信息，例如作者，描述，图标、从何处获取最新更新、定义的命令 (commands） 、调用菜单项 (menu) 以及资源的元数据。 123456789101112131415161718192021222324252627282930313233&#123; \"name\": \"Select Shapes\", \"description\": \"Plugins to select and deselect shapes\", \"author\": \"Joe Bloggs\", \"homepage\": \"https://github.com/example/sketchplugins\", \"version\": \"1.0\", \"identifier\": \"com.example.sketch.shape-plugins\", \"appcast\": \"https://excellent.sketchplugin.com/excellent-plugin-appcast.xml\", \"compatibleVersion\": \"3\", \"bundleVersion\": 1, \"commands\": [ &#123; \"name\": \"All\", \"identifier\": \"all\", \"shortcut\": \"ctrl shift a\", \"script\": \"shared.js\", \"handler\": \"selectAll\" &#125;, &#123; \"name\": \"Circles\", \"identifier\": \"circles\", \"script\": \"Select Circles.cocoascript\" &#125;, &#123; \"name\": \"Rectangles\", \"identifier\": \"rectangles\", \"script\": \"Select Rectangles.cocoascript\" &#125; ], \"menu\": &#123; \"items\": [\"all\", \"circles\", \"rectangles\"] &#125;&#125; Commands声明一组 command 的信息，每个 command 以 Dictionary 数据结构形式存在。 script : 实现命令功能的函数所在的脚本 handler : 函数名，该函数实现命令的功能。Sketch 在调用该函数时，会传入 context 上下文参数。若未指定 handler，Sketch 会默认调用对应 script 中 onRun 函数 shortcut：命令的快捷键 name：显示在 Sketch Plugin 菜单中 identifier : 唯一标识，建议用 com.xxxx.xxx 格式，不要过长 MenuSketch 加载插件会根据指定的信息，在菜单栏中有序显示命令名。 在了解了 Sketch 插件结构之后，我们再来了解一下，sketch提供的官方 API： Actions API， Javascript API。 Sketch Actions APISketch Actions API 用于监听用户操作行为而触发事件，例如 OpenDocumen（打开文档）、CloseDocument（关闭文档）、Shutdown（关闭插件）、TextChanged（文本变化）等，具体详见官网：https://developer.sketch.com/reference/action/ register Actions manifest.json 文件，配置相应 handlers。 示例：当 OpenDocument 事件被触发时调用 onOpenDocument handler 。 1234567891011121314\"commands\" : [ ... &#123; \"script\" : \"my-action-listener.js\", \"name\" : \"My Action Listener\", \"handlers\" : &#123; \"actions\": &#123; \"OpenDocument\": \"onOpenDocument\" &#125; &#125;, \"identifier\" : \"my-action-listener-identifier\" &#125; ...], my-action-listener.js 123export function onOpenDocument(context) &#123; context.actionContext.document.showMessage('Document Opened')&#125; Action Context Action 事件触发时会将 context.actionContext 传递给相应 handler。注意有些 Action 包含两个状态begin 和 finish，例如 SelectionChanged，需分别订阅 SelectionChanged.begin 和 SelectionChanged.finish，否则会触发两次事件。 Sketch JS APISketch 插件开发大概有如下三种方式：① 纯使用 CocoaScript 脚本进行开发，② 通过 Javascript + CocoaScript 的混合开发模式， ③ 通过 AppKit + Objective-C 进行开发。Sketch 官方建议使用 JavaScript API 编写 Sketch 插件，且官方针对 Sketch Native API 封装了一套 JS API，目前还未涵盖所有场景， 若需要更丰富的底层 API 需结合 CocoaScript 进行实现。通过 JS API 可以很方便的对 Sketch 中 Document、Artboard、Group、Layer 进行相关操作以及导入导出等，可能需要考虑兼容性， JS API 原理图如下： CocoaScript CocoaScript 实现 JavaScript 运行环境到 Objective-C 运行时的桥接功能，可通过桥接器编写 JavaScript 外部脚本访问内部 Sketch API 和 macOS 框架底层丰富的 API 功能。 小贴士： Mocha 实现提供 JavaScript 运行环境到 Objective-C 运行时的桥接功能已包含在CocoaScript中。 CocoaScript 建立在 Apple 的 JavaScriptCore 之上，而 JavaScriptCore 是为 Safari 提供支持的 JavaScript 引擎，使用 CocoaScript 编写代码实际上就是在编写 JavaScript。CocoaScript 包括桥接器，可以从 JavaScript 访问 Apple 的 Cocoa 框架。 借助 CocoaScript 使用 JavaScript 调 Objective-C 语法: 方法调用用 ‘.’ 语法 Objective-C 属性设置 Getter: object.name() Setter: object.setName(&#39;Sketch&#39;)，object.name=&#39;sketch&#39; 参数都放在 ‘ ( ) ’ 里 Objective-C 中 ‘ : ‘（参数与函数名分割符） 转换为 ‘ _ ‘，最后一个下划线是可选的 返回值，JavaScript 统一用 var/const/let 设置类型 注意：详细 Objective-C to JavaScript 请参考 Mocha 文档 示例: 1234567891011121314151617181920212223// oc: MSPlugin 的接口 valueForKey:onLayer:NSString * value = [command valueForKey:kAutoresizingMask onLayer:currentLayer];// cocoascript:const value = command.valueForKey_onLayer(kAutoresizingMask, currentLayer);// oc:const app = [NSApplication sharedApplication];[app displayDialog:msg withTitle:title];// cocoascript:const app = NSApplication.sharedApplication();app.displayDialog_withTitle(msg, title)// oc:const openPanel = [NSOpenPanel openPanel][openPanel setTitle: \"Choose a location…\"][openPanel setPrompt: \"Export\"];// cocoascript:const openPanel = NSOpenPanel.openPanelopenPanel.setTitle(\"Choose a location…\")openPanel.setPrompt(\"Export\") Objective-C ClassesSketch 插件系统可以完全访问应用程序的内部结构和 macOS 中的核心框架。Sketch 是用 Objective-C 构建的，其 Objective-C 类通过 Bridge (CocoaScript/mocha) 提供 Javascript API 调用，简单的了解 Sketch 暴露的相关类以及类方法，对我们开发插件非常有帮助。 使用 Bridge 定义的一些内省方法来访问以下信息： 123456789101112131415String(context.document.class()) // MSDocumentconst mocha = context.document.class().mocha()mocha.properties() // array of MSDocument specific properties defined on a MSDocument instancemocha.propertiesWithAncestors() // array of all the properties defined on a MSDocument instancemocha.instanceMethods() // array of methods defined on a MSDocument instancemocha.instanceMethodsWithAncestors()mocha.classMethods() // array of methods defined on the MSDocument classmocha.classMethodsWithAncestors()mocha.protocols() // array of protocols the MSDocument class inherits frommocha.protocolsWithAncestors() Context当输入插件定制的命令时，Sketch 会去寻找改命令对应的实现函数， 并传入 context 变量。context包含以下变量： command: MSPluginCommand 对象，当前执行命令 document: MSDocument 对象 ，当前文档 plugin: MSPluginBundle 对象，当前的插件 bundle，包含当前运行的脚本 scriptPath: NSString 当前执行脚本的绝对路径 scriptURL: 当前执行脚本的绝对路径，跟 scriptPath 不同的是它是个 NSURL 对象 selection: 一个 NSArray 对象，包含了当前选择的所有图层。数组中的每一个元素都是 MSLayer 对象 小贴士：MS 打头类名为 Sketch 封装类如图层基类 MSLayer)、文本层基类 MSTextLayer) 、位图层基类 MSBitmapLayer，NS 打头为 AppKit 中含有的类 12345678910111213141516const app = NSApplication.sharedApplication()function initContext(context) &#123; context.document.showMessage('初始执行脚本') const doc = context.document const page = doc.currentPage() const artboards = page.artboards() const selectedArtboard = page.currentArtboard() // 当前被选择的画板 const plugin = context.plugin const command = context.command const scriptPath = context.scriptPath const scriptURL = context.scriptURL const selection = context.selection // 被选择的图层&#125; Sketch 插件开发上手前面我们了解了许多 Sketch 插件开发知识，那接下来实际上手两个小例子： ① 创建辅助内容面板窗口， ② 侧边栏导航。为了方便开发，我们在开发前需先进行如下操作： 崩溃保护 当 Sketch 运行发生崩溃，它会停用所有插件以避免循环崩溃。对于使用者，每次崩溃重启后手动在菜单栏启用所需插件非常繁琐。因此可以通过如下命令禁用该特性。 1defaults write com.bohemiancoding.sketch3 disableAutomaticSafeMode true 插件缓存 通过配置启用或禁用缓存机制： 1defaults write com.bohemiancoding.sketch3 AlwaysReloadScript -bool YES 该方法对于某些场景并不适用，如设置 COScript.currentCOScript().setShouldKeepAround(true) 区块会保持常驻在内存，那么则需要通过 coscript.setShouldKeepAround(false) 进行释放。 WebView 调试 如果插件实现方案使用 WebView 做界面，可通过以下配置开启调试功能。 1defaults write com.bohemiancoding.sketch3 WebKitDeveloperExtras -bool YES 创建辅助内容面板窗口首先我们先熟悉一下 macOS 下的辅助内容面板， 如下图最左侧 NSPanel 样例， 它是有展示区域，可设置样式效果，左上角有可操作按钮的辅助窗口。 Sketch 中要创建如下内容面板，需要使用 macOS 下 AppKit 框架中 NSPanel 类，它是 NSWindow 的子类，用于创建辅助窗口。内容面板外观样式设置，可通过 NSPanel 类相关属性进行设置， 也可通过 AppKit 的NSVisualEffectView 类添加模糊的背景效果。内容区域则可通过 AppKit 的 WKWebView 类，单开 webview 渲染网页内容展示。 创建 Panel 123456789101112131415161718192021222324const panelWidth = 80;const panelHeight = 240;// Create the panel and set its appearanceconst panel = NSPanel.alloc().init();panel.setFrame_display(NSMakeRect(0, 0, panelWidth, panelHeight), true);panel.setStyleMask(NSTexturedBackgroundWindowMask | NSTitledWindowMask | NSClosableWindowMask | NSFullSizeContentViewWindowMask);panel.setBackgroundColor(NSColor.whiteColor());// Set the panel's title and title bar appearancepanel.title = \"\";panel.titlebarAppearsTransparent = true;// Center and focus the panelpanel.center();panel.makeKeyAndOrderFront(null);panel.setLevel(NSFloatingWindowLevel);// Make the plugin's code stick around (since it's a floating panel)COScript.currentCOScript().setShouldKeepAround(true);// Hide the Minimize and Zoom buttonpanel.standardWindowButton(NSWindowMiniaturizeButton).setHidden(true);panel.standardWindowButton(NSWindowZoomButton).setHidden(true); Panel 添加模糊的背景 1234567// Create the blurred backgroundconst vibrancy = NSVisualEffectView.alloc().initWithFrame(NSMakeRect(0, 0, panelWidth, panelHeight));vibrancy.setAppearance(NSAppearance.appearanceNamed(NSAppearanceNameVibrantLight));vibrancy.setBlendingMode(NSVisualEffectBlendingModeBehindWindow);// Add it to the panelpanel.contentView().addSubview(vibrancy); Panel 插入 webview 渲染 1234567891011121314const wkwebviewConfig = WKWebViewConfiguration.alloc().init()const webView = WKWebView.alloc().initWithFrame_configuration( CGRectMake(0, 0, panelWidth, panelWidth), wkwebviewConfig)// Add it to the panelpanel.contentView().addSubview(webView);// load file URLwebview.loadFileURL_allowingReadAccessToURL( NSURL.URLWithString(url), NSURL.URLWithString('file:///')) 侧边栏导航开发我们开发复杂的 Sketch 插件，一般都要开发侧边栏导航展示插件功能按钮，点击触发相关操作。那开发侧边栏导航，我们主要使用 AppKit 中的那些类呢，有 NSStackView 、 NSBox 、NSImage、 NSImageView、NSButton 等，大致核心代码如下： 12345678910111213141516171819202122232425262728293031323334353637 // create toolbar const toolbar = NSStackView.alloc().initWithFrame(NSMakeRect(0, 0, 40, 400)) threadDictionary[SidePanelIdentifier] = toolbar toolbar.identifier = SidePanelIdentifier toolbar.setSpacing(8) toolbar.setFlipped(true) toolbar.setBackgroundColor(NSColor.windowBackgroundColor()) toolbar.orientation = 1 // add element toolbar.addView_inGravity(createImageView(NSMakeRect(0, 0, 40, 22), 'transparent', NSMakeSize(40, 22)), 1) const Logo = createImageView(NSMakeRect(0, 0, 40, 30), 'logo', NSMakeSize(40, 28)) toolbar.addSubview(Logo) const contentView = context.document.documentWindow().contentView() const stageView = contentView.subviews().objectAtIndex(0) const views = stageView.subviews() const existId = views.find(d =&gt; ''.concat(d.identifier()) === identifier) const finalViews = [] for (let i = 0; i &lt; views.count(); i++) &#123; const view = views[i] if (existId) &#123; if (''.concat(view.identifier()) !== identifier) finalViews.push(view) &#125; else &#123; finalViews.push(view) if (''.concat(view.identifier()) === 'view_canvas') &#123; finalViews.push(toolbar) &#125; &#125; &#125;// add to main Window stageView.subviews = finalViews stageView.adjustSubviews() 详细见开源代码： https://github.com/o2team/sketch-plugin-boilerplate （欢迎 star 交流） 调试当插件运行时，Sketch 将会创建一个与其关联的 JavaScript 上下文，可以使用 Safari 来调试该上下文。 在 Safari 中, 打开 Developer &gt; 你的机器名称 &gt; Automatically Show Web Inspector for JSContexts，同时启用选项 Automatically Pause Connecting to JSContext，否则检查器将在可以交互之前关闭（当脚本运行完时上下文会被销毁）。 现在就可以在代码中使用断点了，也可以在运行时检查变量的值等等。 日志JavaScriptCore 运行 Sketch 插件的环境 也有提供类似调试 JavaScript 代码打 log 的方式，我们可以在关键步骤处放入一堆 console.log/console.error 等进行落点日志查看。 有以下几种选择可以查看日志： 打开 Console.app 并查找 Sketch 日志 查看 ~/Library/Logs/com.bohemiancoding.sketch3/Plugin Output.log 文件 运行 skpm log 命令，该命令可以输出上面的文件（执行 skpm log -f 可以流式地输出日志） 使用 skpm 开发的插件，安装 sketch-dev-tools，使用 console.log 打日志查看。 SketchToolSketchTool 包含在 Sketch 中的 CLI 工具，通过 SketchTool 可对 Sketch 文档执行相关操作： 导出 artboards、layers、slices、pages、交互稿 检查 Sketch 文档 导出 Sketch 文档 JSON data Run plugins sketchtool 二进制文件位于 Sketch 应用程序包中： 1Sketch.app/Contents/Resources/sketchtool/bin/sketchtool 设置 alias ： 1alias sketchtool=\"/Applications/Sketch.app/Contents/Resources/sketchtool/bin/sketchtool\" 使用： 12345sketchtool -h # 查看帮助sketchtool export artboards path/to/document.sketch # 导出画板sketchtool dump path/to/document.sketch # 导出 Sketch 文档 JSON datasketchtool metadata path/to/document.sketch # 查看 Sketch 文档元数据sketchtool run [Plugin path] # 运行插件 注意：SketchTool 需要 OSX 10.11或更高版本。 Other Resourcessketch Plugin 开发官方文档 sketch插件开发中文文档 sketch 使用文档 sketch-utils sketch reference api Github SketchAPI react-sketchapp Sketch-Plugins-Cookbook iOS开发60分钟入门 AppKit, 构建 Sketch 的一个主要 Apple 框架 Foundation(基础), 更重要的 Apple 课程和服务 Chromeless-window","pubDate":"Thu, 31 Oct 2019 07:30:00 GMT","guid":"https://aotu.io/notes/2019/10/31/sketch-plugin/","category":"Web开发"},{"title":"2019年，你是否可以抛弃 CSS 预处理器？","link":"https://aotu.io/notes/2019/10/29/css-preprocessor/","description":"随着前端工程化的不断完善，CSS 预处理器已经成为项目中不可缺少的部分，很多人在项目技术选型阶段就会先选择一个 CSS 预处理器，绝大部分前端工程的脚手架也内置了一系列的 CSS 预处理的模版，大家已经习惯了享受 CSS 预处理器带来的书写代码的灵活流畅，反而将原生的 CSS 冷落在一旁。 可能许多前端开发人员依然觉得 CSS 预处理器属于比较新的技术，其实不然，最早的 CSS 预处理器 Sass 从 07 年诞生距今已有 12 年，相对较新的的 Stylus 也已发布 9 年了。 前端的技术栈发展突飞猛进，W3C 的 CSS 工作组也一直在持续从社区汲取营养，加快 CSS 的迭代。那么到现在为止，CSS 是否可以取代 CSS 预处理器的地位？CSS 预处理器会不会成为 CSS 过渡时期的产物呢？ W3C 介绍CSS 是开放网络的核心语言之一，由 W3C 规范 实现跨浏览器的标准化。因此，在深入了解 CSS 规范更新进度之前，我们有必要先了解一下 W3C 及其规范制定流程。 W3C 也就是万维网联盟（World Wide Web Consortium），又称 W3C 理事会，是万维网的主要国际标准组织。为半自治非政府组织（quasi-autonomous non-governmental organisation）。由 蒂姆·伯纳斯-李（Tim Berners-Lee）于 1994年10月 于麻省理工学院 MIT 计算机科学与人工智能实验室（MIT／LCS）创立。 W3C 制定了一系列标准并督促网络应用开发者和内容提供者遵循这些标准。标准的内容包括使用语言的规范，开发中使用的导则和解释引擎的行为等等。W3C制定了包括 HTML、DOM、SVG、XML和 CSS 等的众多影响深远的标准规范。 W3C 规范制定流程因为接下来我们需要谈到一些不同阶段的 CSS 规范，因此这里有必要简单介绍一下 W3C 的规范制定流程。 按照 W3C 的 Process Document，一个推荐标准的发展需要通过不同的阶段。 其中几个主要的阶段分别为： WD 工作草案（Working draft） CR 候选推荐标准（Candidate recommendation） PR 提案推荐标准（recommendation） REC W3C推荐标准（W3C recommendation） 篇幅有限，这里就不详细展开讲解 W3C 的标准流程了，如果想了解更多关于 W3C 标准流程与组织架构 的信息，可以查看W3C标准流程与组织架构。 CSS 的历史HTML 和 CSS 是那么密不可分，以至于你可能会觉得它们是一起出现的。实际上，自 1989 年 Tim Berners Lie 发明互联网后的多年中，这个世界上都不存在一个名为 CSS 的事物（更别说 CSS 预处理器了），Web 的原始版本根本就没有提供一种装饰网页的方法。 HTML 规范虽然规定了网页中的标题、段落应该使用的标签，但是没有涉及这些内容应该以何种样式(比如大小、位置、间距、缩进等属性)呈现在浏览器中。 不过，在随后仅短短10年后，CSS就被一个现代的 Web 社区全面采用，这期间的发生了一系列有趣的故事，有兴趣的可以看一下 A Look Back at the History of CSS。 CSS1于1994年，Håkon Wium Lie (哈肯·维姆·莱) 和 Bert Bos (伯特·波斯) 合作设计CSS。他们在1994年首次在芝加哥的一次会议上第一次展示了CSS的建议。 1996年12月 发表的 CSS1 的要求有第一版主要规定了选择器、样式属性、伪类 、对象几个大的部分。 CSS2CSS2 在 1998 年 5月 由 W3C 发布，CSS2 规范是基于 CSS1 设计的，扩充和改进了很多更加强大的属性。包括选择器、位置模型、布局、表格样式、媒体类型、伪类、光标样式。 Cascading Style Sheets Level 2 Revision 1，通常被称为“ CSS 2.1” ，修复了 CSS 2中的错误，删除了支持不良或不能完全互操作的特性，并为规范增加了已经实现的浏览器扩展。 为了遵守 W3C 标准化技术规范的过程，CSS 2.1 在 Working Draft (WD) 状态和 Candidate Recommendation (CP) 状态之间来回了很多年。 CSS 2.1于 2004 年 2 月 25 日首次成为 Candidate Recommendation (CR)标准，但在 2005 年 6 月 13 日又回到 Working Draft (WD) 中进行进一步审查。 它于 2007 年 7 月 19 日回到 Candidate Recommendation (CP) 标准，然后在 2009 年更新了两次。 然而，由于作出了修改和澄清，它再次回到了2010年12月7日的 Last Call Working Draft 。 CSS3CSS3 是层叠样式表（Cascading Style Sheets）语言的最新版本，旨在扩展CSS2.1。 CSS Level 2 经历了 9 年的时间（从 2002 年 8 月到 2011 年 6 月）才达到 Recommendation（推荐） 状态，主要原因是被一些次要特性拖了后腿。为了加快那些已经确认没有问题的特性的标准化速度，W3C 的 CSS Working Group 作出了一项被称为 Beijing doctrine 的决定，将 CSS 划分为许多小组件，称之为模块。这些模块彼此独立，按照各自的进度来进行标准化。其中一些已经是 W3C Recommendation 状态，也有一些仍是 Early Working Drafts（早期工作草案）。当新的需求被肯定后， 新的模块也会同样地添加进来。 从形式上来说，CSS3 标准自身已经不存在了。每个模块都被独立的标准化，现在标准 CSS 包括了修订后的 CSS2.1 以及完整模块对它的扩充，模块的 level（级别）数并不一致。可以在每个时间点上为 CSS 标准定义一个 snapshots（快照），列出 CSS 2.1 和成熟的模块。 W3C 会定期的发布这些 snapshots，如 2007, 2010, 2015 或 2017。 目前为止，还没有 level 超过 3 的模块被标准化，未来应该会有所改变。 不过有些模块，比如 Selectors（选择器）4 或 CSS Borders and Backgrounds（边框和背景）Level 4 早已拥有了 Editor’s Draft（编辑草案），即使它们还没达到 First Published Working Draft（初次发布工作草案）状态。 有一张图可以更加直观的表示当前 CSS3 Modules 的分类和状态： 问题：为什么没有 CSS4？There is no single, integrated CSS4 specification, because it is split into separate “level 4” modules.Level 4 不等于 CSS 4 ，如 CSS Custom Properties for Cascading Variables Module Level 1 总不能说它是 CSS1 吧。 CSS 预处理器CSS 自诞生以来，基本语法和核心机制一直没有本质上的变化，在很长一段时间内，它的发展几乎全是表现力层面上的提升。 最开始 CSS 在网页中的作用只是辅助性的装饰，轻便易学是最大的需求；然而如今网站的复杂度已经不可同日而语，原生 CSS 已经让开发者力不从心。 当一门语言的能力不足而用户的运行环境又不支持其它选择的时候，这门语言就会沦为 “编译目标” 语言。开发者将选择另一门更高级的语言来进行开发，然后编译到底层语言以便实际运行。于是，在前端领域，天降大任于斯人也，CSS 预处理器应运而生。 百花齐放CSS 预处理器是一个能让你通过预处理器自己独有的语法来生成 CSS 的程序。 市面上有很多 CSS 预处理器可供选择，且绝大多数 CSS 预处理器会增加一些原生 CSS 不具备或不完善的高级特性，这些特性让 CSS 的结构更加具有可读性且易于维护。当前社区代表的 CSS 预处理器 主要有一下几种： Sass：2007 年诞生，最早也是最成熟的 CSS 预处理器，拥有 Ruby 社区的支持和 Compass 这一最强大的 CSS 框架，目前受 LESS 影响，已经进化到了全面兼容 CSS 的 SCSS。 Less：2009年出现，受 SASS 的影响较大，但又使用 CSS 的语法，让大部分开发者和设计师更容易上手，在 Ruby 社区之外支持者远超过 SASS，其缺点是比起 SASS 来，可编程功能不够，不过优点是简单和兼容 CSS，反过来也影响了 SASS 演变到了 SCSS 的时代，著名的 Twitter Bootstrap 就是采用 LESS 做底层语言的。 Stylus：Stylus 是一个CSS的预处理框架，2010 年产生，来自 Node.js 社区，主要用来给 Node 项目进行 CSS 预处理支持，所以 Stylus 是一种新型语言，可以创建健壮的、动态的、富有表现力的 CSS。比较年轻，其本质上做的事情与 SASS/LESS 等类似， 优点虽然各种预处理器功能强大，但使用最多的，还是以下特性：变量（variables），代码混合（ mixins），嵌套（nested rules）以及 代码模块化(Modules)。 接下来以 Sass 为例，展示一下这几个主要特性在预处理器中的实现： Variables and Operators (+, -, *, /, %)12345678910$font-size: 10px;$font-family: Helvetica, sans-serif;body &#123; font: $font-size $font-family;&#125;.mark&#123; font-size: 1.5 * $font-size;&#125; Mixins1234567891011@mixin clearfix &#123; &amp;:after &#123; display: block; content: &apos;&apos;; clear: both; &#125;&#125;.sidebar&#123; @include clearfix;&#125; Nesting12345678// menu.nav &#123; &gt; li &#123; &gt; a:hover &#123; background-color: red; &#125; &#125;&#125; Modules1234@import './common';@import './github-markdown';@import './mixin';@import './variables'; 缺点或不足额外的编译配置在写样式前需要做一些额外的编译配置工作，sass-node 安装以及编译的配置就能卡住一批前端新手。 编译成本每次修改代码都需要重新编译,占用时间和 CPU。 学习成本不同的 CSS 预处理器语法不同，增加学习成本。在同一个团队甚至项目里，可能同时使用了好几种样式预处理器。 123456789101112131415// Sass$color: #f00;$images: &quot;../img&quot;;@mixin clearfix &#123; &amp;:after &#123; content: &quot; &quot;; display: block; clear: both; &#125;&#125;body &#123; color: $color; background: url(&quot;#&#123;images&#125;/1.png&quot;); @include clearfix;&#125; 123456789101112131415// Less@color: #f00;@images: \"../img\";.clearfix() &#123; &amp;:after &#123; content: \" \"; display: block; clear: both; &#125;&#125;body &#123; color: @color; background: url(\"@&#123;images&#125;/1.png\"); .clearfix;&#125; 调试在使用 CSS 预处理器时，我们通常会配置 SourceMap 来辅助调试，但即使这样，还是会碰到一些调试困难的情况： 回归 CSS各种 CSS 预处理器在更新迭代的过程中，功能越来越繁杂花哨，但是绝大部分人用到的核心功能还是那几样：Variables、Mixing、Nested、Module，顶多再加上一些工具类函数。 我们既想要想要预处理器的优点，又不想要它带来的成本和缺点，有没有两全其美的办法？CSS 这么多年一直也在从社区汲取养分加速进化和迭代，我们能不能从 CSS 标准里面找到答案呢？ Variables in CSSCSS 自定义属性（CSS Custom Properties)，又叫 CSS 变量（CSS Variable）,允许你自己在样式中声明变量，并通过 var() 函数使用。 CSS Custom Properties for Cascading Variables 规范在 2012 年 10 月首次作为 工作草案（WD） 提出，并在 2015 年 10 月到达 候选人推荐标准（CR）阶段。现在浏览器支持程度已经接近 93%。 CSS 变量定义及使用如下所示，可定义的类型极其丰富。 12345678910111213141516171819202122232425/* declaration */--VAR_NAME: &lt;declaration-value&gt;;/* usage */var(--VAR_NAME)/* root element selector (global scope), e.g. &lt;html&gt; */:root &#123; /* CSS variables declarations */ --main-color: #ff00ff; --main-bg: rgb(200, 255, 255); --logo-border-color: rebeccapurple; --header-height: 68px; --content-padding: 10px 20px; --base-line-height: 1.428571429; --transition-duration: .35s; --external-link: \"external link\"; --margin-top: calc(2vh + 20px);&#125;body &#123; /* use the variable */ color: var(--main-color);&#125; 不同于 SASS 预处理器变量的编译时处理，CSS 变量是浏览器在运行时进行处理的，因此 CSS 变量会更加强大和灵活。 Operators可以使用 calc() 进行计算 12345678:root &#123; --block-font-size: 1rem;&#125;.block__highlight &#123; /* WORKS */ font-size: calc(var(--block-font-size)*1.5);&#125; Generate Colors可以用于通过 RGB 等函数生成和计算颜色：Generate Colors CSS to JSCSS 变量出现前，从 CSS 传值给 JS 非常困难，甚至需要借助一些 Hack 的手法。现在使用 CSS 变量，你可以直接通过 JS 获取变量值并进行修改： 1234.breakpoints-data &#123; --phone: 480px; --tablet: 800px;&#125; 123456789const breakpointsData = document.querySelector('.breakpoints-data');// GETconst phone = getComputedStyle(breakpointsData) .getPropertyValue('--phone');// SETbreakpointsData.style .setProperty('--phone', 'custom'); Custom Theme使用 CSS 变量，定制和动态切换网站主题非常简单方便： 首先定义好不同主题下的变量，然后正常书写样式即可。 123456789html &#123; --hue: 210; /* Blue */ --text-color-normal: hsl(var(--hue), 77%, 17%); ...&#125;html[data-theme='dark'] &#123; --text-color-normal: hsl(var(--hue), 10%, 62%); ...&#125; 通过 JS 改变元素属性，动态切换主题： 12document.documentElement.setAttribute('data-theme', 'dark')document.documentElement.setAttribute('data-theme', 'light') 更多高级用法可以参考：CSS custom properties (native variables) In-Depth 为什么变量的定义以 --开头？原因在这里：Let’s Talk about CSS Variables Mixins in CSSCSS 的有一个提案：CSS @apply Rule，按照该草案描述，用户可直接使用 CSS 变量存放声明块，然后通过 @apply rule 使用。 12345678910:root &#123; --pink-schema: &#123; color: #6A8759; background-color: #F64778; &#125;&#125;body&#123; @apply --pink-schema;&#125; 可惜这个提案已被废弃，具体废弃原因感兴趣的可以看看这篇文章：Why I Abandoned @apply。 尽管 Mixins 现在 CSS 还没有好的实现标准，但我们坚信迟早会有更优秀的规范涌现出来弥补 CSS 的这一块空白。 Nesting in CSSCSS 里已经有 Nesting 的规范出现，尽管现在只处于 Editor’s Draft 阶段：CSS Nesting Module Level 3 可以看到按照 CSS Nesting Module ，Nesting 规范基本和预处理器一模一样。 123456789101112131415/* Dropdown menu on hover */ul &#123; /* direct nesting (&amp; MUST be the first part of selector)*/ &amp; &gt; li &#123; color: #000; &amp; &gt; ul &#123; display: none; &#125; &amp;:hover &#123; color: #f00; &amp; &gt; ul &#123; display: block; &#125; &#125; &#125;&#125; Module in CSS其实 CSS 很早就有了模块化方案，那就是 @import，使用 CSS 的 @import 规则，可以引用其他的文件样式。这个特性从 IE 5.5 开始就被所有的浏览器支持，那为什么一直以来使用者寥寥无几呢，原因很多： 在一些老的浏览器有加载顺序的 bug 无法并行加载 导致过多的请求数量 …… 不过现在大家的前端项目基本都会使用构建工具（Gulp、Webpack 等）打包后再上线，因此以上哪些缺点也就不存在了，而在 Webpack 的 css-loader 中，是可以配置是否开启 @import 的。 Selector Helpers除了上面介绍的一些主要特性，CSS 还提供了一些全新的特性来帮助你更优雅的书写样式。 :matches pseudo-class 已更名为 :is() :matches() CSS 伪类 函数将选择器列表作为参数，并选择该列表中任意一个选择器可以选择的元素，这对于以更紧凑的形式编写大型选择器非常有用，而且浏览器支持程度也已经接近 93%。 12/* 语法 */:matches( selector[, selector]* ) 1234567891011.nav:matches(.side,.top) .links:matches(:hover, :focus) &#123; color: #BADA55;&#125;/* 相当于以下代码 */.nav.side .links:hover,.nav.top .links:hover,.nav.side .links:focus,.nav.top .links:focus &#123; color: #BADA55;&#125; 想要了解更多详情可以查看规范：Selectors Level 4 @custom-selector同时，你还可以您可以使用自定义选择器来定义可以匹配复杂选择器的别名。 12/* 语法 */@custom-selector: &lt;custom-selector&gt; &lt;selector-list&gt;; 定义的方式和 CSS 变量类似，使用起来稍微有点区别。 123456789101112131415@custom-selector :--text-inputs input[type=\"text\"],input[type=\"password\"];:--text-inputs.disabled,:--text-inputs[disabled] &#123; opacity: 0.5&#125;/* 相当于以下代码 */input[type=\"text\"].disabled,input[type=\"password\"].disabled,input[type=\"text\"][disabled],input[type=\"password\"][disabled] &#123; opacity: 0.5&#125; 用起来尽管上述的 CSS 特性还处于不同阶段，浏览器的支持程度也不尽相同，但是使用 postcss-preset-env，你就可以抢先尝试 CSS 的最新特性。 当然，postcss-preset-env 的配置也十分简单，以 Webpack 为例： 12345678910111213rules: [ &#123; test: /\\.css$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; importLoaders: 1 &#125; &#125;, &#123; loader: 'postcss-loader', options: &#123; ident: 'postcss', plugins: () =&gt; [ postcssPresetEnv(/* pluginOptions */) ] &#125; &#125; ] 总结经过一番梳理，我们发现，尽管 CSS 在社区的刺激下加快了更新迭代的速度，但是到目前为止，依然达不到 CSS 预处理器 VS CSS 的地步，只能说在使用 CSS 预处理器的同时，也可以在项目中尝试一些优秀的 CSS 新特性，即：CSS 预处理器 + CSS。 但是我们依然坚信，在 W3C 的推动下，随着 CSS 自身不断完善，CSS 预处理器终究会像当年的 CoffeScript 、Jade 一样，变成时代的过渡产物。到那时候，大家也就不用纠结各种 CSS 预处理器的环境配置和技术选型等，直接打开编辑器，就能愉快的书写样式。 参考 You might not need a CSS preprocessor CSS3 Modules and the standardization process How to Read W3C Specs Wikipedia - Cascading Style Sheets CSS Custom Properties for Cascading Variables Module Level 1","pubDate":"Tue, 29 Oct 2019 10:00:00 GMT","guid":"https://aotu.io/notes/2019/10/29/css-preprocessor/","category":"Web开发"},{"title":"Mongoose-modified-at 时间自动记录插件介绍","link":"https://aotu.io/notes/2019/10/28/modified-at/","description":"Mongoose-modified-at 是一款自动更新字段变化时间并记录到数据库中的 Mongoose 插件，类似 Mongoose 自带的 timestamps 功能。 使用场景让我们考虑一个场景，我们有个文章发布与展示的需求，数据模型如下。 123456789const schema = new mongoose.Schema(&#123; // 文章标题 title: String, // 是否为草稿 is_draft: Boolean, // 是否推荐 is_recommended: Boolean, // 更多字段...&#125;) 当我们在展示最新文章列表时，应该是以文章第一次发布的时间倒序展示，因为文章可以存为草稿，多次编辑，所以不能用 Mongoose 提供的 createdAt 或 updatedAt 作为第一次发布的时间，正确的做法是在每次文章创建或更新时，确定用户是发布文章而不是存为草稿，然后记录此次时间，用该时间作为第一次发布的时间。 要实现该功能我们需要在代码逻辑层进行处理，这样可行不过有点耦合，或者自己封装一个 Mongoose 中间件来做这件事，不过现在你可以把这件事交给一个经受测试、API 优雅的插件 ModifiedAt 来处理。 首先安装插件。 1npm install mongoose-modified-at --save 然后在 Schema 初始化时做简单的配置即可，如下。 12345678910111213141516import modifiedAt from 'mongoose-modified-at'// 在 mongoose.model 调用之前schema.plugin(modifiedAt, &#123; // 函数名将作为字段名写入数据库 publishedAt(doc) &#123; // 当函数返回值为 true 时，则记录该时间 return !doc.is_draft &#125;, // 推荐文章也是如此 recommendedAt(doc) &#123; return doc.is_recommended &#125;,&#125;)const Article = mongoose.model('Article', schema) 当文档保存或更新携带着 is_draft 字段并且值为 false 时，插件就会记录此次时间到你声明的 publishedAt 字段上一起写入数据库。 示例如下： 123456await Article.create(&#123; title: 'Document Title', is_draft: false, is_recommended: true, // 更多字段...&#125;) 结果如下（数据库）： 12345678&#123; \"title\": \"Document Title\", \"is_draft\": false, \"is_recommended\": true, \"publishedAt\": ISODate(\"2019-09-27T03:11:07.880Z\"), \"recommendedAt\": ISODate(\"2019-09-27T03:11:07.880Z\"), // 更多字段...&#125; 附加案例作为渐进式项目，我们的开发一般也是渐进式的，虽然我们会不自觉地超前考虑，但是还是不能完全考虑到未来需求的变化，假如我们对某个项目的功能已经完成并稳定上线了，后来比如我们需要做数据统计分析的工作，这项工作的分析维度对时间的精度要求比较高，所以要是我们在开发时并没有考虑到要添加这些时间字段（因为可能对业务不是必须的），而现在需要加上这些字段，要是去原来的代码基础上改动添加，如果改动的地方少还好，如果有完善的测试用例还好，否则这也许会改的心惊胆战，因为你需要确保每一处改动不会产生错误影响。所以此时，使用无侵入式的中间件插件 ModifiedAt 那就省心很多了，只需在模型出口简单配置，无需改动逻辑层代码，即可实现刚刚想要的功能。 API介绍上面是 ModifiedAt 的富 API 形式，即对象格式，全部参数选项如下。 123456789101112schema.plugin(modifiedAt, &#123; // 设置监听字段 fields: ['name', 'status', 'another'], // 设置后缀 suffix: '_your_suffix', // 设置路径默认行为 select: true, // 自定义字段 customField(doc) &#123; // 做一些你想做的事，然后返回 Boolean 值，告诉插件是否记录时间 &#125;,&#125;) 🍎 参数解释： fields: 设置监听字段，在文档创建或更新时，如果存在被监听的字段，则自动以 字段名 + 后缀 的形式作为字段，并记录此次更新时间到该字段上。可选，Array 类型。 suffix: 设置后缀，默认值为 _modifiedAt。可选，String 类型。 select: 设置路径默认行为，默认为 true ，参考 Mongoose 文档。可选，Boolean 类型。 customField: 自定义字段，此字段不会加后缀，以函数形式添加到参数中，用于自定义功能，函数接收唯一文档参数，当函数返回值为真值时，则记录此次时间到该字段上。 简化API🚀 为了增加 API 的简洁易用同时避免过度重载，ModifiedAt 只增加了一种简化传参格式，如下。 1schema.plugin(modifiedAt, ['name', 'status']) 意思是将 fields 选项提取出来作为参数，写入数据库的结果如下。 123456&#123; \"name\": \"Tom\", \"status\": 1, \"name_modifiedAt\": ISODate(\"2019-09-27T03:13:17.888Z\"), \"status_modifiedAt\": ISODate(\"2019-09-27T03:13:17.888Z\"),&#125; 支持异步你需要 Node.js 版本支持 async/await 即可。 12345678910111213141516171819202122import P from 'bluebird'const petSchema = new mongoose.Schema(&#123; name: String, age: Number, sex: String, // 1：表示采购中，2：已购买，3：已售出 status: Number,&#125;)petSchema.plugin(modifiedAt, &#123; // 记录购买于哪时 async boughtAt(doc) &#123; // 延时 1s await P.delay(1000) return doc.status === 2 &#125;, // 记录售出于哪时 soldAt(doc) &#123; return doc.status === 3 &#125;,&#125;) 支持 Mongoose 4.x如果你现在使用的是 Mongoose 4.x，那么你需要使用插件 1.x 版本，文档可在这里查看。 1npm install mongoose-modified-at@1 --save “100%”测试覆盖率29 个测试用例，777 行测试代码，“100%” 测试覆盖率。 细节更多细节处理请移步至 GitHub 文档，这里。 最后本插件在京东智能设计项目 - 羚珑中实际应用，ling.jd.com 欢迎体验 😘。","pubDate":"Mon, 28 Oct 2019 02:00:00 GMT","guid":"https://aotu.io/notes/2019/10/28/modified-at/","category":"NodeJS"},{"title":"Taro 邀你加入社区共建 — 社区共建倡议书","link":"https://aotu.io/notes/2019/10/24/taro-open/","description":"Taro 作为一个多端统一开发解决方案，自诞生以来一直保持着高速的发展态势， 从一个单一的开发框架发展到如今服务数万名开发者的多端解决方案，Taro 的成长有 Taro 团队不忘初心的努力，但更重要的是，离不开社区广大开发者的支持和帮助。 开源面临着什么我们可以先来看一组数据。 Taro 从开源到当前行文为止，统共有 5227 次 commits，发布了 235 个版本，同时有 3908 个 issues 被开启，在 Taro 团队和社区的努力下，已经关闭了 3296 个，还有近 600 个 issues 有待解决，而每周 Taro 的新开启的 issues 也在 50 个左右；同时也收获了 709 个 PR，合入了 656 个。 除此之外，Taro 交流社区 发帖数也达到 3000 个，每周以 200 个左右的增速在增加，而 Taro 官方文档 作为 Taro 入门及开发必备的资源，每周的访问量达到了 20w。 同时 Taro 还有 20 余 个 500 人左右的开发者交流微信群，以及 10 余个跟各小程序官方团队、各大公司研发团队的研讨群，每天 Taro 团队的开发人员都要遭受大规模的信息轰炸。 由此可见，Taro 目前拥有庞大且活跃的开发者社区，每天都会产生大量的信息，或是问题，或是建议，或是代码提交，或是有用的轮子。当社区变得越来越大后，如何进行有效的管理，提升社区整体的使用体验，便成了困扰 Taro 团队的问题，迫切需要在方案迭代与社区维护之间寻找到一个平衡点，以使 Taro 可以走得更远，发展得更好。 来自社区的力量正所谓「单丝不成线，独木不成林」。 Taro 发展至今早已不在属于单一团队的项目了，而是整个 Taro 开发社区共同的项目。在 Taro 所属的 NervJS 组织的成员 中也已经加入了像华为、腾讯等其他公司的研发人员，共同建设项目，而整个社区的贡献者也达到了 230 位。 而在所有的社区贡献中，需要特别感谢： Tom Huang ，独立为 Taro 开发所有端的 MobX 支持 jsNewbee，为 Taro 贡献了一个完整支持 小程序 + H5 + React Native 的多端样例 Chunlin，来自华为，为 Taro 完善了快应用的转换支持 同时也感谢受邀成为 TaroUI 核心维护人员的 Garfield550 (小姐姐)、梁音、ShaoQian Liu，他们将支撑起 TaroUI 的后续迭代与维护。 当然还有在社区中乐于助人、积极贡献的 zacksleo 、Jay Fong、loveonelong、lolipop99、波仔糕、原罪、lentoo 、白领夏公子 、YuanQuan、 tourze、 lingxiaoZhu 等等。 此外，还要感谢一直默默为 Taro 发展提供宝贵建议的研发团队：腾讯云、数字广东、腾讯CDC、网易严选、华为开源团队、招联消费金融等等 社区的力量一直在支撑 Taro 前进。 所以，如今 Taro 面临的社区维护问题我们希望可以交给社区来进行自我管理。 期待你的加入为了能够让社区更加高效、健康的运转下去，Taro 官方团队希望能够从社区中吸引开发者来共同维护，进行社区共建。 社区共建本次拟开放三大类角色，Taro 团队会为每一类角色设定一定门槛以及激励机制，从而保证整体质量。 能力完善 头衔 准入机制 权益 认证开发者 1. 为 Taro 实现过独立功能特性 2. 代码 commit 数及代码贡献量达到一定标准 1. 获取 Taro 项目 developer 权限 2. 来自 Taro 团队定期礼品与开源认证证书 3. Readme 及官网、文档展示 代码贡献者 为 Taro 提交过 PR Readme 及官网、文档展示 社区管理 头衔 准入机制 权益 职责 社区版主 1. 通过社区报名，遴选后产生 2. 通过考察在 Taro 社区的活跃程度，由 Taro 团队进行定向邀请 1. Readme 及官网、文档展示 2. 所提出特性会优先考虑在 Taro 版本中加入 3. 来自 Taro 团队定期礼品与开源认证证书 1. 负责社区各版块的管理2. 定期发布版块相关主题帖 3. 定期收集版块问题帖子，进行汇总，反馈给 Taro 团队 4. 对版块内帖子进行审核，剔除无用、违反法律等帖子 GitHub Issues 管理员 1. 通过社区报名，遴选后产生 2. 通过考察在 Taro 社区的活跃程度，由 Taro 团队进行定向邀请 1. Readme 及官网、文档展示 2. 所提出特性会优先考虑在 Taro 版本中加入 3. 来自 Taro 团队定期礼品与开源认证证书 4. 参与 GitHub robot 完善 1. 负责对 GitHub issues 答疑解惑以及打标分类 2. 负责每周汇总 issues，并将 issues 提交到 Taro 团队 3. 负责每周精选 issues，并将数据同步到 Taro 社区 交流群管理员 1. 通过社区报名，遴选后产生 2. 通过考察在 Taro 社区的活跃程度，由 Taro 团队进行定向邀请 1. Readme 及官网、文档展示 2. 所提出特性会优先考虑在 Taro 版本中加入 3. 来自 Taro 团队定期礼品与开源认证证书 4. 参与 群小助手 完善 1. 负责群内内容的管理，创造良好的沟通交流环境 2. 负责群内问题的答疑解惑，引导开发者去社区、GitHub issues 获取答案 3. 负责操作社区群管理工具，整理群内问题，同步到 Taro 社区 知识构建 形式 提交方式 权益 Taro 课程视频录制 通过邮箱发送个人信息及试讲视频邮箱：taro@jd.com内容：1. 个人信息：主攻技术方向、从业经历、公开分享经验等 2. 试讲视频链接通过遴选后，Taro 团队会与你联系沟通后续的视频录制事宜 成为 Taro 官方合作伙伴，视频课程经由 Taro 团队审核后，Taro 团队会全力协助进行运营推广 Taro 开发实践文章撰写 通过邮箱投稿邮箱：taro@jd.com内容：1. md 文件（若为系列文章请添加大纲） 2. 是否在 Taro 渠道首发通过遴选后，Taro 团队会与你联系沟通后续发布事宜 成为 Taro 官方合作伙伴，文章经由 Taro 团队审核后，会通过 Taro 相关优质渠道进行发布 写在最后Taro 作为一个多端开发解决方案，还处在初级的发展阶段，是一个发展中的方案，在不久的未来我们会有更多新的功能、特性推向开发者，甚至可能也有颠覆性的东西出现，让 Taro 成为一个更棒的方案。目前 Taro 已经翻过了一座座发展的山峰，但他正在向更高山峰迈进。 长风破浪会有时，直挂云帆济沧海。 Taro 诚邀你的加入联系邮箱：taro@jd.com邮件标题：【共建】+ 你想说的话 加入 Taro 微信群？加「 Taro小助手」（微信号: jdtester）回复 taro 即可。","pubDate":"Thu, 24 Oct 2019 03:30:00 GMT","guid":"https://aotu.io/notes/2019/10/24/taro-open/","category":"移动开发"},{"title":"玩转 Taro 跨端之 flex 布局篇","link":"https://aotu.io/notes/2019/09/25/taro-flex/","description":"玩转 Taro 跨端之 flex 布局篇，带你了解 flex 布局在各小程序端的表现详情并给出最佳实践 demo 玩转Taro跨端之flex布局篇Taro 是一套遵循 React 语法规范的跨平台开发解决方案，但是目前当我们使用 Taro 的时候，在不同平台上的开发体验还有不一致的地方，所以我们也都期待有一套跨平台统一的解决方案，能够以最小差异的方式向开发者提供更好的开发体验。 在跨平台开发的过程中，不同平台之间的差异尤其体现在样式的统一上，由于不同平台对样式的支持程度并不一致，Taro 很难能够通过编译的手段来对跨平台样式进行统一，所以，我们需要一个支持跨平台的解决方案来对样式进行统一。 跨平台样式考虑页面布局和样式 H5 是最为灵活的，小程序次之，React Native 和快应用最弱，统一跨平台样式应当优先对齐短板，也就是要以 React Native 和快应用的约束来管理样式，同时兼顾小程序的限制，而 Flexbox 就是一个很好的解决方案。 在构建页面的时候，我们可以通过 Flexbox 高效地完成页面代码，虽然并不是所有属性都可以全平台适应的，但是它在全平台都能够得到足够的支持，而且所有平台可以很容易通过它来绘制通用性很高的页面，这也就是为什么我们选择使用 Flexbox 方案来完成这个跨平台演示项目。 预览地址 Flexbox 布局 (Flexible Box Layout)Flexbox 是弹性布局模块(CSS Flexible Box Layout Module)常用的简称，是一种用于在单个维度中显示项目行或列的布局模型。在规范中， Flexbox 被描述为用户界面设计的布局模型。 Flexbox 的关键特性是 flex 布局中的项目可以增长和缩小。可以将空间分配给项目本身，或者在项目之间或周围分配空间。 在 Flexbox 中，采用 flex 布局 的元素，称为 flex 容器(flex container)， flex 容器所有的子元素自动成为容器成员，称为 flex 元素(flex item)。Flex 容器 默认存在两根轴：水平的主轴(main-axis)和垂直的交叉轴(cross-axis)。flex 元素 默认沿主轴排列。主轴的开始位置(与边框的交叉点)叫做 main-start ，结束位置叫做 main end ;交叉轴的开始位置叫做 cross-start ，结束位置叫做 cross-end ;单个项目占据的主轴空间叫做 main-size ，占据的交叉轴空间叫做 cross-size 。 Flexbox 可以对齐主轴或横轴上的项目，从而提供对一组项目的大小和对齐的高级控制，大多数场景下，使用 flex-direction、align-items 和 justify-content 三个样式属性就已经能满足大多数布局需求，换而言之如果熟悉 Flexbox 就可以应对大多数场景下的布局需求。 注意，设为 Flex 布局以后，子元素的 float 、 clear 和 vertical-align 属性将失效。 Flex Container 属性在规范中， Flex Container 上，一共有七个属性可以设置，但是 flex-flow 在 React Native 上是不支持的。 flex-directionflex-direction 属性指定了flex 元素是如何在 flex 容器中布局的，定义了主轴的方向(正方向或反方向)。 支持的值如下：|值|意义||–|–||row|flex 容器的主轴被定义为与文本方向相同。 主轴起点和主轴终点与内容方向相同。||row-reverse|表现和 row 相同，但是置换了主轴起点和主轴终点。||column|flex 容器的主轴和块轴相同。主轴起点与主轴终点和书写模式的前后点相同。||column-reverse|表现和 column 相同，但是置换了主轴起点和主轴终点。| 需要注意的是，规范下 flex-direction 的默认值是 row ，而在 React Native 中则为 column，这也就是为什么我们会添加了这个的样式 12345&gt; .flex &#123;&gt; display: flex;&gt; flex-direction: row;&gt; &#125;&gt; flex-wrapflex-wrap 指定 flex 元素单行显示还是多行显示。如果允许换行，这个属性允许控制行的堆叠方向。默认值为 nowrap。 支持的值如下：|值|意义||–|–||nowrap|不换行。flex 元素被摆放到到一行，这可能导致溢出 flex 容器。交叉轴的起点会根据 flex-direction 的值相当于 start 或 before。||wrap|flex 元素被打断到多个行中。交叉轴的起点会根据 flex-direction 的值选择等于start 或before。交叉轴的终点为确定的交叉轴的起点的另一端。||wrap-reverse|和 wrap 的行为一样，但是交叉轴的起点和交叉轴的终点互换。| 使用 flex-wrap 属性的时候，我们需要注意 wrap-reverse 值在 React Native 上是不支持的。 flex-flowflex-flow 属性是 flex-direction 和 flex-wrap 的简写。默认值为 row nowrap。 语法格式1&lt;&apos;flex-direction&apos;&gt; || &lt;&apos;flex-wrap&apos;&gt; flex-flow 属性不被 React Native 和快应用支持 align-itemsalign-items 属性将所有直接子节点上的 align-self 值设置为一个组。 align-self 属性设置项目在其包含块中在交叉轴方向上的对齐方式。默认值为 stretch。 值 意义 stretch flex 元素在交叉轴方向拉伸到与容器相同的高度或宽度（flex 元素不能固定尺寸） flex-start 交叉轴的起点对齐 flex-end 交叉轴的终点对齐 center 交叉轴的中点对齐 baseline 元素第一行文字的基线对齐 语法格式12345normal | stretch | &lt;baseline-position&gt; | [ &lt;overflow-position&gt;? &lt;self-position&gt; ]where &lt;baseline-position&gt; = [ first | last ]? baseline&lt;overflow-position&gt; = unsafe | safe&lt;self-position&gt; = center | start | end | self-start | self-end | flex-start | flex-end baseline 值不被 React Native 和快应用支持 space-evenly、start、end、self-start、self-end、left、right、first baseline、last baseline、safe、unsafe 在 flex 布局中通用性低 align-contentalign-content 属性设置了如何沿着 flex 容器的交叉轴和在 flex 元素之间和周围分配空间。默认值为 stretch。 该属性对单行弹性盒子模型无效。（即：带有 flex-wrap: nowrap 的 flex 容器）。 值 意义 stretch 拉伸所有 flex 元素来填满剩余空间。剩余空间平均的分配给每一个 flex 元素 flex-start 所有 flex 元素从垂直轴起点开始填充。第一个 flex 元素的垂直轴起点边和 flex 容器的垂直轴起点边对齐。接下来的每一个 flex 元素紧跟前一个 flex 元素。 flex-end 所有 flex 元素从垂直轴末尾开始填充。最后一个 flex 元素的垂直轴终点和容器的垂直轴终点对齐。同时所有后续 flex 元素与前一个对齐。 center 所有 flex 元素朝向容器的中心填充。每 flex 元素互相紧挨，相对于容器居中对齐。容器的垂直轴起点边和第一个 flex 元素的距离相等于容器的垂直轴终点边和最后一个 flex 元素的距离。 space-between 所有 flex 元素在容器中平均分布。相邻两 flex 元素间距相等。容器的垂直轴起点边和终点边分别与第一个 flex 元素和最后一个 flex 元素的边对齐。 space-around 所有 flex 元素在 flex 容器中平均分布，相邻两 flex 元素间距相等。容器的垂直轴起点边和终点边分别与第一个 flex 元素和最后一个 flex 元素的距离是相邻两 flex 元素间距的一半。 space-evenly flex 元素都沿着主轴均匀分布在指定的 flex 元素中。相邻 flex 元素之间的间距，主轴起始位置到第一个 flex 元素的间距,，主轴结束位置到最后一个 flex 元素的间距，都完全一样。 语法格式123456normal | &lt;baseline-position&gt; | &lt;content-distribution&gt; | &lt;overflow-position&gt;? &lt;content-position&gt;where &lt;baseline-position&gt; = [ first | last ]? baseline&lt;content-distribution&gt; = space-between | space-around | space-evenly | stretch&lt;overflow-position&gt; = unsafe | safe&lt;content-position&gt; = center | start | end | flex-start | flex-end React Native 中需要版本号在 0.58 以上 且 flex-wrap 属性值需要为 wrap 同时只对横轴生效(即 flex-direction 属性为 column 或 column-reverse) baseline 值不被 React Native 支持 space-evenly、start、end、left、right、first baseline、last baseline、safe、unsafe 在 flex 布局中通用性低 justify-contentjustify-content 属性定义了浏览器如何分配顺着 flex 容器主轴的 flex 元素之间及其周围的空间。 值 意义 flex-start 从行首开始排列。每行第一个 flex 元素与行首对齐，同时所有后续的 flex 元素与前一个对齐。 flex-end 从行尾开始排列。每行最后一个 flex 元素与行尾对齐，其他元素将与后一个对齐。 center 伸缩元素向每行中点排列。每行第一个元素到行首的距离将与每行最后一个元素到行尾的距离相同。 space-between 在每行上均匀分配 flex 元素。相邻元素间距离相同。每行第一个元素与行首对齐，每行最后一个元素与行尾对齐。 space-around 在每行上均匀分配 flex 元素。相邻元素间距离相同。每行第一个元素到行首的距离和每行最后一个元素到行尾的距离将会是相邻元素之间距离的一半。 space-evenly flex 元素都沿着主轴均匀分布在指定的 flex 元素中。相邻 flex 元素之间的间距，主轴起始位置到第一个 flex 元素的间距,，主轴结束位置到最后一个 flex 元素的间距，都完全一样。 语法格式12345normal | &lt;content-distribution&gt; | &lt;overflow-position&gt;? [ &lt;content-position&gt; | left | right ]where &lt;content-distribution&gt; = space-between | space-around | space-evenly | stretch&lt;overflow-position&gt; = unsafe | safe&lt;content-position&gt; = center | start | end | flex-start | flex-end baseline 值不被 React Native 支持 stretch、space-evenly、start、end、left、right、first baseline、last baseline、safe、unsafe 在 flex 布局中通用性低 place-contentplace-content 属性是 align-content 和 justify-content 的简写。 语法格式1&lt;&apos;align-content&apos;&gt; &lt;&apos;justify-content&apos;&gt;? 如果第二个值不存在，且第一个值适用于用于两者，则第二个值复用第一个 如果第二个值不存在，且第一个值不适用于用于两者，则整个值无效 place-content 属性不被 React Native 支持 Flex Item 属性在 Flex Item 上，同样也有六个属性，而 order 属性在 React Native 上不支持。 orderorder 属性规定了 flex 容器中的 flex 元素在布局时的顺序。flex 元素按照 order 属性的值的增序进行布局。拥有相同 order 属性值的 flex 元素按照它们在源代码中出现的顺序进行布局。默认值为 0。 语法格式1&lt;integer&gt; order 属性不被 React Native 支持 flex-growflex-grow 属性定义 flex 元素的拉伸因子。 语法格式1&lt;number&gt; | inherit 负值无效 React Native 上默认值为 0 flex-shrinkflex-shrink 属性指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。默认值为 1。 语法格式1&lt;number&gt; | inherit 负值是不被允许的。 React Native 上默认值为 1 flex-basisflex-basis 指定了 flex 元素在主轴方向上的初始大小。如果不使用 box-sizing 改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的尺寸。 注意：如果一个 flex 元素同时设置了 flex-basis (auto 除外)和 width (或者 flex-direction: column 时设置了 height )，flex-basis 权级更高。 语法规范1content | &lt;&apos;width&apos;&gt; &lt;’width’&gt; width 值可以是&lt;length&gt;; 该值也可以是一个相对于其父弹性盒容器主轴尺寸的百分数 。 负值是不被允许的。 默认为 0。 content 基于 flex 元素的内容自动调整大小。 React Native 上使用 ScrollView 组件会导致属性失效 如果没有足够空间，组件不会发生收缩 (应该是设置了 flex-shrink 属性值默认为 0) flexflex 规定了 flex 元素如何伸长或缩短以适应 flex 容器中的可用空间。这是一个简写属性，用来设置 flex-grow, flex-shrink 与 flex-basis。 语法格式1none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ] initial 元素会根据自身宽高设置尺寸。 它会缩短自身以适应 flex 容器，但不会伸长并吸收 flex 容器中的额外自由空间来适应 flex 容器 。 相当于将属性设置为”flex: 0 1 auto”。 auto 元素会根据自身的宽度与高度来确定尺寸，但是会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应 flex 容器。 这相当于将属性设置为 “flex: 1 1 auto”。 none 元素会根据自身宽高来设置尺寸。 它是完全非弹性的：既不会缩短，也不会伸长来适应 flex 容器。 相当于将属性设置为”flex: 0 0 auto”。 在 React Native 中只能为 number 类型 当 flex &gt; 0 时，组件大小将与其弹性值成比例。因此，flex 设置为 2 的组件将占用空间的两倍作为 flex 设置为 1 的组件 当 flex = 0 时，组件根据 width 和 height 确定大小，且不会发生变化。 当 flex = -1 时，组件通常根据 width 和 height 确定大小。但是，如果没有足够的空间，组件将收缩到 minWidth 和 minHeight。 在快应用中，flex 的快捷值设置均是无效值 align-selfalign-self 会对齐当前 flex 行中的 flex 元素，并覆盖 align-items 的值. 如果任何 flex 元素的侧轴方向 margin 值设置为 auto，则会忽略 align-self。 语法格式12345auto | normal | stretch | &lt;baseline-position&gt; | &lt;overflow-position&gt;? &lt;self-position&gt;where &lt;baseline-position&gt; = [ first | last ]? baseline&lt;overflow-position&gt; = unsafe | safe&lt;self-position&gt; = center | start | end | self-start | self-end | flex-start | flex-end baseline 值不被 React Native 和快应用支持 start、end、self-start、self-end、first baseline、last baseline、safe、unsafe 在 flex 布局中通用性低 组件化开发不同的平台如 Web、React-Native、微信小程序等各有特色，平台之间的差异很大，会导致很多额外的开发成本。那么如果我们想要完成一个跨平台项目该怎么做呢？ 我们开始从比较容易入手的方向考虑，如果采用模块化组件或是 css-in-js 的方案去完成样式的构建会是一个好的方案么？ 在目前的前端生态中，模块化组件开发会是个很棒的方案，覆盖模式下构建开箱即用的组件同时可以提供方法来覆盖样式再好不过了，但是如果放到小程序开发的模式中，这就会有个很严重的问题，那就是如果我们在层级样式表中写到的样式，是不能直接传给组件来覆盖样式的，组件和组件的隔离在不同小程序中很难被打破。 1234567891011121314151617/* CustomComp.js */export default class CustomComp extends Component &#123; static defaultProps = &#123; className: '' &#125; render () &#123; return &lt;View className=&#123;this.props.className&#125;&gt;这段文本的颜色不会由组件外的 class 决定&lt;/View&gt; &#125;&#125;/* MyPage.js */export default class MyPage extends Component &#123; render () &#123; return &lt;CustomComp className=\"red-text\" /&gt; &#125;&#125; 1234/* MyPage.scss */.red-text &#123; color: red;&#125; 如果大家尝试上述的写法，会发现 red-text 类中的样式并没有生效，那么在这种情况下我们如果考虑是使用 css-in-js 会好么？很遗憾，如果你使用它，我们将不会为这些需要运行时处理的样式补全前缀。 这两个方案都不是合适的方案，那么我们该怎么做呢？试着去打破小程序的组件限制么？我们在微信小程序官方的文档中找到 externalClasses 这个方法，可以先来尝试。 123456789101112131415/* CustomComp.js */export default class CustomComp extends Component &#123; static externalClasses = ['my-class'] render () &#123; return &lt;View className=\"my-class\"&gt;这段文本的颜色由组件外的 class 决定&lt;/View&gt; &#125;&#125;/* MyPage.js */export default class MyPage extends Component &#123; render () &#123; return &lt;CustomComp className=\"red-text\" /&gt; &#125;&#125; 1234/* MyPage.scss */.red-text &#123; color: red;&#125; 但是这也并非所有的开发平台都能够提供给开发者相关的方法，所以我们只能转换目光到另一个 addGlobalClass 方法上，这个方法不仅在所有小程序都能够支持，Taro 在 React Native 端上也提供了同样的方法给大家，这样我们也可以避开 css modules 这个体验稍差的方法。 12345678910/* CustomComp.js */export default class CustomComp extends Component &#123; static options = &#123; addGlobalClass: true &#125; render () &#123; return &lt;View className=\"red-text\"&gt;这段文本的颜色由组件外的 class 决定&lt;/View&gt; &#125;&#125; 1234/* 组件外的样式定义 */.red-text &#123; color: red;&#125; 写在最后在项目中，我们已经将所有通用支持的方法写到 scss 文件中，如果大家需要可以直接使用我们已经提供的 flexbox 样式，按如下方法在自己全局的层级样式表中引入我们已经提供的样式。 1@import 'https://raw.githubusercontent.com/NervJS/taro-flexbox/master/flexbox-demo/src/asset/flex.scss'; 那么关于 Flex 布局的知识，如果文中有遗漏的，大家可以跟着我们的项目来梳理知识，也可以到 MDN 上查看相关的文档，值得注意的是在 Flexbox 布局中 gap、row-gap、column-gap 属性在 Grid 布局中普遍支持，但是在 Flex 布局中却只有 Firefox 完成了适配，所以暂且不表, 同样 justify-content 属性的 space-evenly 值在 web 端通用性很低，不建议使用。 gap、row-gap、column-gap in flex space-evently on desktop space-evently on mobile 希望这篇文章可以为你提供一些帮助。 属性对照表 属性 Chrome Firefox Android webview Safari on iOS 微信小程序 支付宝小程序 百度小程序 头条小程序 QQ小程序 React Native flex-direction ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ 部分差异 flex-wrap ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ wrap-reverse 不支持 flex-flow ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ 不支持 align-items ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ baseline 不支持 align-content ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ 0.58+ (部分差异) justify-content ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ baseline 不支持 place-content ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ 不支持 order ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ 不支持 flex-grow ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ flex-shrink ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ flex-basis ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ 部分差异 flex ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ 语法不同 align-self ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ baseline 不支持 相关链接 预览地址：https://nervjs.github.io/taro-flexbox/ 项目地址：https://github.com/NervJS/taro-flexbox 参考地址 https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout#Reference https://facebook.github.io/react-native/docs/flexbox https://github.com/startheart/cml-flexbox","pubDate":"Wed, 25 Sep 2019 07:00:00 GMT","guid":"https://aotu.io/notes/2019/09/25/taro-flex/","category":"移动开发"},{"title":"从程序媛角度去看项目管理","link":"https://aotu.io/notes/2019/09/11/project-management-of-programmer/","description":"项目管理一般是从技术负责人、项目产品负责人的角度去看的，程序员虽然码代码很重要，但对项目的领悟能力也同样重要。我们经常会遇到各种困惑：手上的项目需求越来越多，BUG列表只增不减，该采取怎样的措施，保证自己的生产力？希望以下的讲述带给你莫名的认同感，或多或少让你磨刀霍霍一试。 需求管理下图描述的是程序员从接到需求到开发环节的过程： 一般我们首先会收到产品的PRD或交互稿，被询问今天什么时间点是否有空，进行需求评审。时光匆匆，回想起刚毕业那时，我望着冗长的PRD，直接跳过背景、目的等看似与开发无关的内容描述。时光冉冉，我明白了一个道理：知道了为什么而做，才能砍需求啊！！ 我们要做一个有思考的程序员，不是别人说什么我们就做什么，我们可以引导产品经理，给出提醒并提供建设性的意见，让他们向着我们希望的那个点去思考去改进。嗯，牛逼~ 当然，祈求PRD完美，是不可能的，但是它又是我们排期、开发的依据，这两者存在这不可避免的矛盾。因此，力求在分析评审阶段，把不清晰不完整的部分暴露出来，是我们的目标之一。 特别警惕一句话需求，比如在页面添加一个链接，包含的功能可能有： 确认添加a元素跳转为target=”_blank”，还是在当前页面跳转； 链接的文字和地址是否可配置，是否通过接口拉取； 链接地址是否可为空，此时要警惕target=”_blank”的情况； 链接文字是否可多行，是否限制字数； 是否需要埋点，以及确认埋点方案。 第二个目标，就是砍需求了。“没时间了，这个需求放在二期吧” 这个金句，不知道大家感悟深不深，哈哈。首先要清楚自己在某个时间段的工作重点，然后根据需求与工作重点的相关系数去评估，有意识地拒绝一些无意义的工作。当然，工作重点应该是与业务息息相关的，最好是和上级商量后的结果。 于是，给自己定个todo list，在需求评审前自己过一遍相关文件内容，列出有疑问的地方，做好砍需求的准备… 需求排期确认需求后，首先确认需求的优先级，然后进行排期。如果我们手上有许多需求，确认需求的优先级是十分有必要的。 来自同一个产品的需求，可让对方给出优先级即可。 不同产品的需求，可征求需求方的意见，避免出现严重影响到对方的主流程的情况。 虽说需求的优先级主要掌握在产品经理的手上，但是我们自己也要有个认识。 了解 主线需求 &gt; 主线的分支需求 &gt; 锦上添花的需求 的原则，根据 用户覆盖面、用户使用频次、对用户的重要程度，以四象限法则“重要且紧急 &gt; 重要不紧急 &gt; 紧急不重要 &gt; 不重要也不紧急”作为辅助等等，应付什么需求都重要、什么需求都紧急的情况。 针对老板提的需求，下周要演示给老板看的需求，我们就乖乖地排期在前面吧，排除万难，没啥好说的~ 排期一直是历史难题，有以下“名言名句”供参考： 了解需求进入开发阶段的依赖条件，比如是否依赖设计稿还是接口，然后再进行排期。 不要把一天当8个或者更多的工作小时用，临时的会议或者被打断的现象太常见了。 排期留有余地，尤其是自己不熟悉的领域，风险较高。排期的计算方式有挺多，可以根据自己的丰富经验来，或者计算公式比如（一般能完成的天数 + 肯定能完成的天数）/2，或者（一般能完成的天数）* 系数，系数根据难度来区分。 把握好需求的节奏，如遇开发周期较长的需求，将需求拆分成N个子需求。 要明白，即使排期很轻松，你可能依然是最后一刻才完成，太扎心。 需求跟踪需求进入开发后，特别是大项目，得利用需求管理平台，这有利于需求的进度追踪，且方便我们汇报工作。不要把汇报工作当做负担，应化被动为主动。否则，周五下午某个时刻，你会收到产品经理的盘问：“做得怎么样了？进度如何？”；汇报工作，也有利于让大家看到自己的努力成果，成就感增倍，形成良好的工作循环；或者是了解身边的小伙伴在做什么，有利于交流。 我们现在每周五会开项目例会，汇报内容如下： 结果：进度如何，完成了哪些内容？ 计划：下周计划完成哪些内容？ 问题：讨论问题，找出问题的失误点、关键点、反思点，如何解决。 需求变更需求变更有时不可避免，我们还得拿出快速响应需求变更的本事，记录反馈所有的变更，拒绝不合理的需求。最好和产品经理达成一个共识，若因PRD的需求变动，则会根据实际情况重新排期。有代价，有反思，有利于督促双方在编写PRD、评审的阶段就开始认真对待，且定义好完成需求的标准。 研发管理打开昨天没关机的电脑屏幕，找到自己喜欢的姿势，或穿着格子衬衫、棉拖鞋，或套着护颈枕，或带着耳机听音乐，然后就开始搬砖了~~ 仓库管理为了规范代码仓库，使得版本的演进保持简洁，主干清晰，因此得遵循一些规则，避免由于维护困难造成的错误版本发布等问题。 分支要求： 每个需求必须新开一个本地分支，并备注好需求描述。 每个分支只做一个需求，切勿需求交叉修改。 合并后或无用的分支需立即删除，如果有修改，再重新拉一个新分支。 约束命名规则，如采取master、dev、feat、release、hotfix命名方式。 提交commit要求： 保证commit历史记录的整洁，要求提交的代码粒度要小， 尽量保证这个 commit只做一件事情，否则很难描述清楚。 约定commit提交规范，如 Angular 团队的规范&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;，且利用commitlint工具约束一些格式，同时避免使用-n强制提交。 有分支就有合并，合理选择适当的时机、适当的方式进行合并，比如merge --no-ff、merge --squash、rebase还是cherry-pick。大家都知道，变基有风险，且要遵循变基原则：只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作。 有合并就可能有冲突。如果一直存在大量的冲突，说明是分工、组织架构不对，需要减少多人同时改动同一份代码的几率。如遇到冲突，可采取以下措施： 降低合并分支冲突的数量，比如先合并少冲突的分支，再合并冲突多的分支。 熟悉Git操作，适当借助可视化合并工作。 合并后的代码检查，让代码实际运行一遍。 如果冲突的不是自己负责的代码，让具体负责人来参与代码合并。 代码管理 逻辑一定要清晰，考虑周全。不要只考虑普通情况，还要考虑什么情况会出错，失败了如何处理，总之，多维度去思考。 当第二次编写相同的代码时，是提取成组件的正确时机。对于大项目，第三次才提取，将会增强执行的阻力。 一定要多写注释，解释代码的意图和及其原因，再次回头看的时候，你也会十分感激自己，效率往上蹭。 如果函数或方法超过 30 行代码，考虑优化它，可用工具比如vscode的插件CodeMetrics辅助提示解决，心中要有一把尺子时刻鞭策自己，凡事得过自己那一关。 看到问题，即使暂时不能解决，一定要以某种方式把问题抛出来，不然容易遗忘在某个角落。当然，能解决就当场解决，再次拾起的时间、人力代价也是很高的。 风险管理即使小心再小心，意外总是会在某一刻发生。所以我们要时刻控制，降低需求变更、项目延期的风险，应用积累的经验和专业知识来预测何时会出现风险，以及如何采取有效的应对措施。 风险管理就是如何预防风险： 下面挑几个重点讲讲： 需求理解误差、难度误判、排期紧张，在分析评审阶段，可以一定程度地避免这些问题，当然也和我们自身的能力有关。自己越没有把握的事，争取留些时间以备不测，避免延期的情况出现。 确认有效的沟通方式，及时抛出异常。可在研发邮件中暴露进度是否异常、同步需求变更，是否存在待确认的问题，或者标红其他重要信息。 认真验收所有需求，是否遗漏功能。除了覆盖功能基本流程逻辑的形式，也可以从用户的使用习惯角度去进行场景测试。说起来容易，有时候做起来难，特别是对项目不是特别熟悉，项目又特别复杂的情况，此时要做的就是，根据代码影响的范围来确定自测的范围。项目成员可共同维护一份功能列表，以此为依据进行测试。 保证测试分支与将上线的内容一致，也就是说，保证测试分支的干净程度。如果测试完毕后才合并分支，可能带来合并冲突的类似问题。 针对大版本，分析上线前的依赖，通知到所有相关人员，最好开一个上线总动员的会议，共同探讨上线注意事项、遗留的问题。 针对小版本，约定上线的频次。可每周固定周二或周四发版，且发送上线申请邮件，不可随意发版。 上线前后，指定每人负责某些模块的测试以及风险管理，有利于内心产生更大的责任去做好，甚至可以影响督促别人。 报错异常、性能、服务异常要监控，保证第一时间收到异常并处理。 上线后，及时回顾总结项目的成功和失败之处，剖析各个环节存在的问题，为以后的项目提供参考。 一个优秀的程序员和一个普通程序员的差别，可能在于理解问题的深度。“试试重启一下电脑”，当电脑出现问题的时候，我们经常会想到这句话。但是有没有想过，可能失去了一个挖掘问题本质的机会，导致以后问题该出现的时候还是会出现。再者，我们码程序，修BUG，有时候忽略了质量，而去赶进度，这是得不偿失的，最后坑的还是自己啊。 总结以上从需求管理、研发管理、风险管理三个大方向，又细分了小方向去讲述如何管理好手上的项目。人本身就是一个产品，多个项目的集合。项目就要好心经营，精心管理，因为正是这一件一件的执行的过程，构成了我们丰富多彩的程序员生活。 经验有限，或许以上内容有瑕疵，欢迎交流与更正。谢谢大家~","pubDate":"Wed, 11 Sep 2019 07:00:00 GMT","guid":"https://aotu.io/notes/2019/09/11/project-management-of-programmer/","category":"项目总结"},{"title":"京东 PC 首页 2019 改版前端总结","link":"https://aotu.io/notes/2019/08/26/jdindex_2019/","description":"距离上次首页改版，已有2年3个月零五天。相比上次改版对首页整体框架、开发流程的大刀阔斧（前两次改版总结传送门：2016版，2017版），这次的改版看起来显得有点像跳水——没什么水花。在站在巨人肩膀上的小巨人的叮咛与期盼下，这次改版在延续17版的框架与流程的基础之上，为首页的稳定性、安全性、视觉体验、无障碍体验方面见缝插针地添了砖加了瓦。 本文将从以下几个方面进行阐述 引入强类型校验 升级资源构建方案 接入自动化测试 完善监控体系 优化页面加载体验：骨架屏 优化信息无障碍体验 引入强类型校验在性能几近无懈可击的情况下，我们决定从稳定性入手，为项目引入强类型校验，弥补 JavaScript 这种弱类型语言在不可预测性上的缺陷。 强类型语言 TypeScript 已发布6年有余，国内应用的开发者也在慢慢增长。一般来说，业务开发周期短，迭代频繁，TypeScript 的引入对于很大一部分开发者来说是一件费时费力的事，用的话业务可以上线，不用的话业务照样可以上线，因此团队极少在业务生产中应用。但秉承着不折腾不凹凸的理念，新版首页不负使命的，进行了基于 TS 的重构。 做 TS 重构并不难，把 js 后缀改成 ts 就好了。完。 当然是开玩笑的啦！显然，这样的 TS 是没有意义的。只有严格遵循 TS 标准的代码才能最大化 TS 的效用。在项目中，我们对 TS 的检查开启 strict 模式，每次提交时，都会对代码做一次完整的检查，只要有 TS 报错就禁止提交，旨在向成员传达一个信息——写强类型语言就该有觉悟，否则就是耍流氓。 没有深入使用过 TS 的同学在前期可能会感到人生的艰难，但这些都是为你好为了保证代码的健壮性。例如，在以往难以定位、查找的 window 全局变量的管理上，十分令开发者头疼，而引入了 TS 之后，只要对全局变量进行了接口设置，各个组件中再也不会出现多余或是未知全局变量的情况。再例如，在写一个拥有 get、set 方法的存贮类的时候，TS 能帮助检测获取内容的类型： 123456789101112131415161718192021222324interface MemoryState &#123; testa: boolean testb: string&#125;class Controller &#123; state: StateType constructor() &#123; this.state = &#123; state: &#123;&#125;, &#125; &#125; get&lt;K extends MemoryStateKeys&gt;(key: K) &#123; return this.state.memory[key] &#125; set&lt;K extends MemoryStateKeys&gt;(key: K, value: MemoryState[K]): MemoryState[K] &#123; this.state.memory[key] = value return value &#125;&#125; 当我们使用 new Controller().get(&quot;testb&quot;) 的时候，TS 能够在开发阶段检测 testb 是否是 string 类型。通过 TS 的检测插件，我们能放心的使用 string 类型对象的方法，简化繁复的判断逻辑，同时保证代码在获取到非期望值时能及时通过报错发现，一切的输入和输出都是稳定可预测的，四舍五入就是在写代码的时候自动走了一部分测试，为项目的开发与迭代保驾护航。 升级资源构建方案旧版首页项目使用的构建工具 Athena，推进了开发流程自动化，但是涉及到定制化的构建流程时，由于 Athena 的通用性，不方便直接做改动。首页包含直出、同步、异步三种类型的资源引用，需对资源的打包进行特殊处理，所以我们这次回归 Webpack，基于 Webpack 4.0 做了以下的方案优化： 发布流程优化 旧版的发布流程中，每次发布需要对改动的文件进行 diff 检查，避免产生不符合预期的误改动。Webpack 默认打包机制的特点，是根据模块的打包顺序为每一个模块提供一个按顺序编号的 ID，对文件的包进行依赖管理。旧版首页的入口文件包含依赖包管理的执行环境，因此任何一个包引入顺序发生变动时，入口文件都会发生变动。以上的打包机制会出现一个文件发生引入顺序变动时，可能会影响到编译后的几个甚至十几个文件发生变动的情况，而这些文件中的逻辑代码部分其实并不需要更新，这就降低了 diff 代码的准确性，使得这一中间检查措施失去了原本的意义。首页缓存机制与资源懒加载机制使得静态资源在发布时，需要对发生变动的文件进行 CDN 缓存清除的操作，也就意味着，改动文件越多，需要清除的缓存资源链接就越多，而链接越多，由于缓存清除不同步引起的资源异步加载出错的概率就越高，每次上线发布都存在一定的风险。 为了减少发布风险，新版首页的打包机制改变了 Webpack 的打包逻辑，通过设置，每个模块不再通过顺序编号的 ID 管理依赖包，而是通过文件目录生成哈希编码的专有 ID，并把依赖包的执行环境从入口文件中抽离出来作为一个单独的资源请求，这样每次改动文件时，可以只针对改动的文件 diff，剔除了其他非预期的 diff 情况。通过新的构建方案，使代码改动控制在预期的范围内，保证部署流程的稳定。 项目架构优化旧版页面的性能优化方案中，包含了部分 js 片段直出，这些代码是项目所依赖的基函数，需要在核心 js 代码执行之前启动。但这样的方案也有一些不尽人意的地方： 由于代码需要直出于页面模版中，考虑到兼容性，这些代码不能使用一些高级语法，每次改动都需要确保自己的代码没有兼容问题，导致维护成本巨高。同时，首页页面模版由后台负责管理，直出代码的改动需经过后台发布，迭代成本略高，风险也不小； 由于打包的限制，核心代码与模板代码存在同一套公用代码，代码冗余不说，一旦这部分代码发生变动还需要同时修改与发布两部分的代码，使得代码的维护成本增高。 针对以上问题，新版中我们将这些代码重新放入核心代码，模板代码中不再承载任何逻辑代码，迭代发版不再涉及模版发布，只需进行静态资源的发布即可，开发过程中统一使用 JS 高级语法，去除人工维护兼容语法代码的过程。 至此，我们通过增强资源打包的可预测性、以及优化项目资源架构两个方面对资源的发布方案进行了优化。 接入自动化测试一个页面开发完成后，在对其进行提测之前，对页面进行自测是一个必不可少的环节。一方面，保证页面所开发的功能能正常运作；另一方面，保证在对一个功能进行开发时，没有影响到页面其他区域功能的正常使用。 一般情况下，自测需要人为手动地进行测试，但这样会有两个缺点，第一，需要测试的区域数量过于巨大，相似的测试操作过于频繁，浪费了人力，也影响了测试的效率；第二，人为的自测由于没有统一的自测规范，因此在测试时很容易有所疏漏，从而忽视了一些看似微小，实则影响巨大的 bug，花费了大量的时间，却得不到自测所需要的效果。针对这种情况，我们产生了实施自动化测试的想法。以新版首页为例，我们通过使用 Nightwatch.js，为新版首页创建了一个自动化测试脚本，对新版的首页的73项用例进行自动化测试。 结果显示，通过自动化测试，在不到三分钟的时间内，完成了对新版首页73项用例的测试，这也意味着，若要通过自动化测试，来对任一页面进行自测，自测的时间都可控制在五分钟以内，并且准确性更高。将自动化测试应用在发布前以及上线后5分钟之内，及时检查测试用例，保证每次发版的安全。 完善监控体系旧版页面的前端监控体系覆盖了浏览器信息、页面加载测速、楼层隐藏方面，但信息通知较为滞后，且仅覆盖了页面 onLoad 时间，收到告警信息时，无法做到快速定位问题。 参考京东购物小程序目前的监控机制，新版首页针对代码报错、接口可用性增加了上报监控。 代码报错监控：BadJS通过 BadJS 框架捕获页面报错，并分析处理报错信息上报至京东 BadJS 服务。通过上报数据，我们可以得到报错的详细信息以及发生次数。通过分析上报数据，可以发现一些潜在的问题，及时修复，保证首页代码的健壮性。同时根据上报数，还可以预估出一个问题所造成的影响范围，便于预估损失。 业务可用性监控本次改版，在可用率上报系统中为首页补充了特定判定规则，包含调用次数、可用率、和 TP（性能指标）三个维度，在此基础上还可以对这三个维度进行环比，以减少误报的可能性，近期系统还上线了红灯告警-语音通知功能。 可用率上报系统一般被用来监听接口可用性，但对于首页来说，除了接口，还需关注楼层隐藏的情况。目前的兜底方案中，每个楼层中的模块接口兜底全部失效的情况下，会隐藏当前楼层。楼层一旦发生隐藏，则意味着出现了比较严重的问题，需快速关注并解决。可用率上报系统可做到触发告警规则时，1分钟之内即推送通知，精确到接口，便于及时发现问题，及时止损。需要注意的是，如何设置一套能够较为精确反映问题发生、减少假报警的阈值尤为重要，毕竟狼来了喊多了，也就等于没有监控。 测速上报这一部分延用了旧版的 Athena 测速上报方案，并对一些与业务数据上报重复的部分做了减法，同时增加了接口的测速上报，完善故障追溯数据体系。 优化页面加载体验：骨架屏旧版页面懒加载的占位方案采用了统一区域 loading 动画的方式，这种方式的优势在于复用成本低，适配性强。但如果遇到较大面积的模块或是模块较为密集的情况时，区域 loading 动画的体验有所下降————要么是空白区域过大，要么是 loading 动画过于密集，模块加载过程造成的视觉差异感知较为明显。而对于 PC 首页来说，空白区域过大是主要存在的问题。 低网速下旧版首页的 loading 体验 这次改版，我们引入了骨架屏方案，最终目的是以灰色豆腐块的形式尽量缩小真实模块结构与加载占位之间的视觉差异。执行起来可以按照视觉差异分为两种对应关系： 弱对应关系：只对模块进行标题、子项等主要内容进行块化处理，复用性较高，适配性中等； 强对应关系：以视觉效果为基础，对子项进一步作出图片、文案的块化处理，针对占位面积较大、内容更为复杂的子项进行更细化的块化拆分，复用性低，适配性高。 考虑到首页的特殊性，我们最终选择了强对应关系的骨架屏方案，并为了可扩展性，使用的是使用样式渲染的骨架屏，而不是直接使用图片占位。除了开发成本的上升，页面首屏加载代码量也有所增加。 项目结构使用骨架屏所要达到的效果包含以下几点： 提前占位，在页面的加载中滚动条不发生较为明显的跳动； 页面快速滚动时也能看到骨架屏样式的占位。 也就意味着骨架屏的内容需要与页面做同步加载处理，结合懒加载组件，骨架屏组件需提前作为 loading 结构传入，并保证样式在页面渲染的第一时间进行加载，否则就失去了骨架屏的意义。 每个需要骨架屏样式的组件，单独拆分出一个 placeholder 组件。组件内的占位结构包含两类样式——颜色与尺寸定位，加上容器外层的动画效果样式。颜色样式全页公用，尺寸定位样式与正式组件公用： 尺寸定位样式与正式组件公用的目的是为了在将来组件样式发生变化时，保证骨架屏与正式样式的统一修改，避免出现样式修改上的遗漏，但同时增加了样式的维护成本。同时样式编写与拆分的过程中也需要开发者注意兼容骨架屏的样式，例如需要占位豆腐块的容器间距 padding、margin 的选择都很重要。因此这次首页的骨架屏尝试并不适合快速复用至其他项目。 新版首页骨架屏 loading 体验 优化信息无障碍体验互联网信息无障碍，即针对视力障碍人士所提供的辅助。系统级别的辅助主要依赖读屏工具，读屏工具可以解决网页端信息无障碍 60%的阻碍，剩余的 40%需要在网页开发的过程中由开发者进行体验优化。 没有做任何信息无障碍处理的网页，使用读屏工具访问时一般存在以下几个问题： 多余无用信息的播报，例如：跳转链接、图片名称； 弹出浮层无法访问； 懒加载内容直接跳过； 为了造福国内一百一十人中的一个视障人士（数据来自这里），本次改版，我们决定在 PC 首页开启京东商城桌面端首个信息无障碍实践。 桌面端视障用户的操作主要通过键盘进行。针对刚才提出的几个问题，PC 首页初步的无障碍体验优化方案分为几个阶段。 第一阶段，语义化一切 tab 可及的元素——包含页面外跳转链接的 a 标签统一添加 aria-label 属性，以便读屏软件能够简化读取元素信息； 第二阶段，保证页面主要模块的访问——懒加载内容占位容器将 tab-index 设置为大于 0 的值，使得 tab 键能够遍历到，以便触发页面懒加载，避免 tab 直接跳过； 第三阶段，扩展带弹出浮层等元素的操作——针对无障碍增加弹出浮层交互逻辑，入口增加 aria-haspopup 属性，告诉读屏软件这里是弹出浮层的入口，将 tab-index 设置为大于 0 的数值使得 tab 操作可聚焦到，浮层弹出后焦点自动聚焦至浮层； 第四阶段，为视障用户额外增加快捷跳转——参考 Google 搜索结果页，可在页面的顶部，增加一些隐藏的快捷跳转。PC 首页本次对搜索框以及底部的“为你推荐”位置增加了隐藏跳转链接，只有使用键盘操作的用户能够定位到。 对于商城页面来说，第一阶段能满足基本的内容访问，而如果能做到第四阶段，才能算一个完整的信息无障碍网站。商城业务中，无障碍体验一直缺乏相应的规范与测试流程，因此通过本次 PC 首页的改版实践，输出了一份针对商城频道页的信息无障碍开发规范，内容包含： 访问路径设计规范 语义化规范 读屏测试规范 未来将借由这份规范，陆续实现商城其他业务的无障碍体验优化。 综上，本次改版对于开发者来说最大的变化，就是本地开发体验更加舒服、发布风险有所降低、故障追溯更加完善，而对用户来说，页面加载跳动感大大减小，视障用户的体验终于得以照顾到。作为商城桌面端的入口与门面，首页的改进一定不止于此，希望每一次的改版都能有一丝的优化，使得首页这个项目趋近完美。","pubDate":"Mon, 26 Aug 2019 09:00:00 GMT","guid":"https://aotu.io/notes/2019/08/26/jdindex_2019/","category":"PC"},{"title":"serverless","link":"https://aotu.io/notes/2019/08/05/serverless/","description":"Serverless 架构即“无服务器”架构，它是一种全新的架构方式，是云计算时代一种革命性的架构模式。与云计算、容器和人工智能一样，Serverless 是这两年IT行业的一个热门词汇，它在各种技术文章和论坛上都有很高的曝光度。 目前行业可能更多处在容器 Docker+Kubernetes, 利用 IaaS、PaaS和SaaS 来快速搭建部署应用 什么是ServerlessServerless 圈内俗称为“无服务器架构”，Serverless 不是具体的一个编程框架、类库或者工具。简单来说，Serverless 是一种软件系统架构思想和方法，它的核心思想是用户无须关注支撑应用服务运行的底层主机。这种架构的思想和方法将对未来软件应用的设计、开发和运营产生深远的影响。 所谓“无服务器”，并不是说基于 Serverless 架构的软件应用不需要服务器就可以运行，其指的是用户无须关心软件应用运行涉及的底层服务器的状态、资源（比如 CPU、内存、磁盘及网络）及数量。软件应用正常运行所需要的计算资源由底层的云计算平台动态提供。 Serverless的技术实现Serverless 的核心思想是让作为计算资源的服务器不再成为用户所关注的一种资源。其目的是提高应用交付的效率，降低应用运营的工作量和成本。以 Serverless 的思想作为基础实现的各种框架、工具及平台，是各种 Serverless 的实现（Implementation）。Serverless不是一个简单的工具或框架。用户不可能简单地通过实施某个产品或工具就能实现 Serverless 的落地。但是，要实现 Serverless 架构的落地，需要一些实实在在的工具和框架作为有力的技术支撑和基础。 随着 Serverless 的日益流行，这几年业界已经出现了多种平台和工具帮助用户进行 Serverless 架构的转型和落地。目前市场上比较流行的 Serverless 工具、框架和平台有： AWS Lambda，最早被大众所认可的 Serverless 实现。 Azure Functions，来自微软公有云的 Serverless 实现。 OpenWhisk，Apache 社区的开源 Serverless 框架。 Kubeless，基于 Kubernetes 架构实现的开源 Serverless 框架。 Fission，Platform9 推出的开源 Serverless 框架。 OpenFaaS，以容器技术为核心的开源 Serverless 框架。 Fn，来自 Oracle 的开源 Serverless 框架，由原 Iron Functions 团队开发。 列举的 Serverless 实现有的是公有云的服务，有的则是框架工具，可以被部署在私有数据中心的私有云中（私有云 Serverless 框架 OpenWhisk、Fission 及 OpenFaaS）。每个 Serverless 服务或框架的实现都不尽相同，都有各自的特点。 FaaS与BaaSIT是一个永远都不消停的行业，在这个行业里不断有各种各样新的名词和技术诞生，云计算（Cloud Computing）的出现是21世纪IT业界最重大的一次变革。云计算的发展从基础架构即服务（Infrastructure as a Service， IaaS），平台即服务（Platform as a Service，PaaS），软件即服务（Software as a Service，SaaS），慢慢开始演变到函数即服务（Function as a Service，FaaS）以及后台即服务（Backend as a Service，BaaS），Serverless 无服务化。 目前业界的各类 Serverless 实现按功能而言，主要为应用服务提供了两个方面的支持：函数即服务（Function as a Service，FaaS）以及后台即服务（Backend as a Service，BaaS）。 1.FaaSFaaS 提供了一个计算平台，在这个平台上，应用以一个或多个函数的形式开发、运行和管理。FaaS 平台提供了函数式应用的运行环境，一般支持多种主流的编程语言，如 Java、PHP 及 Python 等。FaaS 可以根据实际的访问量进行应用的自动化动态加载和资源的自动化动态分配。大多数 FaaS 平台基于事件驱动（Event Driven）的思想，可以根据预定义的事件触发指定的函数应用逻辑。 目前业界 FaaS 平台非常成功的一个代表就是AWS Lambda平台。AWS Lambda 是 AWS 公有云服务的函数式计算平台。通过 AWS Lambda，AWS 用户可以快速地在 AWS 公有云上构建基于函数的应用服务。 2.BaaS为了实现应用后台服务的 Serverless 化，BaaS（后台即服务）也应该被纳入一个完整的 Serverless 实现的范畴内。通过 BaaS 平台将应用所依赖的第三方服务，如数据库、消息队列及存储等服务化并发布出来，用户通过向 BaaS 平台申请所需要的服务进行消费，而不需要关心这些服务的具体运维。 BaaS 涵盖的范围很广泛，包含任何应用所依赖的服务。一个比较典型的例子是数据库即服务（Database as a Service，DBaaS）。许多应用都有存储数据的需求，大部分应用会将数据存储在数据库中。传统情况下，数据库都是运行在数据中心里，由用户运维团队负责运维。在DBaaS的场景下，用户向 DBaaS 平台申请数据库资源，而不需要关心数据库的安装部署及运维。 Serverless的技术特点为了实现解耦应用和服务器资源，实现服务器资源对用户透明，与传统架构相比，Serverless 架构在技术上有许多不同的特点。 1.按需加载 在 Serverless 架构下，应用的加载（load）和卸载（unload）由 Serverless 云计算平台控制。这意味着应用不总是一直在线的。只有当有请求到达或者有事件发生时才会被部署和启动。当应用空闲至一定时长时，应用会到达或者有事件发生时才会被部署和启动。当应用空闲至一定时长时，应用会被自动停止和卸载。因此应用并不会持续在线，不会持续占用计算资源。 2.事件驱动 Serverless 架构的应用并不总是一直在线，而是按需加载执行。应用的加载和执行由事件驱动，比如HTTP请求到达、消息队列接收到新的信息或存储服务的文件被修改了等。通过将不同事件来源（Event Source）的事件（Event）与特定的函数进行关联，实现对不同事件采取不同的反应动作，这样可以非常容易地实现事件驱动（Event Driven）架构。 3.状态非本地持久化 云计算平台自动控制应用实例的加载和卸载，且应用和服务器完全解耦，应用不再与特定的服务器关联。因此应用的状态不能，也不会保存在其运行的服务器之上，不能做到传统意义上的状态本地持久化。 4.非会话保持 应用不再与特定的服务器关联。每次处理请求的应用实例可能是相同服务器上的应用实例，也可能是新生成的服务器上的应用实例。因此，用户无法保证同一客户端的两次请求由同一个服务器上的同一个应用实例来处理。也就是说，无法做到传统意义上的会话保持（Sticky Session）。因此，Serverless架构更适合无状态的应用。 5.自动弹性伸缩 Serverless 应用原生可以支持高可用，可以应对突发的高访问量。应用实例数量根据实际的访问量由云计算平台进行弹性的自动扩展或收缩，云计算平台动态地保证有足够的计算资源和足够数量的应用实例对请求进行处理。 6.应用函数化 每一个调用完成一个业务动作，应用会被分解成多个细颗粒度的操作。由于状态无法本地持久化，这些细颗粒度的操作是无状态的，类似于传统编程里无状态的函数。Serverless 架构下的应用会被函数化，但不能说 Serverless 就是 Function as a Service（FaaS）。Serverless 涵盖了 FaaS 的一些特性，可以说 FaaS 是 Serverless 架构实现的一个重要手段。 Serverless的应用场景通过将 Serverless 的理念与当前 Serverless 实现的技术特点相结合，Serverless 架构可以适用于各种业务场景。 1.Web应用 Serverless 架构可以很好地支持各类静态和动态Web应用。如 RESTful API 的各类请求动作（GET、POST、PUT及DELETE等）可以很好地映射成 FaaS 的一个个函数，功能和函数之间能建立良好的对应关系。通过 FaaS 的自动弹性扩展功能，Serverless Web 应用可以很快速地构建出能承载高访问量的站点。 2.移动互联网 Serverless 应用通过 BaaS 对接后端不同的服务而满足业务需求，提高应用开发的效率。前端通过FaaS提供的自动弹性扩展对接移动端的流量，开发者可以更轻松地应对突发的流量增长。在 FaaS 的架构下，应用以函数的形式存在。各个函数逻辑之间相对独立，应用更新变得更容易，使新功能的开发、测试和上线的时间更短。 3.物联网（Internet of Things，IoT） 物联网（Internet of Things，IoT）应用需要对接各种不同的数量庞大的设备。不同的设备需要持续采集并传送数据至服务端。Serverless 架构可以帮助物联网应用对接不同的数据输入源。 4.多媒体处理 视频和图片网站需要对用户上传的图片和视频信息进行加工和转换。但是这种多媒体转换的工作并不是无时无刻都在进行的，只有在一些特定事件发生时才需要被执行，比如用户上传或编辑图片和视频时。通过 Serverless 的事件驱动机制，用户可以在特定事件发生时触发处理逻辑，从而节省了空闲时段计算资源的开销，最终降低了运维的成本。 5.数据及事件流处理 Serverless 可以用于对一些持续不断的事件流和数据流进行实时分析和处理，对事件和数据进行实时的过滤、转换和分析，进而触发下一步的处理。比如，对各类系统的日志或社交媒体信息进行实时分析，针对符合特定特征的关键信息进行记录和告警。 6.系统集成 Serverless 应用的函数式架构非常适合用于实现系统集成。用户无须像过去一样为了某些简单的集成逻辑而开发和运维一个完整的应用，用户可以更专注于所需的集成逻辑，只编写和集成相关的代码逻辑，而不是一个完整的应用。函数应用的分散式的架构，使得集成逻辑的新增和变更更加灵活。 Serverless的局限世界上没有能解决所有问题的万能解决方案和架构理念。Serverless 有它的特点和优势，但是同时也有它的局限。有的局限是由其架构特点决定的，有的是目前技术的成熟度决定的，毕竟 Serverless 还是一个起步时间不长的新兴技术领域，在许多方面还需要逐步完善。 1.控制力 Serverless 的一个突出优点是用户无须关注底层的计算资源，但是这个优点的反面是用户对底层的计算资源没有控制力。对于一些希望掌控底层计算资源的应用场景，Serverless 架构并不是最合适的选择。 2.可移植性 Serverless 应用的实现在很大程度上依赖于 Serverless 平台及该平台上的 FaaS 和 BaaS 服务。不同IT厂商的 Serverless 平台和解决方案的具体实现并不相同。而且，目前 Serverless 领域尚没有形成有关的行业标准，这意味着用户将一个平台上的 Serverless 应用移植到另一个平台时所需要付出的成本会比较高。较低的可移植性将造成厂商锁定（Vendor Lock-in）。这对希望发展 Serverless 技术，但是又不希望过度依赖特定供应商的企业而言是一个挑战。 3.安全性 在 Serverless 架构下，用户不能直接控制应用实际所运行的主机。不同用户的应用，或者同一用户的不同应用在运行时可能共用底层的主机资源。对于一些安全性要求较高的应用，这将带来潜在的安全风险。 4.性能 当一个 Serverless 应用长时间空闲时将会被从主机上卸载。当请求再次到达时，平台需要重新加载应用。应用的首次加载及重新加载的过程将产生一定的延时。对于一些对延时敏感的应用，需要通过预先加载或延长空闲超时时间等手段进行处理。 5.执行时长 Serverless 的一个重要特点是应用按需加载执行，而不是长时间持续部署在主机上。目前，大部分 Serverless 平台对 FaaS 函数的执行时长存在限制。因此 Serverless 应用更适合一些执行时长较短的作业。 6.技术成熟度 虽然 Serverless 技术的发展很快，但是毕竟它还是一门起步时间不长的新兴技术。因此，目前 Serverless 相关平台、工具和框架还处在一个不断变化和演进的阶段，开发和调试的用户体验还需要进一步提升。Serverless 相关的文档和资料相对比较少，深入了解 Serverless 架构的架构师、开发人员和运维人员也相对较少。 Other Resources精读《Serverless 给前端带来了什么》Docker — 从入门到实践serverless-chrome怎么理解 IaaS、SaaS 和 PaaS 的区别？","pubDate":"Mon, 05 Aug 2019 02:27:06 GMT","guid":"https://aotu.io/notes/2019/08/05/serverless/","category":"Web开发"},{"title":"使用 React Hooks 重构你的小程序","link":"https://aotu.io/notes/2019/07/10/taro-hooks/","description":"本文由余澈在 GMTC 全球大前端技术 2019 的演讲：《使用 React Hooks 重构你的小程序》整理而成。 背景一直关注小程序开发的朋友应该会注意到，最开始小程序就是为了微型创新型业务打造的一个框架，最多只能运行 1m 的包。可是后来发现很多厂商把越来越多的业务搬到了小程序上，小程序的能力也在不断地开放，变得越来越强大。于是后来打包限制上升到了 2m，然后引入了分包，现在已经已经可以上传 8m 的小程序。其实这个体积已经可以实现非常巨型非常复杂的业务了。就从 Taro 的用户来看，例如京东购物小程序和 58 同城小程序不管从代码的数量还是复杂度都不亚于 PC 端业务，所以我们可以说前端开发的复杂度正在向小程序端转移。 而小程序开发其实也是前端开发的一个子集，在整个前端业界，我们又是怎么解决复杂度这个问题的呢？ 首先我们看看 React：React Core Team 成员，同时也是 Redux 的作者 Dan Abramov 在 2018 年的 ReactConf 向大家首次介绍了 React Hooks。React Hooks 是为了解决 Class Component 的一些问题而引入的： Class Component 组件间的逻辑难以复用。因为 JavaScript 不像 Go 或 C++ 一样，Class 可以多重继承，类的逻辑的复用就成了一个问题； 复杂组件难以理解。Class Component 经常会在生命周期做一些数据获取事件监听的副作用函数，这样的情况下我们就很难把组件拆分为更小的力度； Class 令人迷惑。很多新手应该会被 Class 组件绑定事件的 this 迷惑过，绑定事件可以用 bind，可以直接写箭头函数，也可以写类属性函数，但到底哪种方法才是最好的呢？而到了 ES 2018，class 还有多种语法，例如装饰器，例如 private fileds 这些奇奇怪怪的语法也为新手增加了更多的困惑。 而对于 Vue 而言也有相同的问题，Vue 的作者尤玉溪老师在 VueConf China 2019 也给 Vue 3.0 引入了一个叫 Functional-based API 的概念，它是受 React Hooks 启发而增加的新 API。由于 Vue 2.0 组件组合的模式是对象字面量形式，所以 Functional-based API 可以作为 Mixins 的替代，配合新的响应式 API 作为新的组件组合模式。那么对于 Vue 3.0 我们还知之甚少，以后的 API 也有可能改变，但或许是英雄所见略同，React 和 Vue 对于降低前端开发复杂度这一问题都不约而同地选择了 Hooks 这一方案，这到底是为什么呢？ 我们可以一下之前的组件组合方案，首先是 Mixins，红色圈的 Mixins，黄色的是组件，我们知道 Mixins 其实就是把多个对象组合成一个对象，Mixins 的过程就有点像调用 Object.assgin 方法。那 Mixins 有什么问题呢？首先是命名空间耦合，如果多个对象同名参数，这些参数就会耦合在一起；其次由于 Mixins 必须是运行时才能知道具体有什么参数，所以是 TypeScript 是无法做静态检查的；第三是组件参数不清晰，在 Mixins 中组件的 props 和其他参数没什么两样，很容易被其它的 Mixins 覆盖掉。 为了解决 Mixins 的问题，后来发展出了高阶组件（HOC）的方式，高阶组件就和图里一样，一个组件嵌套着另外的组件。它的确解决了 Mixins 的一些问题，例如命名空间解耦，由于每次都会生成新组件，就不存在命名空间问题了；其次它也能很好地做静态检查；但它依然没有办法处理组件 props 的问题，props 还是有可能会在高阶组件中被更改；而且它还有了新的问题，每多用一次高阶组件，都会多出一个组件实例。 最后我们来看一下 Hooks，紫色的圈圈是 Hooks，就像图里一样，Hooks 都在同一个组件里，Hooks 之间还可以相互调用。因为 Hooks 跑在一个普通函数式组件里，所以他肯定是没有命名空间的问题，同时 TypeScript 也能对普通函数做很好的静态检查，而且 Hooks 也不能更改组件的 Props，传入的是啥最后可用的就是啥；最后 Hooks 也不会生成新的组件，所以他是单组件实例。 在 Taro 1.3 版本，我们实现了一大堆特性，其中的重头戏就是 React Hooks 的支持。虽然 React Hooks 正式稳定的时间并不长，但我们认为这个特性能有效地简化开发模式，提升开发效率和开发体验。即便 Hooks 的生态和最佳实践还尚未完善，但我们相信未来 Hooks 会成为 React 开发模式的主流，也会深刻地影响其它框架未来的 API 构成。所以在 Taro 的规划中我们也把 Hooks 放在了很重要的位置。 什么是 Hooks？相信笔者扯了那么多，大家对 Hooks 应该产生了一些兴趣，那什么是 Hooks 呢？简单来说，Hooks 就是一组在 React 组件中运行的函数，让你在不编写 Class 的情况下使用 state 及其它特性。具体来说，Hooks 可以表现为以下的形式： useState 与内部状态我们可以看一个原生小程序的简单案例，一个简单计数器组件，点击按钮就 + 1，相信每位前端开发朋友都可以轻松地写一个计数器组件。但我们可以稍微改一下代码，把事件处理函数改为箭头函数。如果是这样代码就跑不了了。事实上在原生开发中 this 的问题是一以贯之的，所以我们经常要开个新变量把 this 缓存起来，叫做 self 什么的来避免类似的问题。我们之前也提到过，如果采用 ES6 的 Class 来组织组件同样也会遇到 this 指向不清晰的问题。 12345678910Page(&#123; data: &#123; count: 0 &#125;, increment: () =&gt; &#123; // 这里写箭头函数就跑不了了 this.setData(&#123; count: this.data.count + 1 &#125;) &#125;&#125;) 再来看看我们的 hooks 写法，我们引入了一个叫 useState 的函数，它接受一个初始值参数，返回一个元组，如果是写后端的同学应该对这个模式比较熟悉，就像 Koa 或者 Go 一样，一个函数返回两个值或者说叫一个元组，不过我们返回的第一个参数是当前的状态，一个是设置这个状态的函数，每次调用这个设置状态的 setState 函数都会使得整个组件被重新渲染。然后用 ES6 的结构语法把它俩解构出来使用。 然后我们在定义一个增加的函数，把他绑定到 onClick 事件上。 123456789101112131415161718function Counter () &#123; // 返回一个值和一个设置值的函数 // 每次设置值之后会重新渲染组件 const [ count, setCount ] = useState(0) function increment () &#123; setCount(count + 1) &#125; return ( &lt;View&gt; &lt;Text&gt;You clicked &#123;count&#125; times&lt;/Text&gt; &lt;Button onClick=&#123;increment&#125;&gt; Click me &lt;/Button&gt; &lt;/View&gt; )&#125; 同样是非常简单的代码。如果你熟悉 Taro 之前的版本的话就会知道这样的代码在以前的 Taro 是跑不了的，不过 Taro 1.3 之后事件传参可以传入任何合法值，你如果想直接写箭头函数或者写一个柯里化的函数也是完全没有问题的。 大家可以发现我们使用的 Hooks 就是一个非常简单非常 normal 的函数，没有 this 没有 class，没有类构造函数，没有了 this，再也不会出现那种 this、self 傻傻分不清楚的情况。 大家可以记住这个简单的计数器组件，以后之后讲的很多案例是基于这个组件做的。 useEffect 与副作用接下来我们看一个稍微复杂一些的例子，一个倒计时组件，我们点击按钮就开始倒计时，再点击就停止倒计时。在我们这个组件里有两个变量，start 用于控制是否开始计时，time 就是我们的倒计时时间。这里注意我们需要多次清除 interval，而在现实业务开发中，这个 touchStart 函数可能会复杂得多，一不小心就会提前清除 interval 或忘记清除。 123456789101112131415161718192021Page(&#123; data: &#123; time: 60 &#125;, start: false, toggleStart () &#123; this.start = !this.start if (this.start) &#123; this.interval = setInterval(() =&gt; &#123; this.setData(&#123; time: this.data.time - 1 &#125;) &#125;, 1000) &#125; else &#123; clearInterval(this.interval) &#125; &#125;, onUnload () &#123; clearInterval(this.interval) &#125;&#125;) 12345&lt;view&gt; &lt;button bindtap=\"toggleStart\"&gt; &#123;&#123;time&#125;&#125; &lt;/button&gt;&lt;/view&gt; 而我们 Hooks 的例子会是这样：我们引入了一个 useEffect 函数。之前我们提到过，每次调用 useState 返回的 setState 函数都会重新调用整个函数，其实就包括了 useEffect 函数，useEffect 接受两个参数。第一个就是副作用，也就是 effect 函数，他不接受也不返回任何参数。第二个参数是依赖数组，当数组中的变量变化时就会调用，第一个参数 effect 函数。Effect 函数还可以返回一个函数，这个函数在下一次 effect 函数被调用时或每次组件被注销时或者就会调用，我们可以在这里清楚掉一些事件的订阅或者 interval 之类可能会导致内存泄露的行为。在我们这个例子中，当 start 每次变化就会重新跑一次 effect 函数，每隔一秒会设置一次 time 的值让它减一，但这样的写法是有问题的。 123456789101112131415161718192021function Counter () &#123; const [ start, setStart ] = useState(false) const [ time, setTime ] = useState(60) useEffect(() =&gt; &#123; // effect 函数，不接受也不返回任何参数 let interval if (start) &#123; interval = setInterval(() =&gt; &#123; // setTime(time - 1) ❌ time 在 effect 闭包函数里是拿不到准确值的 setTime(t =&gt; t -1) // ✅ 在 setTime 的回调函数参数里可以拿到对应 state 的最新值 &#125;, 1000) &#125; return () =&gt; clearInterval(interval) // clean-up 函数，当前组件被注销时调用 &#125;, [ start ]) // 依赖数组，当数组中变量变化时会调用 effect 函数 return ( &lt;View&gt; &lt;Button onClick=&#123;() =&gt; setStart(!start)&#125;&gt;&#123;time&#125;&lt;/Button&gt; &lt;/View&gt; )&#125; 因为我们在 setInterval 这个函数的闭包中，我们捕捉到 time 这个变量的值不能和最新的值对应得上，time 的值有可能在我们意料之外地被更改了多次。解决的方案也很简单，之前我们提到过 useState 返回的 setState 方法，可以接受一个函数作为参数，而这个函数的参数，就是 state 最新的值，所以只要我们传入一个函数就好了。这是其中一种方法。 还有另一种方法是使用 useRef Hooks，useRef 可以返回一个可变的引用，它会生成一个对象，对象里这个有 current 属性，而 current 的值是可变的。在我们这个例子里，每次更改 currentTime.current 都是同步的，而且 currentTime 是一个引用，所以 currentTime.current 一定是可控的。 123456789101112131415161718192021function Counter () &#123; const [ start, setStart ] = useState(false) const [ time, setTime ] = useState(60) const currentTime = useRef(time) // 生成一个可变引用 useEffect(() =&gt; &#123; // effect 函数，不接受也不返回任何参数 let interval if (start) &#123; interval = setInterval(() =&gt; &#123; setTime(currentTime.current--) // currentTime.current 是可变的 &#125;, 1000) &#125; return () =&gt; clearInterval(interval) // clean-up 函数，当前组件被注销时调用 &#125;, [ start ]) // 依赖数组，当数组中变量变化时会调用 effect 函数 return ( &lt;View&gt; &lt;Button onClick=&#123;() =&gt; setStart(!start)&#125;&gt;&#123;time&#125;&lt;/Button&gt; &lt;/View&gt; )&#125; 虽然说我们可以 useRef 来解决这个问题，但是没必要这样做。因为 setTime 传递一个回调函数的方法显然可读性更高。真正有必要的是把我们的 interval 变量作为一个 ref，我们在函数最顶层的作用域把 interval 作为一个 ref，这样我们就可以在这个函数的任何一个地方把他清除，而原来的代码中我们把 interval 作为一个普通的变量放在 effect 函数里，这样如果我们有一个事件也需要清除 interval，这就没法做到了。但是用 useRef 生成可变引用就没有这个限制。 1234567891011121314151617181920function Counter () &#123; const [ start, setStart ] = useState(false) const [ time, setTime ] = useState(60) const interval = useRef() // interval 可以在这个作用域里任何地方清除和设置 useEffect(() =&gt; &#123; // effect 函数，不接受也不返回任何参数 if (start) &#123; interval.current = setInterval(() =&gt; &#123; setTime(t =&gt; t - 1) // ✅ 在 setTime 的回调函数参数里可以拿到对应 state 的最新值 &#125;, 1000) &#125; return () =&gt; clearInterval(interval.current) // clean-up 函数，当前组件被注销时调用 &#125;, [ start ]) // 依赖数组，当数组中变量变化时会调用 effect 函数 return ( &lt;View&gt; &lt;Button onClick=&#123;() =&gt; setStart(!start)&#125;&gt;&#123;time&#125;&lt;/Button&gt; &lt;/View&gt; )&#125; useContext 与跨组件通信接下来我们再来看一个跨组件通信的例子，例如我们有三个组件，page 组件有一个 child 组件，child 组件有一个 counter 组件，而我们 counter 组件的 count 值和 setCount 函数，是由 page 组件传递下来的。这种情况在一个复杂业务的开发中也经常能遇到，在原生小程序开发中我们应该怎么做呢？ 我们需要手动的把我们 counter 的值和函数手动地依次地传递下去，而这样的传递必须是显式的，你需要在 JavaScript 中设置 props 的参数，也需要在 WXML 里设置 props 的参数，一个也不能少，少了就跑不动。我们还注意到即便 child 组件没有任何业务逻辑，他也必须要设置一个 triggerEvent 的函数和 props 的类型声明。这样的写法无疑是非常麻烦而且限制很大的。 1234567891011121314151617181920&lt;!-- page.wxml --&gt;&lt;view&gt; &lt;child /&gt;&lt;/view&gt;&lt;!-- child.wxml --&gt;&lt;view&gt; &lt;counter /&gt;&lt;/view&gt;&lt;!-- counter.wxml --&gt;&lt;view&gt; &lt;text&gt; You clicked &#123;&#123;count&#125;&#125; times &lt;/text&gt; &lt;butto bindtap=\"increment\"&gt; Click me &lt;/button&gt;&lt;/view&gt; 1234567891011121314151617181920212223242526272829303132333435// page.jsPage(&#123; data: &#123; count: 0 &#125;, increment () &#123; this.setData(&#123; count: this.data.count + 1 &#125;) &#125;&#125;)// child.jsComponent(&#123; properties: &#123; count: Number &#125;, methods: &#123; increment () &#123; this.triggerEvent('increment') &#125; &#125;&#125;)// counter.jsComponent(&#123; properties: &#123; count: Number &#125;, methods: &#123; increment () &#123; this.triggerEvent('increment') &#125; &#125;&#125;) 而我们可以看看 Hooks 的写法，首先我们用 Taro.createContext 创建一个 context 对象，在我们 page 组件里把我们的 count 和 setCount 函数作为一个对象传入到 Context.Provider 的 value 里。然后在我们的 Counter 组件，我们可以使用 useContext 这个 Hooks 把我们的 count 和 setCount 取出来，就直接可以使用了。 12345678910111213141516171819202122232425262728293031323334export const CounterContext = Taro.createContext(null);// page.jsconst Page = () =&gt; &#123; const [ count, setCount ] = useState(0) return ( &lt;CounterContext.Provider value=&#123;&#123; count, setCount &#125;&#125;&gt; &lt;Child /&gt; &lt;/CounterContext.Provider&gt; );&#125;;// child.jsconst Child = () =&gt; ( &lt;View&gt; &lt;Counter /&gt; &lt;/View&gt;);// counter.jsconst Counter = () =&gt; &#123; const &#123; count, setCount &#125; = useContext(CounterContext) return ( &lt;View&gt; &lt;Text&gt; You clicked &#123;count&#125; times &lt;/Text&gt; &lt;Button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/Button&gt; &lt;/View&gt; )&#125; 大家可以发现使用 Context 的代码比原来的代码精简了很多，参数不需要一级一级地显式传递，child 组件也和事实一样，没有一行多余的逻辑。但精简不是最大的好处。最大的好处是大家可以发现我们的 Context 可以传递一个复杂的对象，熟悉小程序原生开发的同学可能会知道，所有 props 的传递都会被小程序序列化掉，如果传递了一个复杂的对象最终会变成一个 JSON。但是用 Taro 的 context 则没有这层限制，你可以传入一个带有函数的对象，也可以传入像是 imutabale 或者 obserable 这样复杂的对象。在 taro 1.3 我们对 props 系统进行了一次重构，Taro 的 context 和 props 一样，属性传递没有任何限制，想传啥就传啥。 另外一个值得注意的点的是，context 的传递可以无视父级组件的更新策略，在这个例子中即便我们通过 shouldComponentUpdate() 禁止了 child 组件的更新，但 counter 作为它的子组件依然是可以更新的。这个特性可以让我们做性能优化的时候更为灵活一些。 Hooks 在小程序实战讲完了 Hooks 的基本使用，有些同学会觉得：咦，我怎么觉得你这几个东西感觉平平无奇，没什么特别的。但实际上这些基础的 Hooks 单独拿出来看的确不能玩出什么花样，但他们组合起来却能迸发强大的力量。 自定义 Hooks大家在业务开发可能会遇到这样的需求，实现一个双击事件，如果你是从 H5 开发过来的可能会直接写 onDoubleClick，但很遗憾，小程序组件是没有 doubleClick 这个事件的。当然，如果你使用 Taro 又用了 TypeScript 就不会犯这样的错误，编辑器就回直接给你报错 Text 组件没有这个属性。 于是你就自己实现了一个双击事件，代码大概是这样，有一个上次点击的时间作为状态，每次触发单机事件的时候和上次点击的时间做对比，如果间隔过小，那他就是一个双击事件。代码非常简单，但我们不禁就会产生一个问题问题，每一次给一个组件加单击事件，我们就每次都加这么一坨代码吗？ 12345678910111213141516171819202122232425function EditableText (&#123; title &#125;) &#123; const [ lastClickTime, setClickTime ] = useState(0) const [ editing, setEditing ] = useState(false) return ( &lt;View&gt; &#123; editing ? &lt;TextInput editing=&#123;editing&#125; /&gt; : &lt;Text onClick=&#123;e =&gt; &#123; const currentTime = e.timeStamp const gap = currentTime - lastClickTime if (gap &gt; 0 &amp;&amp; gap &lt; 300) &#123; // double click setEditing(true) &#125; setClickTime(currentTime) &#125;&#125; &gt; &#123;title&#125; &lt;/Text&gt; &#125; &lt;/View&gt; )&#125; 这个时候我们就可以写一个自定义 Hooks，代码和原来的代码也差不多，useDoubleClick 不接受任何参数，但当我们调用 useDoubleClick 时候返回一个名为 textOnDoubleClick 的函数，在在 Text 组件的事件传参中，我们再在 textOnDoubleClick 函数中传入一个回调函数，这个回调函数就是触发双击条件时候的函数。当我们给这个自定义 Hooks 做了柯里化之后，我们就可以做到知道 Hook 使用时才暴露回调函数: 123456789101112131415161718192021222324252627282930313233function useDoubleClick () &#123; const [ lastClickTime, setClickTime ] = useState(0) return (callback) =&gt; (e) =&gt; &#123; const currentTime = e.timeStamp const gap = currentTime - lastClickTime if (gap &gt; 0 &amp;&amp; gap &lt; 300) &#123; callback &amp;&amp; callback(e) &#125; setClickTime(currentTime) &#125;&#125;function EditableText (&#123; title &#125;) &#123; const [ editing, setEditing ] = useState(false) const textOnDoubleClick = useDoubleClick() return ( &lt;View&gt; &#123; editing ? &lt;TextInput editing=&#123;editing&#125; /&gt; : &lt;Text onClick=&#123;textOnDoubleClick(() =&gt; setEditing(true) )&#125; &gt; &#123;title&#125; &lt;/Text&gt; &#125; &lt;/View&gt; )&#125; 柯里化函数好像有一点点绕，但一旦我们完成了这一步，这种我们的自定义 hooks 就可以像多次调用： 123456789101112131415function EditableText (&#123; title &#125;) &#123; const textOnDoubleClick = useDoubleClick() const buttonOnDoubleClick = useDoubleClick() // 任何实现单击类型的组件都有自己独立的双击状态 return ( &lt;View&gt; &lt;Text onClick=&#123;textOnDoubleClick(...)&#125;&gt; &#123;title&#125; &lt;/Text&gt; &lt;Button onClick=&#123;buttonOnDoubleClick(...)&#125; /&gt; &lt;/View&gt; )&#125; 每一个大家不妨试想如果按照我们传统的 render props 实现，每次都要多写一个 container 组件，如果用 Mixins 或高阶组件来实现就更麻烦，我们需要基于每个不同类型的组件创造一个新的组件。而使用 Hooks，任何一个实现了单机类型的组件都可以通过我们的自定义 Hook 实现双击效果，不管从它的内部实现来看，还是从它暴露的 API 来看都是非常优雅的。 性能优化接下来我们谈一下性能优化，相信大家也有过这种情况，有一个数组，他只需拿到他的 props 要渲染一次，从此之后他就再也不需要更新了。对于传统而言的 Class Component 我们可以设置 shouldComponentUpdate() 返回 false。 12345678910111213class Numbers extends Component &#123; shouldComponentUpdate () &#123; return false &#125; render () &#123; return &lt;View&gt; &#123; expensive(this.props.array).map(i =&gt; &lt;View&gt;&#123;i&#125;&lt;/View&gt;) &#125; &lt;/View&gt; &#125;&#125; 而对于函数式组件而言，我们也可以做一样的事情。Taro 和 React 一样提供 Taro.memo API，他的第一个参数接受一个函数式组件，第二个参数和我们的 shouldComponentUpdate() 一样，判断组件在什么样的情况下需要更新。如果第二个参数没有传入的话，Taro.memo 的效果就和 Taro.PureComponent 一样，对新旧 props 做一层浅对比，如果浅对比不相等则更新组件。 12345678910111213function Numbers (&#123; array &#125;) &#123; return ( &lt;View&gt; &#123; expensive(array).map( i =&gt; &lt;View&gt;&#123;i&#125;&lt;/View&gt; ) &#125; &lt;/View&gt; )&#125;export default Taro.memo(Numbers, () =&gt; true) 第二种情况我们可以看看我们的老朋友，计数器组件。但是这个计数器组件和老朋友有两点不一样：第一是每次点击 + 1，计数器需要调用 expensive 函数循环 1 亿次才能拿到我们想要的值，第二点是它多了一个 Input 组件。在我们真实的业务开发中，这种情况也很常见：我们的组件可能需要进行一次昂贵的数据处理才能得到最终想要的值，但这个组件又还有多个 state 控制其它的组件。在这种情况下，我们如果正常书写业务逻辑是有性能问题的： 123456789101112131415161718192021function Counter () &#123; const [ count, setCount ] = useState(0) const [val, setValue] = useState('') function expensive() &#123; let sum = 0 for (let i = 0; i &lt; count * 1e9; i++) &#123; sum += i &#125; return sum &#125; return ( &lt;View&gt; &lt;Text&gt;You clicked &#123;expensive()&#125; times&#125;&lt;/Text&gt; &lt;Button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/Button&gt; &lt;Input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.detail.value)&#125; /&gt; &lt;/View&gt; )&#125; 因为我们 count 的值跟 Input 的值没有关系，但我们每次改变 Input 的值，就会触发这个组件重新渲染。也就是说这个循环一亿次的 expensive() 函数就会重新调用。这样情况显然是不能接受的。为了解决这个问题，我们可以使用 useMemo API。useMemo 的签名和 useEffect 有点像，区别就在于 useMemo 的第一个函数有返回值，这个函数返回的值同时也是 useMemo 函数的返回值。而第二个参数同样是依赖数组，只有当这个数组的数据变化时候，useMemo 的函数才会重新计算，如果数组没有变化，那就直接从缓存中取数据。在我们这个例子里我们只需要 count 变化才进行计算，而 Input value 变化无需计算。 123456789101112131415161718192021function Counter () &#123; const [ count, setCount ] = useState(0) const [val, setValue] = useState('') const expensive = useMemo(() =&gt; &#123; let sum = 0 for (let i = 0; i &lt; count * 100; i++) &#123; sum += i &#125; return sum &#125;, [ count ]) // ✅ 只有 count 变化时，回调函数才会执行 return ( &lt;View&gt; &lt;Text&gt;You Clicked &#123;expensive&#125; times&lt;/Text&gt; &lt;Button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/Button&gt; &lt;Input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.detail.value)&#125; /&gt; &lt;/View&gt; )&#125; 我们刚才提到的两个 memo 的 API ，他的全称其实是 Memoization。由于 Hooks 都是在普通函数中运行的，所以我们要做好性能优化，一定要好好利用缓存和记忆化这一技术。 在计算机科学中，记忆化（Memoization）是一种提高程序运行速度的优化技术。通过储存大计算量函数的返回值，当这个结果再次被需要时将其从缓存提取，而不用再次计算来节省计算时间。 大规模状态管理提到状态管理，React 社区最有名的工具当然是 Redux。在 react-redux@7 中新引用了三个 API: useSelector。它有点像 connect() 函数的第一个参数 mapStateToProps，把数据从 state 中取出来； useStore 。返回 store 本身； useDispatch。返回 store.dispatch。 在 Taro 中其实你也可以使用我们之前提到过的 createContext 和 useContext 直接就把 useStore 和 useDispatch 实现了。而基于 useStore 和 useDispatch 以及 useState，useMemo，useEffect 也可以实现 useSelector。也就是说 react-redux@7 的新 API 全都是普通 Hooks 构建而成的自定义 Hooks。当然我们也把 react-redux@7 的新功能移植到了 @tarojs/redux，在 Taro 1.3 版本你可以直接使用这几个 API。 Hooks 的实现我们现在对 Hooks 已经有了以下的了解，一个合法的 Hooks ，必须满足以下需求才能执行: 只能在函数式函数中调用 只能在函数最顶层中调用 不能在条件语句中调用 不能在循环中调用 不能在嵌套函数中调用 我想请大家思考一下，为什么一个 Hook 函数需要满足以上的需求呢？我想请大家以可以框架开发者的角度去思考下这个问题，而不是以 API 的调用者的角度去逆向地思考。当一个 Hook 函数被调用的时，这个 Hook 函数的内部实现应该可以访问到当前正在执行的组件，但是我们的 Hooks API 的入参却没有传入这个组件，那究竟是怎么样的设计才可以让我们的 hook 函数访问到正在执行的组件，也能够准确地定位自己呢？ 聪明的朋友或许已经猜到了，这些所有线索都指向一个结果，Hooks 必须是一个按顺序执行的函数。也就是说，不管整个组件执行多少次，渲染多少次，组件中 Hooks 的顺序都是不会变的。 我们还知道另外一条规则，Hooks 是 React 函数内部的函数，于是我们就可以知道，要实现 Hooks 最关键的问题在于两个: 找到正在执行的 React 函数 找到正在执行的 Hooks 的顺序。 我们可以设置一个全局的对象叫 CurrentOwner，它有两个属性，第一个是 current，他是正在执行的 Taro 函数，我们可以在组件加载和更新时设置它的值，加载或更新完毕之后再设置为 null；第二个属性是 index，它就是 CurrentOwner.current 中 Hooks 的顺序，每次我们执行一个 Hook 函数就自增 1。 1234567891011const CurrentOwner: &#123; current: null | Component&lt;any, any&gt;, index: number&#125; = &#123; // 正在执行的 Taro 函数, // 在组件加载和重新渲染前设置它的值 current: null, // Taro 函数中 hooks 的顺序 // 每执行一个 Hook 自增 index: 0&#125; 在 React 中其实也有这么一个对象，而且你还可以使用它，它叫做 __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner，也就是说如果你想给 React 15 实现 Hooks，其实也可以做到的。但也正如它的名字一样，如果你用了说不定就被 fire 了，被优化了，所以更好的方案还是直接使用我们 taro。 接下来我们来实现我们的 getHook 函数，同样很简单，如果 CurrenOwner.current 是 null，那这就不是一个合法的 hook 函数，我们直接报错。如果满足条件，我们就把 hook 的 index + 1，接下来我们把组件的 Hooks 都保存在一个数组里，如果 index 大于 Hooks 的长度，说明 Hooks 没有被创造，我们就 push 一个空对象，避免之后取值发生 runtime error。然后我们直接返回我们的 Hook。 1234567891011function getHook (): Hook &#123; if (CurrentOwner.current === null) &#123; throw new Error(`invalid hooks call: hooks can only be called in a taro component.`) &#125; const index = CurrentOwner.index++ // hook 在该 Taro 函数中的 ID const hooks: Hook[] = CurrentOwner.current.hooks // 所有的 hooks if (index &gt;= hooks.length) &#123; // 如果 hook 还没有创建 hooks.push(&#123;&#125; as Hook) // 对象就是 hook 的内部状态 &#125; return hooks[index] // 返回正在执行的 hook 状态&#125; 既然我们已经找到了我们正在执行的 Hooks，完整地实现 Hooks 也就不难了。之前我们讨论过 useState 的签名，现在我们一步一步地看他的实现。 首先如果 initState 是函数，直接执行它。其次调用我们我们之前写好的 getHook 函数，它返回的就是 Hook 的状态。接下来就是 useState 的主逻辑，如果 hook 还没有状态的话，我们就先把正在执行的组件缓存起来，然后 useState 返回的，就是我们的 hook.state, 其实就是一个数组，第一个值当然就是我们 initState，第一个参数是一个函数，它如果是一个函数，我们就执行它，否则就直接把参数赋值给我们 的 hook.state 第一个值，赋值完毕之后我们把当前的组件加入到更新队列，等待更新。 1234567891011121314151617function useState&lt;S&gt; (initialState: S | (() =&gt; S)): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;] &#123; if (isFunction(initialState)) &#123; // 如果 initialState 是函数 initialState = initialState() // 就直接执行 &#125; const hook = getHook() as HookState&lt;S&gt; // 找到该函数中对应的 hook if (isUndefined(hook.state)) &#123; // 如果 hook 还没有状态 hook.component = Current.current! // 正在执行的 Taro 函数，缓存起来 hook.state = [ // hook.state 就是我们要返回的元组 initialState, (action) =&gt; &#123; hook.state[0] = isFunction(action) ? action(hook.state[0]) : action enqueueRender(hook.component) // 加入更新队列 &#125; ] &#125; return hook.state // 已经创建 hook 就直接返回&#125; 最后我们把 hook.state 返回出去就大功告成了。 Taro 的 Hooks 总共有八个 API， useState 的实现大家可以发现非常简单，但其实它的代码量和复杂度是所有 Hooks 的实现中第二高的。所以其实 Hooks 也没有什么黑科技，大家可以放心大胆地使用。 总结与展望在 2018 年 Ember.js 的作者提出过一个观点，Compilers are the New Frameworks，编译器即框架。什么意思呢？就拿 React 来举例，单单一个 React 其实没什么用，你还需要配合 create-react-app, eslint-plugin-react-hooks, prettier 等等编译相关的工具最终才能构成一个框架，而这些工具也恰巧是 React Core Team 的人创造的。而这样趋势不仅仅发生在 React 身上，大家可以发现在2018年，尤玉溪老师的主要工作就是开发 vue-cli。而对一些更激进的框架，例如 svelte，它的框架就是编译器，编译器就是框架。 而到了 2019 年，我想提出一个新概念，叫框架即生态。就拿 Taro 来说，使用 Taro 你可以复用 React 生态的东西，同时 Taro 还有 taro doctor，Taro 开发者社区，Taro 物料市场，还有腾讯小程序·云开发等等多个合作伙伴一起构成了 Taro 生态，而整个 Taro 生态才是框架。在过去的半年，我们持续改进并优化了 Taro 框架的表现，以上提到的特性与功能在 Taro 1.3 全部都可以正常使用。而在框架之外，我们也深耕社区，推出了 Taro 物料市场和 Taro 开发者社区，并和腾讯小程序·云开发合作举办了物料开发竞赛。现在，我们诚挚邀请你一起来参与社区贡献，让小程序开发变得更好、更快、更方便： Taro 官网：https://taro.jd.com/ Taro 物料市场：https://taro-ext.jd.com/ Taro 开发者社区：https://taro-club.jd.com/","pubDate":"Wed, 10 Jul 2019 13:00:00 GMT","guid":"https://aotu.io/notes/2019/07/10/taro-hooks/","category":"小程序"},{"title":"邀您参加「Taro x 小程序·云开发」物料开发竞赛","link":"https://aotu.io/notes/2019/07/01/taro-ext-action/","description":"多端统一开发解决方案 Taro 是由凹凸实验室开源、遵循 React 语法规范的多端开发解决方案，截止目前 star 数即将突破两万，受到了前端开发者的广泛关注，成为了当前最受欢迎的小程序多端开发框架之一。开发者只需书写一套代码，通过 Taro 的编译，即可将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动/QQ/快应用小程序、H5、React-Native 等）运行的代码，很大程度提高了小程序的开发效率和开发体验。 小程序·云开发提供的一站式开发服务。打通了小程序前端与云资源的链路，让开发者无需管理后端服务架构，即可轻松拥有各种后端能力，极大减轻开发过程中繁杂的后端操作，使小程序开发更简单。告别以前开发小程序需要买服务器、部署后端服务、搭建运维服务等繁琐工作。 随着 Taro 受到越来越多的关注，也涌现了许多 优秀案例 和优秀轮子，他们分散各处，我们希望有个集中的地方让大家快速查找，方便地使用这些轮子而不用重复制造，因此推出了 Taro 物料市场，大家可以分享、学习或使用。 Taro 团队和腾讯云团队一直有着深入的合作，我们可以看到在 Taro 项目初始化的时候提供了“云开发模板”；在 Taro 掘金小册里介绍和使用小程序云开发；在腾讯云的高校公开课里有 Taro 的参与…… 值物料市场上线之际，Taro 团队和腾讯云团队再次合作，联合举办此次 Taro x 小程序·云开发物料上传激励活动 ，Taro 的开发者们只要上传 Taro 开发的包含腾讯云开发能力（例如：云数据库、云存储、云函数）的物料，就可以参与活动，并有机会赢得奖品。 活动时间及评奖方式： 即日起至 2019 年 07 月 30 日，提交物料并被审核通过。 2019 年 8 月 1 日 - 8 月 10 日，竞赛评委将根据物料的完整性、可用性、多端兼容性、评分、下载量、Github Star 等综合权重打分，评选出此次活动的获奖者。 2019 年 8 月 12 日，公布获奖名单，获奖者发送地址给 Taro 团队，Taro 团队按地址发放奖品。 说明：目前物料市场上管理员已经上传的物料欢迎原作者认领。（原作者只需上传自己的物料，管理员看到后会把管理员上传的删除） 奖品设置：一等奖（ 1 名）： 腾讯云代金券3000元 腾讯云精美电脑包 1 个（颜色随机） 凹凸实验室珍藏 T 恤 1 件 二等奖（ 2 名）： 腾讯云代金券1500元 腾讯云Q版蓝牙音箱 1个（颜色随机） 凹凸实验室珍藏 T 恤 1 件 三等奖（ 3 名）： 腾讯云代金券500元 腾讯云抱枕 1 个 凹凸实验室珍藏 T 恤 1 件 参与奖（不限名额）： 腾讯云定制公仔 或 京东Joy公仔 1 个 其他 获奖作者将进入核心开发者交流群，享受 Taro 和云开发核心开发者提供优先的技术支持和 bug 受理。 优秀的作品和获奖作者将得到宣传报道，有助于为简历资质添彩。 参赛方式 登录物料市场 https://taro-ext.jd.com 点击 「发布物料」 填入物料相关信息并提交发布 物料有多种类型，包含组件、项目模版或页面模版、JS SDK、UI库，都可以参与活动，要求使用 Taro 开发 和 小程序·云开发 评委人员 Taro 核心开发团队 小程序云开发 核心开发团队 Taro 联合开发团队 黄轶 Zoom · 前端架构师 许世超 网易严选 · 前端负责人 吴立奇 美的 · 美的官方商城核心开发 · 小程序‘轻松问卷’开发者 其他注意事项 提交的物料都会经过后台审核 完整性、可用性是比较重要的参考维度 感谢感谢腾讯云小伙伴的支持，为我们提供了奖品，欢迎大家体验腾讯云产品。 声明本活动解释权归 Taro 团队和腾讯云团队 相关网址： Taro 官网：https://taro.jd.com Taro 物料市场: https://taro-ext.jd.com Taro 社区：https://taro-club.jd.com GitHub: https://github.com/NervJS/taro","pubDate":"Mon, 01 Jul 2019 13:00:00 GMT","guid":"https://aotu.io/notes/2019/07/01/taro-ext-action/","category":"小程序"},{"title":"Taro 「物料市场」及「交流社区」 惊喜上线","link":"https://aotu.io/notes/2019/06/21/taro-ext-club/","description":"多端统一开发框架 Taro 自 2018 年 6 月开源以来，一直受到业界的广泛关注和支持。 目前，Taro GitHub star 数已经突破了 1.8W。作为研发团队，我们为取得的成绩感到欣喜，但也始终不忘初心。一直以来，我们对 Taro 框架不断完善和优化，近期也即将发布全新的大版本（Taro 1.3），将提供快应用和 QQ 小程序的开发支持，React Hooks 支持，Taro Doctor 等重大特性 (详情)。而与此同时，我们也马不停蹄，对 Taro 进行了全方位的升级，希望给大家带来小小的惊喜。 我们不仅带来了焕然一新的 Taro 官网，还一次性推出了 Taro 物料市场 和 Taro 开发者社区。帮助 Taro 实现从 多端统一开发框架 到 多端统一开发解决方案 的转型。 Taro 物料市场：https://taro-ext.jd.com/Taro 开发者社区：https://taro-club.jd.com/ 物料市场 — “让每一个轮子产生价值”随着 Taro 受到越来越多的关注，许多 Taro 项目也正式投入生产，涵盖包括 电商、工具、服务 等多种类型，也涌现了许多优秀案例。 但项目开发中，开发者都不得不面临重复的逻辑开发，对现有的逻辑进行 Taro 代码的适配等问题，严重影响开发效能。 开源的时代，我们不希望闭门造车，我们诚邀开发者们共同打造完整的 多端适配 生态，一起沉淀优秀的开发物料，进而赋能更多的开发者。 因此，物料市场应运而生。 我们将物料划分为 4 个大类：组件、UI 库、模版、SDK。每个物料都配有说明文档，并对支持的端进行标记，方便接入使用。 物料的获取方式也相当灵活，可通过 ZIP/TAR 包下载，也可直接通过作者提供的 NPM 或 GitHub 地址下载。 此外，还可以对物料进行评论、收藏和打分，这将作为衡量物料质量的一个指标，为筛选物料提供参考。 后续，我们将加入打赏功能，开发者通过发布优质的物料，给与别人便利的同时，自己可以收获一定的奖励。此外，我们还会不断完善物料质量评定标准，制定用户积分体系，等等。这都将促进整个生态更加健康而全面的发展。 如果你对物料市场有任何建议，或有意愿参与物料市场的建设，欢迎随时与我们联系：taro@jd.com。 开发者社区 — “让每一次交流被沉淀”目前，Taro 共收到了 2k 多个 GitHub Issue，并建立了十多个开发交流微信群（每个群上限人数 500）。 我们希望与开发者进行及时且顺畅的交流，更希望每一次的问题答疑、经验交流都能被沉淀，分享给更多开发者，同时，我们渴望开发者之间可以开放互助，因此我们打造了一个全新的开发者社区。 开发者可通过社区多个版块交流问题、共享经验、发布案例，等等。 Taro 社区基于 NodeBB 开发，共设有 12 个版块，包括 Taro、Taro UI 及其对应转换的 8 个端，有效地对内容做了归类。此外，还设置了 新闻 版块，用于发布 Taro 新闻、公告、规划等；招聘 版块，让 Taro 求职者和招聘者快速匹配；灌水 版块，提供一个健康文明的交流（you）平台。 为了加强社区内容的管理，我们沉淀了一套自动化的社区管理解决方案：通过智能分析微信群聊记录，对有效信息进行筛选和整合，自动同步至社区；并使用插件 GitHub Embed 将 GitHub Issue 直接导入，从而打通 GitHub、微信、社区 三方平台，旨在让社区内容更及时、更全面。 如果你对开发者社区有任何建议，或有意愿参与社区的建设与管理工作，欢迎随时与我们联系：taro@jd.com。 官网 — “全新面貌，蓄势待发”开源近一年，Taro 成长了许多。一开始，我们试图用 React 来实现微信小程序开发；而现在，我们期待的是，Taro 在移动端开发、多端适配领域可以无往不利。 Taro 正在经历由内而外的成长，因此，我们对 Taro 品牌进行了全新升级，旨在赋予其独特的品牌风格。 全新的官网将作为品牌化的一个窗口，不仅带来了全新的视觉体验，内容上更是增加了生态能力和业界合作的展示，并丰富了应用案例和学习资料，方便开发者迅速上手 Taro。 愿景这一切仅仅是起步，未来我们还将推出更多平台、工具、服务，努力将 Taro 打造为名副其实的移动端解决方案。 希望通过我们的点滴努力，创造出更好的移动端开发环境，让工作回归简单、让生活日益丰满。 相关网址： Taro 官网：https://taro.jd.com Taro 物料市场: https://taro-ext.jd.com Taro 社区：https://taro-club.jd.com GitHub: https://github.com/NervJS/taro","pubDate":"Fri, 21 Jun 2019 13:00:00 GMT","guid":"https://aotu.io/notes/2019/06/21/taro-ext-club/","category":"小程序"},{"title":"Taro 1.3 震撼升级：全面支持 JSX 语法和 HOOKS","link":"https://aotu.io/notes/2019/06/13/taro-1-3/","description":"在 Taro 1.2 发布之后，Taro 在业界收获了巨大的赞誉和关注：GitHub 上 Star 数量超过 19000 粒，NPM 下载量也稳居同类开发框架之首，同时 Taro 团队也和腾讯、百度、华为等数十家业界巨头的研发团队展开了深入和有效的合作。 Taro 1.3 是我们酝酿最久的版本：经历了横跨 6 个月的开发时间，近 2000 次的代码提交，近百位开发者的共同参与。我们终于在今天骄傲地发布了 Taro 1.3。 Taro 1.3 的特性包括但不限于： 支持快应用和 QQ 小程序的开发 全面支持 JSX 语法和 React Hooks 大幅提高 H5 性能和可用性 Taro Doctor 支持快应用和 QQ 小程序的开发快应用的开发模式非常特别，它的 API、组件系统、组件库和其他小程序端差异非常大，并且快应用只是一个标准，各家安卓厂商对运行时的实现也各不相同。而这块「硬骨头」终于也被 Taro 啃下了。 QQ 小程序作为新兴的小程序类容器，大家普遍对它知之甚少，但 Taro 也率先实现了对 QQ 小程序的支持。 支持快应用和 QQ 小程序意味着 Taro 真正对业界主流小程序实现了「全覆盖」，不管你的业务要支持哪一个小程序端，只要维护一套代码，Taro 就能生成对应小程序平台的代码。同时 Taro 也成为了业界首个同时支持微信小程序、百度智能小程序、字节跳动小程序、支付宝小程序、快应用、QQ 小程序共 6 端小程序的开发框架。 全面支持 JSX 语法和 React Hooks作为使用 React 和 JSX 语法的开发框架，Taro 早期的版本在编译器和编辑器检查工具都对语法做了高强度的限制。而在 Taro 1.3 中，开发者可以充分发挥自己的创造力和想象力，可以任意地写 if-else，可以任意地写匿名函数，可以把 JSX 放在类函数中，也可以放在普通函数中，等等。只要编译器和和 ESLint 不报错，就可以这么写。 虽然 React Hooks 正式稳定的时间并不长，但我们认为这个特性能有效地简化开发模式，提升开发效率和开发体验。即便 Hooks 的生态和最佳实践还尚未完善，但我们相信未来 Hooks 会成为 React 开发模式的主流，也会深刻地影响其它框架未来的 API 构成。所以我们优先把 React Hooks 带到了 Taro 中，还写了两个小例子展示如何在 Taro 中使用 Hooks： V2EX: https://github.com/NervJS/taro-v2ex-hooks TodoMVC: https://github.com/NervJS/taro-todomvc-hooks 全新生命周期和 Context API在 Taro 1.3 我们还实现了 React 16 的新生命周期函数 static getDerivedStateFromProps() 和 getSnapshotBeforeUpdate()。当新的生命周期函数注入到类组件时，老的生命周期函数将不会被调用，没有使用新的生命周期函数则不会影响原有生命周期的调用。就多数情况而言，我们更推荐使用新的生命周期来构建你的类组件，因为这样能减少一次渲染和更新的开销。更多详细信息可以查看相关文档。 Taro 1.3 还实现了 React 16 的 createContext、contextType 和 useContext API。新 Context 通过声明式的 API 来传递组件的更新，使得Taro 跨组件通信和共享状态更为直观。同时，例如 react-redux 这样的热门库也正在基于 Context 和 Hooks 进行重构，我们也非常期待与社区一起探索 React/Taro 新的开发与设计模式。 大幅提高 H5 性能和可用性作为除微信小程序之外需求量最高的端，我们一直都部署了重要的开发战力在 H5 端。而在 Taro 1.3 中，我们优化了编译代码的方式，实现了资源最小引入和按需引入，将原有最小项目的编译大小降低了 80% 左右。这对于网络状况不佳的 H5 端无疑是巨大的提升。 H5 端的 API 数量和质量也得到了大幅地增长，Taro 1.3 新增了 28 个 H5 API，解决了上百个 H5 相关的 issue。 关于 H5 端性能更感兴趣可以查看文章:《决战性能之巅 - Taro H5 转换与优化升级》。 Taro Doctor我们还从 Flutter Doctor 中得到启发，开发了 Taro Doctor。 Taro Doctor 就像一个医生一样，可以诊断项目的依赖、设置、结构，以及代码的规范是否存在问题，并尝试给出解决方案。 但和真正的医生不一样，Taro Doctor 不需要排队挂号，也不用花钱。你只需要在终端运行命令：taro doctor，就像图里一样： 还有更多除了以上的特性之外，Taro 1.3 还做了许多额外的工作，这些工作可能对日常开发影响不大，但为 Taro 的稳定性以及将来更多的可能性夯实了基础： 组件传参（props）系统重构在 Taro 1.0 到 1.2 的小程序端，我们一直使用原生小程序框架的组件传参系统，但小程序组件系统没办法传递函数的值，也无法传递非具名参数，并且各小程序组件的实现各不相同。为了解决这些问题，在 Taro 1.3 中我们自己实现了一套组件传参系统。新系统会使得传参相关的代码更为可靠，同时也是我们支持更多 JSX 语法的基础。 命令行工具（CLI） 重构在 Taro 1.3，我们将命令行工具使用 TypeScript 进行了重构并逐步添加更多测试用例。重构之后我们可以更加大胆地为 CLI 添加新功能，替换老旧依赖。同时我们也会将 CLI 的功能以 API 的形式暴露出来，赋能给其它开发工具和我们的合作伙伴。 移动端容器更换我们和京东的 ARES) 团队合作，把原有的移动端容器 expo 替换为深度定制的 JDReact。JDReact 大幅提升了 Taro 移动端的可控性，可以让我们突破 expo 的掣肘，引入原生移动端代码，提供定制功能和 API，并且性能和稳定性的表现都会更好。 支持开发小程序插件小程序插件是小程序带来的一个非常优秀的特性，可以极大地提高代码复用率，降低包大小，为开发者带来诸多便利，目前微信、支付宝小程序已经支持插件功能。而从 1.3 版本开始，Taro 支持直接开发微信与支付宝小程序插件，这意味着 Taro 项目将和小程序插件无缝对接，不再有开发模式切换的成本。 支持「小程序·云开发」「小程序·云开发」是微信小程序联合腾讯云团队提供的一个非常强大的功能，它是一款 Serverless 服务，为开发者提供了「云函数」、「云数据库」和「云文件存储」三大能力，并且将这些能力封装成特定的接口，可以帮助开发者快速构建微信小程序的后端服务。为了让 Taro 开发者能够享受到「小程序·云开发」的能力，Taro 也加入了对「小程序·云开发」的支持，为「小程序·云开发」提供了初始化模板，并且将小程序云相关的 API 进行了封装，方便开发者进行使用。同时，「小程序·云开发」已提供 H5 版本的 SDK，Taro 支持将小程序、H5 的调用方式进行统一封装，帮助开发者快速打造 Serverless 的多端应用。 升级兼容性正如前面所提到，Taro 1.3 是一个酝酿时间最久，拥有特性最多的大版本，对 Taro 底层也进行了不小的重构，所以，1.3 版本的升级带了以下 2 个兼容性问题。 JSX 中的事件监听函数必须绑定作用域在之前的 Taro 版本中，JSX 中绑定的事件监听函数，是可以不需要绑定任何作用域，就能访问到组件实例的，例如 123456789101112131415161718192021import Taro, &#123; Component, Config &#125; from '@tarojs/taro'import &#123; View, Button &#125; from '@tarojs/components'export default class Test extends Component &#123; state = &#123; hello: 'noclick' &#125; clickHandler () &#123; this.setState(&#123; hello: 'click' &#125;) &#125; render () &#123; return ( &lt;View className=&#123;styles.index&#125;&gt; &lt;Button onClick=&#123;this.clickHandler&#125;&gt;点击&lt;/Button&gt; &lt;/View&gt; ) &#125;&#125; 上述例子中，&lt;Button /&gt; 按钮绑定的点击事件，在之前版本中是能够正常执行的，Taro 会默认将 clickHandler 的作用域绑定为当前组件实例，但是这并不符合 React 中的实际情况，所以，在 1.3 版本中，我们对这一问题进行了修复，现在 JSX 中的事件监听函数必须绑定作用域，否则就会报错。 上述代码中 JSX 部分可以修改为如下 1234567render () &#123; return ( &lt;View className=&#123;styles.index&#125;&gt; &lt;Button onClick=&#123;this.clickHandler.bind(this)&#125;&gt;点击&lt;/Button&gt; &lt;/View&gt; )&#125; 或者你也可以在 constructor 中将函数进行提前绑定作用域， 1234567891011constructor () &#123; this.clickHandlerBind = this.clickHandler.bind(this)&#125;render () &#123; return ( &lt;View className=&#123;styles.index&#125;&gt; &lt;Button onClick=&#123;this.clickHandlerBind&#125;&gt;点击&lt;/Button&gt; &lt;/View&gt; )&#125; 还有一种做法是，将 clickHandler 写成箭头函数，这种方式在新旧版本中均可以正常运行。 暂时无法在原生应用中使用 Taro 组件在之前版本中，使用 Taro 编译后的组件是可以直接用在原生项目中的，以提升复用性，但 1.3 版本由于组件的 props 系统彻底重构了，升级 1.3 后暂时无法在原生项目中使用 Taro 组件，我们正在积极处理这个问题，在后续版本中将继续支持这一特性。 在框架之外Taro 团队除了 1.3 版本中完善多端适配，提高框架开发体验和开发效率之外，我们还在生态建设上付出了诸多努力，其中包括全新升级的官网，物料/插件市场，独立的社区/论坛。 我们认为，Taro 能够安身立命的本钱是作为开发框架的硬实力，但真正决定 Taro 能走多远却是生态、社区以及合作伙伴。我们在 1.3 已经把实力大幅增强，现在邀请你一起参与或观察 Taro 在生态和社区的建设： Taro 官网：https://taro.jd.com Taro 物料市场: https://taro-ext.jd.com Taro 社区：https://taro-club.jd.com GitHub: https://github.com/NervJS/taro","pubDate":"Thu, 13 Jun 2019 06:00:00 GMT","guid":"https://aotu.io/notes/2019/06/13/taro-1-3/","category":"小程序"},{"title":"小程序框架全面测评","link":"https://aotu.io/notes/2019/03/12/mini-program-framework-full-review/","description":"最近前端届多端框架频出，相信很多有代码多端运行需求的开发者都会产生一些疑惑：这些框架都有什么优缺点？到底应该用哪个？ 作为 Taro 开发团队一员，笔者想在本文尽量站在一个客观公正的角度去评价各个框架的选型和优劣。但宥于利益相关，本文的观点很可能是带有偏向性的，大家可以带着批判的眼光去看待，权当抛砖引玉。 那么，当我们在讨论多端框架时，我们在谈论什么： 多端笔者以为，现在流行的多端框架可以大致分为三类： 1. 全包型这类框架最大的特点就是从底层的渲染引擎、布局引擎，到中层的 DSL，再到上层的框架全部由自己开发，代表框架是 Qt 和 Flutter。这类框架优点非常明显：性能（的上限）高；各平台渲染结果一致。缺点也非常明显：需要完全重新学习 DSL（QML/Dart），以及难以适配中国特色的端：小程序。 这类框架是最原始也是最纯正的的多端开发框架，由于底层到上层每个环节都掌握在自己手里，也能最大可能地去保证开发和跨端体验一致。但它们的框架研发成本巨大，渲染引擎、布局引擎、DSL、上层框架每个部分都需要大量人力开发维护。 2. Web 技术型这类框架把 Web 技术（JavaScript，CSS）带到移动开发中，自研布局引擎处理 CSS，使用 JavaScript 写业务逻辑，使用流行的前端框架作为 DSL，各端分别使用各自的原生组件渲染。代表框架是 React Native 和 Weex，这样做的优点有： 开发迅速 复用前端生态 易于学习上手，不管前端后端移动端，多多少少都会一点 JS、CSS 缺点有： 交互复杂时难以写出高性能的代码，这类框架的设计就必然导致 JS 和 Native 之间需要通信，类似于手势操作这样频繁地触发通信就很可能使得 UI 无法在 16ms 内及时绘制。React Native 有一些声明式的组件可以避免这个问题，但声明式的写法很难满足复杂交互的需求。 由于没有渲染引擎，使用各端的原生组件渲染，相同代码渲染的一致性没有第一种高。 3. JavaScript 编译型这类框架就是我们这篇文章的主角们：Taro、WePY 、uni-app 、 mpvue 、 chameleon，它们的原理也都大同小异：先以 JavaScript 作为基础选定一个 DSL 框架，以这个 DSL 框架为标准在各端分别编译为不同的代码，各端分别有一个运行时框架或兼容组件库保证代码正确运行。 这类框架最大优点和创造的最大原因就是小程序，因为第一第二种框架其实除了可以跨系统平台之外，也都能编译运行在浏览器中。(Qt 有 Qt for WebAssembly, Flutter 有 Hummingbird，React Native 有 react-native-web, Weex 原生支持) 另外一个优点是在移动端一般会编译到 React Native/Weex，所以它们也都拥有 Web 技术型框架的优点。这看起来很美好，但实际上 React Native/Weex 的缺点编译型框架也无法避免。除此之外，编译型框架的抽象也不是免费的：当 bug 出现时，问题的根源可能出在运行时、编译时、组件库以及三者依赖的库等等各个方面。在 Taro 开源的过程中，我们就遇到过 Babel 的 bug，React Native 的 bug，JavaScript 引擎的 bug，当然也少不了 Taro 本身的 bug。相信其它原理相同的框架也无法避免这一问题。 但这并不意味着这类为了小程序而设计的多端框架就都不堪大用。首先现在各巨头超级 App 的小程序百花齐放，框架会为了抹平小程序做了许多工作，这些工作在大部分情况下是不需要开发者关心的。其次是许多业务类型并不需要复杂的逻辑和交互，没那么容易触发到框架底层依赖的 bug。 那么当你的业务适合选择编译型框架时，在笔者看来首先要考虑的就是选择 DSL 的起点。因为有多端需求业务通常都希望能快速开发，一个能够快速适应团队开发节奏的 DSL 就至关重要。不管是 React 还是 Vue（或者类 Vue）都有它们的优缺点，大家可以根据团队技术栈和偏好自行选择。 如果不管什么 DSL 都能接受，那就可以进入下一个环节： 生态以下内容均以各框架现在（2019 年 3 月 11日）已发布稳定版为标准进行讨论。 开发工具就开发工具而言 uni-app 应该是一骑绝尘，它的文档内容最为翔实丰富，还自带了 IDE 图形化开发工具，鼠标点点点就能编译测试发布。 其它的框架都是使用 CLI 命令行工具，但值得注意的是 chameleon 有独立的语法检查工具，Taro 则单独写了 ESLint 规则和规则集。 在语法支持方面，mpvue、uni-app、Taro 、WePY 均支持 TypeScript，四者也都能通过 typing 实现编辑器自动补全。除了 API 补全之外，得益于 TypeScript 对于 JSX 的良好支持，Taro 也能对组件进行自动补全。 CSS 方面，所有框架均支持 SASS、LESS、Stylus，Taro 则多一个 CSS Modules 的支持。 所以这一轮比拼的结果应该是： uni-app &gt; Taro &gt; chameleon &gt; WePY、mpvue 多端支持度只从支持端的数量来看，Taro 和 uni-app 以六端略微领先（移动端、H5、微信小程序、百度小程序、支付宝小程序、头条小程序），chameleon 少了头条小程序紧随其后。 但值得一提的是 chameleon 有一套自研多态协议，编写多端代码的体验会好许多，可以说是一个能戳到多端开发痛点的功能。uni-app 则有一套独立的条件编译语法，这套语法能同时作用于 js、样式和模板文件。Taro 可以在业务逻辑中根据环境变量使用条件编译，也可以直接使用条件编译文件（类似 React Native 的方式）。 在移动端方面，uni-app 基于 weex 定制了一套 nvue 方案 弥补 weex API 的不足；Taro 则是暂时基于 expo 达到同样的效果；chameleon 在移动端则有一套 SDK 配合多端协议与原生语言通信。 H5 方面，chameleon 同样是由多态协议实现支持，uni-app 和 Taro 则是都在 H5 实现了一套兼容的组件库和 API。 mpvue 和 WePY 都提供了转换各端小程序的功能，但都没有 h5 和移动端的支持。 所以最后一轮对比的结果是： chameleon &gt; Taro、uni-app &gt; mpvue &gt; WePY 组件库/工具库/demo作为开源时间最长的框架，WePY 不管从 Demo，组件库数量 ，工具库来看都占有一定优势。 uni-app 则有自己的插件市场和 UI 库，如果算上收费的框架和插件比起 WePy 也是完全不遑多让的。 Taro 也有官方维护的跨端 UI 库 taro-ui ，另外在状态管理工具上也有非常丰富的选择（Redux、MobX、dva），但 demo 的数量不如前两个。但 Taro 有一个转换微信小程序代码为 Taro 代码的工具，可以弥补这一问题。 而 mpvue 没有官方维护的 UI 库，chameleon 第三方的 demo 和工具库也还基本没有。 所以这轮的排序是： WePY &gt; uni-app 、taro &gt; mpvue &gt; chameleon 接入成本接入成本有两个方面： 第一是框架接入原有微信小程序生态。由于目前微信小程序已呈一家独大之势，开源的组件和库（例如 wxparse、echart、zan-ui 等）多是基于原生微信小程序框架语法写成的。目前看来 uni-app 、Taro、mpvue 均有文档或 demo 在框架中直接使用原生小程序组件/库，WePY 由于运行机制的问题，很多情况需要小改一下目标库的源码，chameleon 则是提供了一个按步骤大改目标库源码的迁移方式。 第二是原有微信小程序项目部分接入框架重构。在这个方面 Taro 在京东购物小程序上进行了大胆的实践，具体可以查看文章《Taro 在京东购物小程序上的实践》。其它框架则没有提到相关内容。 而对于两种接入方式 Taro 都提供了 taro convert 功能，既可以将原有微信小程序项目转换为 Taro 多端代码，也可以将微信小程序生态的组件转换为 Taro 组件。 所以这轮的排序是： Taro &gt; mpvue 、 uni-app &gt; WePY &gt; chameleon 流行度从 GitHub 的 star 来看，mpvue 、Taro、WePY 的差距非常小。从 NPM 和 CNPM 的 CLI 工具下载量来看，是 Taro（3k/week）&gt; mpvue (2k/w) &gt; WePY (1k/w)。但发布时间也刚好反过来。笔者估计三家的流行程度和案例都差不太多。 uni-app 则号称有上万案例，但不像其它框架一样有一些大厂应用案例。另外从开发者的数量来看也是 uni-app 领先，它拥有 20+ 个 QQ 交流群（最大人数 2000）。 所以从流行程度来看应该是： uni-app &gt; Taro、WePY、mpvue &gt; chameleon 开源建设一个开源作品能走多远是由框架维护团队和第三方开发者共同决定的。虽然开源建设不能具体地量化，但依然是衡量一个框架/库生命力的非常重要的标准。 从第三方贡献者数量来看，Taro 在这一方面领先，并且 Taro 的一些核心包/功能（MobX、CSS Modules、alias）也是由第三方开发者贡献的。除此之外，腾讯开源的 omi 框架小程序部分也是基于 Taro 完成的。 WePY 在腾讯开源计划的加持下在这一方面也有不错的表现；mpvue 由于停滞开发了很久就比较落后了；可能是产品策略的原因，uni-app 在开源建设上并不热心，甚至有些部分代码都没有开源；chameleon 刚刚开源不久，但它的代码和测试用例都非常规范，以后或许会有不错的表现。 那么这一轮的对比结果是： Taro &gt; WePY &gt; mpvue &gt; chameleon &gt; uni-app 最后补一个总的生态对比图表： 未来从各框架已经公布的规划来看： WePY 已经发布了 v2.0.alpha 版本，虽然没有公开的文档可以查阅到 2.0 版本有什么新功能/特性，但据其作者介绍，WePY 2.0 会放大招，是一个「对得起开发者」的版本。笔者也非常期待 2.0 正式发布后 WePY 的表现。 mpvue 已经发布了 2.0 的版本，主要是更新了其它端小程序的支持。但从代码提交， issue 的回复/解决率来看，mpvue 要想在未来有作为首先要打消社区对于 mpvue 不管不顾不更新的质疑。 uni-app 已经在生态上建设得很好了，应该会在此基础之上继续稳步发展。如果 uni-app 能加强开源开放，再加强与大厂的合作，相信未来还能更上一层楼。 chameleon 的规划比较宏大，虽然是最后发的框架，但已经在规划或正在实现的功能有： 快应用和端拓展协议 通用组件库和垂直类组件库 面向研发的图形化开发工具 面向非研发的图形化页面搭建工具 如果 chameleon 把这些功能都做出来的话，再继续完善生态，争取更多第三方开发者，那么在未来 chameleon 将大有可为。 Taro 的未来也一样值得憧憬。Taro 即将要发布的 1.3 版本就会支持以下功能： 快应用支持 Taro Doctor，自动化检查项目配置和代码合法性 更多的 JSX 语法支持，1.3 之后限制生产力的语法只有 只能用 map 创造循环组件 一条 H5 打包体积大幅精简 同时 Taro 也正在对移动端进行大规模重构；开发图形化开发工具；开发组件/物料平台以及图形化页面搭建工具。 结语那说了那么多，到底用哪个呢？ 如果不介意尝鲜和学习 DSL 的话，完全可以尝试 WePY 2.0 和 chameleon ，一个是酝酿了很久的 2.0 全新升级，一个有专门针对多端开发的多态协议。 uni-app 和 Taro 相比起来就更像是「水桶型」框架，从工具、UI 库，开发体验、多端支持等各方面来看都没有明显的短板。而 mpvue 由于开发一度停滞，现在看来各个方面都不如在小程序端基于它的 uni-app 。 当然，Talk is cheap。如果对这个话题有更多兴趣的同学可以去 GitHub 另行研究，有空看代码，没空看提交： chameleon: https://github.com/didi/chameleon mpvue: https://github.com/Meituan-Dianping/mpvue Taro: https://github.com/NervJS/taro uni-app: https://github.com/dcloudio/uni-app WePY: https://github.com/Tencent/wepy (按字母顺序排序)","pubDate":"Tue, 12 Mar 2019 15:09:41 GMT","guid":"https://aotu.io/notes/2019/03/12/mini-program-framework-full-review/","category":"小程序"},{"title":"决战性能之巅 - Taro H5 转换与优化升级","link":"https://aotu.io/notes/2019/02/28/taro-h5-optimize/","description":"前言作为一个多端开发框架，Taro 从项目发起时就已经支持编译到 H5 端。随着 Taro 多端能力的不断成熟，我们对 Taro H5 端应用的要求也不断提升。我们已经不再满足于“能跑”，更希望 Taro 能跑得快。 我们经常收到用户反馈：为什么使用 Taro 脚手架创建的空项目，打包后代码体积却有 400KB+；也有用户在 Issue 中提到，Taro 的部分 Api 占用空间巨大，事实上功能却并不完美，等等。作为一个开源项目，我们非常重视社区开发者们的意见。所以在最新版本中，我们对 Taro H5 端的性能表现进行了优化。 作为运行时的基础，每一个 Taro 的 H5 端应用都需要引入 @tarojs/components 和 @tarojs/taro-h5 等基础依赖包。在编译、打包之后，这些依赖包大约会在首屏占用 400KB 以上的空间。如果开发者还使用了 UI 库，例如 Taro-UI，基础体积还会更大，这严重限制了 Taro H5 端应用的性能优化空间。 事实上，我们在 H5 端应用中并不会使用到全部的 Taro 组件和 Api。将这些依赖包全部打包进应用是没有必要，也是不合理的。进行死码删除（Dead code elimination），进一步缩减代码体积，就是我们的优化方向之一。 效果在介绍具体细节之前，我们先看一看优化的效果，因为这可能会让你更有兴趣了解后面的内容。用一句话来说，效果非常显著。 我们建立了一个空项目，在项目配置中加入了webpack-bundle-analyzer插件以查看编译分析。下图是优化前的打包文件分析结果： 而在优化后，对比非常明显： 优化前生成的代码总大小为 455KB，而在优化后仅剩约 96KB，仅是原来的 1/5 左右。 你需要做什么很简单，作为使用者，你不需要做任何代码上的改动，只需要将 Taro 更新到最新版本即可。但在看不见的地方，Taro 却默默地做了许多工作。下面会从原理出发，详细介绍 Taro 的工作。 原理死码删除（Dead code elimination）是一种代码优化技术，可以删除对应用程序执行结果没有影响的代码。Web Fundamentals 的一篇文章有提到，treeshaking 是由 Rollup 提出的一种死码删除的形式。 Tree shaking is a form of dead code elimination. The term was popularized by Rollup, but the concept of dead code elimination has existed for some time. – Reduce JavaScript Payloads with Tree Shaking, Jeremy Wagner 通过在构建时进行静态分析，编译工具可以分析出我们代码中真正的依赖关系。treeshaking 把我们的代码想象成一棵树，代码的每个依赖项看作树上的节点。将未使用过的依赖项从构建结果中移除，这就是 treeshaking 的基本思想。 那么，假设我们手头有一段代码，我们要怎样辨别其中可以删除的部分呢？答案是，通过分析副作用： 123456789101112// add.jsexport default function add（a, b）&#123; return a + b; &#125;// add2.jsconsole.log('这是一个log')export default function add2（a, b）&#123; return a + b; &#125;// index.jsimport add from './add.js' // 没有副作用，可以删除import add2 from './add2.js' // 有副作用，不能直接删除// EOF 副作用这个名词对于了解函数式编程的同学肯定不陌生。修改外部状态，或者是产生输出等等，都是副作用；而存在副作用的代码，是不能被直接移除的。类似上面这个代码示意，add2 模块就是存在副作用的。 站在巨人的肩膀上除了 Rollup 之外，支持 treeshaking 的工具/插件还有很多，比如 babel-plugin-transform-dead-code-elimination、uglify、terser等。 webpack 在 v2 之后就内置了对 treeshaking 的支持，并在 webpack@4 中对 treeshaking 功能进行了扩展。 Taro H5 端在构建过程中，使用 webpack 作为构建的核心。在 webpack 中使用 treeshaking 功能有几个需要注意的地方： 如果是 npm 模块，需要package.json中存在sideEffects字段，并且准确配置了存在副作用的源代码。 必须使用 ES6 模块语法。由于诸如babel-preset-env之类的 babel 预配置包默认会对代码的模块机制进行改写，还需要将modules设置为false，将模块解析的工作直接交给 webpack。 需要工作在 webpack 的production模式下。 webpack 的 treeshaking 工作主要分为两步。第一步是在模块级别移除未使用且无副作用的模块，这一步由 webpack 的内置插件完成；第二步是在文件级别移除未使用的代码，这一步由代码压缩工具 Terser 完成的。 移除未使用的模块前面我们提到，需要在package.json中配置sideEffects字段。 在 webpack 文档 中有提到，这一举动正是为了让 webpack 正确地识别到没有副作用的代码模块。 在 webpack 中，模块依赖分析是由内置插件 SideEffectsFlagPlugin 进行的。 经过 SideEffectsFlagPlugin处理后，没有使用过并且没有副作用的模块都会被打上sideEffectFree标记。 在 ModuleConcatenationPlugin 中，带着sideEffectFree标记的模块将不会被打包： 来到这里，webpack 完成了在模块级别对未使用模块的排除。接下来，依靠 Terser，webpack 可以在文件级别，对未使用、无副作用的代码进行移除。 移除未使用的代码在 CommonJS 规范中，我们通过require函数来引入模块，通过module.exports进行导出。这意味着我们可以在代码中的任何地方用任何方式引入和导出模块：可以是在某个需要等待用户输入的回调函数中，或者是在符合某个条件才进行引入等等。所以在使用 ES6 的模块系统之前，对 Javascript 做编译时的依赖关系分析是近乎不可能的（并不是完全不可能。prepack 通过实现一个 JS 解释器，甚至可以在编译时提前进行静态计算）。 12345678// utils.jsmodule.exports.add = function (a, b) &#123; return a + b &#125;;module.exports.minus = function (a, b) &#123; return a - b &#125;;// index.js;var utils = require('./utils.js');utils.add(1, 2); 像上面这段代码，虽然我们最终只使用了add函数，但minus函数也会在最终的打包代码中出现，因为在编译时无法快速得知是否使用了minus函数。 在 ES6 的模块系统中，我们使用import/export语法来进行模块的引入和导出。与 CommonJS 规范不同的是，这套新的模块系统存在一些限制：import/export行为只能在代码的顶层、默认使用严格模式等等。这些限制使代码模块的导入与导出变得静态化，模块间的依赖关系在开发时已经确定，编译器也更容易解析我们的代码。 1234567// utils.jsexport function add (a, b) &#123; return a + b &#125;;export function minus (a, b) &#123; return a - b &#125;;// index.js;import &#123; add &#125; from './utils.js';add(1, 2); 在使用 ES6 模块系统改造后，我们可以清楚地看到，minus函数确实没有被使用过，所以可以安全地将其从最终打包代码中移除。 当然，具体的分析过程非常复杂。变量提升、object 取值操作、for(var i in list) 语句、自执行函数、函数传参（onClick(function a () {…})）等等，都有可能导致意料之外的情况，从而导致 treeshaking 失效。如果想了解 Terser 的具体处理过程，百度/Google 会是最好的老师。 Taro 做了什么Taro 需要对依赖包做一些修改。 组件的 ES 模块化在进行组件库的 ES 模块化改造之前，如果要发布 @tarojs/components 包，Taro 会执行命令 yarn build，使用 webpack 对源代码进行打包，输出为dist/index.js文件。由于 webpack 并不支持输出为 ES 模块，所以这是个 UMD 模块。 这个文件占据了 462KB 的空间，并且由于模块规范等问题，无法进行 treeshaking。所以就算开发者在 Taro 的项目中只引入了两个组件，最终的打包结果也会包含所有的内置组件。 事实上，@tarojs/components 的源码本身是使用 ESM 规范的： 所以只要让 webpack 直接解析组件库的源码，我们立即就可以享受到 webpack 自带 treeshaking 带来的好处了。 同时，我们也在sideEffects属性中对样式文件做了标记，帮助 webpack 对样式代码的副作用进行识别，在项目编译的代码中保留样式代码。 Api 的 ES 模块化同样，以前在发布 @tarojs/taro-h5 之前，Taro 也需要执行命令 yarn build，使用 Rollup 对源代码进行打包，输出为dist/index.js文件： 这个文件占据了 262KB 的空间。同样，只要是个 Taro 的 H5 端应用，生成的代码都会全量引入这个文件。 我们对 @tarojs/taro-h5 进行模块化改造的思路与 @tarojs/components 相同。我们希望 @tarojs/taro-h5 模块本身遵守 ESM 模块规范，那就只需要标记一下sideEffects，再修改一下模块入口就好。 粗略一看，@tarojs/taro-h5 还挺 “ESM” 的，但这还不够。我们还需要将这些 Api 以 namedExports 的形式导出，开发者使用import { XXX } from &#39;@tarojs/taro-h5&#39;导入 Api 即可。 那么问题来了。在 Taro 项目中，我们一直使用的是 defaultImport，并不会使用 Api 的 namedExports 形式： 12345import Taro from '@tarojs/taro-h5'Taro.navigateTo()Taro.getSystemInfo()// Taro.xxx ... 只要 Api 是通过对Taro变量取属性获取，Taro变量就需要具备所有的 Api，treeshaking 也就无从谈起。 有没有办法把 defaultImport 修改为 namedImports 呢？答案是肯定的。我们写了一个 babel 插件 babel-plugin-transform-taroapi，将指定的 Api 调用替换为 namedImports，未指定的变量则保留属性取值的形式。具体源码可以在这里查看。 12345678910111213// const apis = new Set(['navigateTo', 'navigateBack', ...])&#123; babel: &#123; preset: ['babel-preset-env'], plugins: [ // ..., ['babel-plugin-transform-taroapi', &#123; packageName: '@tarojs/taro-h5', apis &#125;] ] &#125;&#125; 这个插件接受一个对象作为配置参数：packageName属性指定需要进行替换的模块名，apis接受一个 Set 对象，也就是所有 Api 的列表。 为了避免后期手动维护 Api 列表的情况，我们给 @tarojs/taro-h5 模块加了一个编译任务，通过一个简单的Rollup 插件，在执行yarn build命令时生成一份 Api 列表： 下面是编译前后的代码对比。可以看到，在编译后setStorage、getStorage的调用都被替换为 namedImports。 1234567891011// 编译前import Taro from '@tarojs/taro-h5';Taro.initPxTransform(&#123;&#125;);Taro.setStorage()Taro['getStorage']()// 编译后import Taro, &#123; setStorage as _setStorage, getStorage as _getStorage &#125; from '@tarojs/taro-h5';Taro.initPxTransform(&#123;&#125;);_setStorage();_getStorage(); 到这里，虽然过程比较艰辛，但我们对 @tarojs/taro-h5 的模块化改造终于完成了。 最后截至目前，Taro 在 H5 端的完成度已经很高，但是并不完美。未来，在对已有问题进行修复的同时，我们还将继续为 Taro H5 端带来更多新的特性，比如对社区中呼声相当高的switchTab、页面滚动监听onPageScroll、下拉刷新onPullDownRefresh等 Api 的支持，更加统一的页面切换动画，以及更加稳定的多页面模式等等。 Taro 发展到现在，离不开社区的支持。非常感谢在 github、微信群中踊跃反馈的开发者们。如果你对Taro有什么想法或建议，Taro 非常欢迎你来吐槽或观光： https://github.com/NervJS/taro","pubDate":"Thu, 28 Feb 2019 15:09:41 GMT","guid":"https://aotu.io/notes/2019/02/28/taro-h5-optimize/","category":"小程序"},{"title":"Taro UI 2.0 发布：新增自定义主题功能，适配更多小程序","link":"https://aotu.io/notes/2019/02/25/taro-ui-2.0/","description":"前言转眼间，Taro UI 发布已有半年，感谢大家的支持，让我们收获了 GitHub 1400+ star。在此期间，我们不断完善组件库的功能和特性，新增了许多组件和小工具，包括但不限于: 新增日历、索引选择、区域选择、图片选择等十一个组件 适配支付宝小程序、百度小程序 新增自定义主题功能 新增主题生成器，以帮助开发者更好地使用自定义主题功能 新增 Issue Helper，以帮助开发者更规范地填写 Issue 新增组件在 1.0 版本发布之后，我们又陆续新增了如下十一个组件： 视图组件：页面提示、 分隔符、倒计时、 幕帘 、步骤条 操作反馈：全局信息组件 表单：图片选择器、区域选择器、索引选择器、日历组件、搜索栏 其中，在社区里呼声最高的组件，非日历组件莫属。由于日历组件复杂度偏高，要适配多端环境难度偏大，纵观市面上的小程序 UI 组件库，包含日历组件的寥寥无几。尽管如此，我们团队的大鱼兄仍独自挑起重担，几乎完美地实现了该组件，此处掌声献给大鱼兄。 日历组件功能预览： 适配支付宝小程序、百度小程序在 1.0 版本适配微信小程序时，我们遇到了很多困难。比如： 微信小程序自定义组件使用 Shadow DOM 进行渲染，引起了以下几种问题： 组件之间无法使用相邻选择器，如组件间加 border 的需求，最终只能通过新增 props 给开发者自行控制 无法自定义 flex 布局组件，最终只能提供样式给开发者自行使用 Component 组件对应 wxss 文件的样式，只对组件 wxml 内的节点生效。经过不断探索，才发现 addGlobalClass 这一属性，需在自定义组件内激活 addGlobalClass 选项，才能使自定义组件被 app.wxss 或页面的 wxss 中的所有的样式定义影响。。 原生组件的使用限制。由于原生组件脱离在 WebView 渲染流程外，原生组件的层级是最高的，所以页面中的其他组件无论设置 z-index 为多少，都无法盖在原生组件上。由此导致模态框等组件无法遮挡 input、textarea等原生组件，造成穿透效果。 可喜的是，微信官方团队已经在改善该问题，对小程序原生组件引入了同层渲染模式。通过同层渲染，小程序原生组件可与其他内置组件处于相同层级，不再有特殊的使用限制。详见。 小程序不支持 requestAnimationFrame，无法很好地实现 js 动画。 克服完上述微信小程序的困难后，支付宝小程序和百度小程序的适配工作大多是解决样式和某些API的差异。得益于 Taro 良好的支持，Taro UI 的适配工作暂时告一段落。 新增自定义主题功能Taro UI 1.0 发布时只有一套默认的主题配色，为满足业务和品牌上多样化的视觉需求，UI 库支持一定程度的样式定制。 Taro UI 的组件样式是使用 SCSS 编写的，如果你的项目中也使用了 SCSS，那么可以直接在项目中改变 Taro UI 的样式变量。 新建一个主题样式文件（例如 custom-variables.scss）并覆盖默认主题变量： 1234/* 改变主题变量，具体变量名可查看 taro-ui/dist/style/variables/default.scss 文件 */$color-brand: #6190E8;/* 引入 Taro UI 默认样式 */@import \"~taro-ui/dist/style/index.scss\"; 之后在项目的入口文件中引入以上的样式文件即可（无需重复引入组件的默认样式）。 目前，我们额外定制了京东主题和 7Fresh 主题色，可通过扫描以下二维码查看。 京东主题： 7Fresh 主题： 新增主题生成器为了让开发者更好地使用自定义主题功能，我们还新增了主题生成器。开发者可以使用该工具方便地定制 UI 主题。 主题生成器地址： https://nervjs.github.io/taro-ui-theme-preview/ 效果预览： 新增 Issue Helper虽然我们配置了 Issue Template，但仍有部分开发者没有根据规范填写 Issue。我们排查问题时经常需要再次询问版本号信息、复现代码等等，这不仅消耗我们维护项目的精力，还降低了 Issue 处理效率。因此我们参考了 Ant 和 iView 团队的做法，制作了 Issue Helper 页面，帮助开发者更规范地填写 Issue。 Taro UI Issue Helper 地址： https://nervjs.github.io/taro-ui-issue-helper/ 此外，我们发现重复制作 Issue Helper 页面是一件很浪费劳动力的事情，于是将 Issue Helper 封装成一个命令行工具，开发者可以通过简单配置 config.js，执行命令 issue-helper build 就可以生成所需要的页面。 Issue Helper 工具仓库地址： https://github.com/jimczj/issue-helper 未来计划 适配字节跳动小程序 国际化 i18n 致谢感谢大家对 Taro UI 的使用与反馈，我们会致力于将 Taro UI 打造成高质量组件库，不断丰富组件功能与特性，紧跟 Taro 的步伐适配更多平台。 最后，欢迎关注并使用我们的组件库： https://github.com/NervJS/taro-ui","pubDate":"Mon, 25 Feb 2019 04:53:41 GMT","guid":"https://aotu.io/notes/2019/02/25/taro-ui-2.0/","category":"小程序"}]}