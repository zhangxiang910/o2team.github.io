<!DOCTYPE html><html class="theme-lattice"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>羚珑项目自动化测试方案实践 | Aotu.io「凹凸实验室」</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="凹凸实验室"><meta name="designer" content="凹凸实验室"><meta name="rating" content="general"><meta name="format-detection" content="telephone=yes"><meta name="robots" content="index, follow"><meta baidu-gxt-verify-token="2b74a5aea155a215abea8547f929190c"><meta name="keywords" content="集成测试,单元测试,自动化测试,凹凸实验室,Aotu,前端开发,全栈开发,IOS开发,Android开发"><link rel="canonical" href="https://aotu.io/notes/2019/12/05/ling-testing-project/index.html"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png"><link rel="icon" type="image/png" sizes="48x48" href="/img/favicon-48x48.png"><link rel="manifest" href="/img/manifest.json"><meta name="mobile-web-app-capable" content="yes"><meta name="theme-color" content="#2f83cd"><meta name="application-name" content="Aotu.io"><link rel="apple-touch-icon" sizes="57x57" href="/img/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/img/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/img/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/img/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/img/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/img/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/img/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="167x167" href="/img/apple-touch-icon-167x167.png"><link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon-180x180.png"><link rel="apple-touch-icon" sizes="1024x1024" href="/img/apple-touch-icon-1024x1024.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-mobile-web-app-title" content="Aotu.io"><meta name="msapplication-TileColor" content="#fff"><meta name="msapplication-TileImage" content="/img/mstile-144x144.png"><meta name="msapplication-config" content="/img/browserconfig.xml"><meta property="wb:webmaster" content="a1686eb81db284d5"><meta name="wechat-logo" content="https://img10.360buyimg.com/ling/jfs/t1/86967/14/4534/59965/5de86ce8E021c30bd/9adf902d7e0dd96a.jpg"><meta name="wechat-title" content="羚珑项目自动化测试方案实践"><meta name="wechat-desc" content="Jest, SuperTest, MongoDB Memory Server, CI, TDD/BDD, etc."><link rel="dns-prefetch" href="//storage.360buyimg.com"><link rel="dns-prefetch" href="//img10.360buyimg.com"><link rel="dns-prefetch" href="//img11.360buyimg.com"><link rel="dns-prefetch" href="//img12.360buyimg.com"><link rel="dns-prefetch" href="//img13.360buyimg.com"><link rel="dns-prefetch" href="//img14.360buyimg.com"><link rel="dns-prefetch" href="//img20.360buyimg.com"><link rel="dns-prefetch" href="//img30.360buyimg.com"><link rel="dns-prefetch" href="//misc.aotu.io"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" href="/atom.xml" title="Aotu.io"><meta name="description" content="分享内容及技术栈本文将分享结合羚珑项目自身情况搭建的测试工作流的实践经验，针对于 Node.js 服务端应用的工具方法和接口的单元测试、集成测试等。实践经验能给你带来：  利用 Jest 搭建一套开发体验友好的测试工作流。 书写一个高效的单元测试用例，及集成测试用例。 利用封装技术实现模块间的分离，简化测试代码。 使用 SuperTest 完成应用进程与测试进程的合并。 创建高效的数据库内存服务，"><meta name="keywords" content="自动化测试,单元测试,集成测试"><meta property="og:type" content="article"><meta property="og:title" content="羚珑项目自动化测试方案实践"><meta property="og:url" content="https://aotu.io/notes/2019/12/05/ling-testing-project/index.html"><meta property="og:site_name" content="Aotu.io"><meta property="og:description" content="分享内容及技术栈本文将分享结合羚珑项目自身情况搭建的测试工作流的实践经验，针对于 Node.js 服务端应用的工具方法和接口的单元测试、集成测试等。实践经验能给你带来：  利用 Jest 搭建一套开发体验友好的测试工作流。 书写一个高效的单元测试用例，及集成测试用例。 利用封装技术实现模块间的分离，简化测试代码。 使用 SuperTest 完成应用进程与测试进程的合并。 创建高效的数据库内存服务，"><meta property="og:locale" content="zh-cn"><meta property="og:image" content="https://img13.360buyimg.com/ling/jfs/t1/87170/26/3878/4089/5de359e1Edb0c41cf/69bdd74155ffeeee.png"><meta property="og:image" content="https://img13.360buyimg.com/ling/jfs/t1/105590/1/3782/258638/5de24b09Ea5abcfbe/7dbc372e74e35d5b.jpg"><meta property="og:image" content="https://img12.360buyimg.com/ling/jfs/t1/85706/25/4075/63443/5de4825cEcd9ccbb8/136d88d6addafc29.png"><meta property="og:image" content="https://img10.360buyimg.com/ling/jfs/t1/92054/15/3970/24549/5de47f01Eff6e7001/7849faffae4c4d39.png"><meta property="og:image" content="https://img13.360buyimg.com/ling/jfs/t1/90876/8/4073/21921/5de50a8bE7087c30f/ee2c0bc4f8ea9708.png"><meta property="og:image" content="https://img12.360buyimg.com/ling/jfs/t1/90882/7/4331/247766/5de62b7cE653322b2/7f3adbf6e294ce03.png"><meta property="og:updated_time" content="2020-04-28T03:04:50.303Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="羚珑项目自动化测试方案实践"><meta name="twitter:description" content="分享内容及技术栈本文将分享结合羚珑项目自身情况搭建的测试工作流的实践经验，针对于 Node.js 服务端应用的工具方法和接口的单元测试、集成测试等。实践经验能给你带来：  利用 Jest 搭建一套开发体验友好的测试工作流。 书写一个高效的单元测试用例，及集成测试用例。 利用封装技术实现模块间的分离，简化测试代码。 使用 SuperTest 完成应用进程与测试进程的合并。 创建高效的数据库内存服务，"><meta name="twitter:image" content="https://img13.360buyimg.com/ling/jfs/t1/87170/26/3878/4089/5de359e1Edb0c41cf/69bdd74155ffeeee.png"><meta name="twitter:site" content="o2circle"><script>var App={root:"/",isHome:!1,isCate:!1,isTag:!1}</script><script>window.WechatShareData={imgUrl:"https://img10.360buyimg.com/ling/jfs/t1/86967/14/4534/59965/5de86ce8E021c30bd/9adf902d7e0dd96a.jpg",link:window.location.href,title:"羚珑项目自动化测试方案实践",desc:"Jest, SuperTest, MongoDB Memory Server, CI, TDD/BDD, etc."},window.WechatJSSDKURL="https://aotu.jd.com/aotu-wx-api/api/wx/jssdk/signature"</script></head><body class="page-post-detail"><div class="mod-hd"><div class="grid"><div class="mod-logo"><a href="/index.html" title="Aotu.io">Aotu.io</a></div><span class="mod-hd-toggle" id="J_hdToggle"><i class="fa fa-bars"></i></span><div class="mod-hd-main"><div class="mod-hd-inner"><nav class="mod-nav"><ul class="mod-nav-list"><li class="main-nav-item"><a href="/index.html" class="main-nav-link">首页</a></li><li class="main-nav-item"><a target="_blank" href="https://geeks.aotu.io" class="main-nav-link">极客沙龙</a></li><li class="main-nav-item"><a href="https://cases.aotu.io" class="main-nav-link">H5案例</a></li><li class="main-nav-item"><a href="/about/" class="main-nav-link">关于</a></li><li class="main-nav-item"><a href="/join/" class="main-nav-link">加入我们</a></li></ul></nav><div class="mod-search" id="J_search"><a class="fa fa-search mod-search-ico" id="J_searchTrigger" title="搜索"></a><form id="J_searchForm" method="get" class="mod-search-form" action="/search/"><input type="text" name="query" class="mod-search-ipt" id="J_searchInput" placeholder="搜索"></form></div></div></div></div></div><div class="mod-container"><div class="grid"><div class="mod-main typo"><article class="post"><div class="post-cover"><img src="https://img12.360buyimg.com/ling/jfs/t1/99375/14/4555/149640/5de86ce8Ee93e2291/8b9f75818c65b54c.png" alt="羚珑项目自动化测试方案实践"></div><header class="post-hd"><h1 class="post-tit">羚珑项目自动化测试方案实践</h1><div class="post-meta">by <a target="_blank" href="https://github.com/Barrior" class="post-author">Barrior</a> on <span>2019-12-05</span></div><p class="post-subtit" style="display:none"><i class="fa fa-quote-left"></i>Jest, SuperTest, MongoDB Memory Server, CI, TDD/BDD, etc.</p><span style="display:none" id="busuanzi_value_page_pv"></span></header><div class="post-content"><h2 id="分享内容及技术栈" class="post-heading"><a href="#分享内容及技术栈" class="headerlink" title="分享内容及技术栈"></a>分享内容及技术栈<a class="post-anchor" href="#分享内容及技术栈" aria-hidden="true"></a></h2><p>本文将分享结合羚珑项目自身情况搭建的测试工作流的实践经验，针对于 Node.js 服务端应用的工具方法和接口的单元测试、集成测试等。实践经验能给你带来：</p><ol><li>利用 Jest 搭建一套开发体验友好的测试工作流。</li><li>书写一个高效的单元测试用例，及集成测试用例。</li><li>利用封装技术实现模块间的分离，简化测试代码。</li><li>使用 SuperTest 完成应用进程与测试进程的合并。</li><li>创建高效的数据库内存服务，实现彼此隔离的测试套件运行机制。</li><li>了解模拟（Mock）、快照（snapshot）与测试覆盖率等功能的使用。</li><li>理解 TDD 与 BDD。</li><li>…</li></ol><p>文中涉及的基础技术栈有（需要了解的知识）：</p><ol><li><strong>TypeScript</strong>: JavaScript 语言的超集，提供类型系统和新 ES 语法支持。</li><li><strong>SuperTest</strong>: HTTP 代理及断言工具。</li><li><strong>MongoDB</strong>: NoSQL 分布式文件存储数据库。</li><li><strong>Mongoose</strong>: MongoDB 对象关系映射操作库（ORM）。</li><li><strong>Koa</strong>: 基础 Web 应用程序框架。</li><li><strong>Jest</strong>: 功能丰富的 JavaScript 测试框架。</li><li><strong>lodash</strong>: JavaScript 工具函数库。</li></ol><h2 id="关于羚珑" class="post-heading"><a href="#关于羚珑" class="headerlink" title="关于羚珑"></a>关于羚珑<a class="post-anchor" href="#关于羚珑" aria-hidden="true"></a></h2><p><img src="https://img13.360buyimg.com/ling/jfs/t1/87170/26/3878/4089/5de359e1Edb0c41cf/69bdd74155ffeeee.png" alt="羚珑Logo"></p><p>羚珑是京东旗下智能设计平台，提供在线设计服务，主要包括大类如：</p><p><strong>图片设计：快速合成广告图，主图，公众号配图，海报，传单，物流面单等线上与线下设计服务。</strong></p><p><strong>视频设计：快速合成主图视频，抖音短视频，自定义视频等设计服务。</strong></p><p><strong>页面设计：快速搭建活动页，营销页，小游戏，小程序等设计服务。</strong></p><p><strong>实用工具：批量抠图、改尺寸、配色、加水印等。</strong></p><p>基于行业领先技术，为商家、用户提供丰富的设计能力，实现快速产出。</p><h2 id="羚珑架构及测试框架选型" class="post-heading"><a href="#羚珑架构及测试框架选型" class="headerlink" title="羚珑架构及测试框架选型"></a>羚珑架构及测试框架选型<a class="post-anchor" href="#羚珑架构及测试框架选型" aria-hidden="true"></a></h2><p>先介绍下羚珑项目的架构，方便后续的描述和理解。羚珑项目采用前后端分离的机制，前端采用 React Family 的基础架构，再加上 Next.js 服务端渲染以提供更好的用户体验及 SEO 排名。后端架构则如下图所示，流程大概是<strong>浏览器或第三方应用访问项目 Nginx 集群，Nginx 集群再通过负载均衡转发到羚珑应用服务器，应用服务器再通过对接外部服务或内部服务等，或读写缓存、数据库，逻辑处理后通过 HTTP 返回到前端正确的数据。</strong></p><p><img src="https://img13.360buyimg.com/ling/jfs/t1/105590/1/3782/258638/5de24b09Ea5abcfbe/7dbc372e74e35d5b.jpg" alt="羚珑服务端架构图"></p><h3 id="主流测试框架对比" class="post-heading"><a href="#主流测试框架对比" class="headerlink" title="主流测试框架对比"></a>主流测试框架对比<a class="post-anchor" href="#主流测试框架对比" aria-hidden="true"></a></h3><p>接下来，根据项目所需我们对比下当下 Node.js 端主流的测试框架。</p><table><thead><tr><th></th><th>Jest</th><th>Mocha</th><th>AVA</th><th>Jasmine</th></tr></thead><tbody><tr><td>GitHub Stars</td><td>28.5K</td><td>18.7K</td><td>17.1K</td><td>14.6K</td></tr><tr><td>GitHub Used by</td><td>1.5M</td><td>926K</td><td>46.6K</td><td>5.3K</td></tr><tr><td>文档友好</td><td>优秀</td><td>良好</td><td>良好</td><td>良好</td></tr><tr><td>模拟功能（Mock）</td><td>支持</td><td>外置</td><td>外置</td><td>外置</td></tr><tr><td>快照功能（Snapshot）</td><td>支持</td><td>外置</td><td>支持</td><td>外置</td></tr><tr><td>支持 TypeScript</td><td>ts-jest</td><td>ts-mocha</td><td>ts-node</td><td>jasmine-ts</td></tr><tr><td>详细的错误输出</td><td>支持</td><td>支持</td><td>支持</td><td>未知</td></tr><tr><td>支持并行与串行</td><td>支持</td><td>外置</td><td>支持</td><td>外置</td></tr><tr><td>每个测试进程隔离</td><td>支持</td><td>不支持</td><td>支持</td><td>未知</td></tr></tbody></table><p>*<em>文档友好：文档结构组织有序，API 阐述完整，以及示例丰富。</em></p><p>分析：</p><ol><li>之所以 Mocha GitHub 使用率很高，很有可能是因为出现的最早（2011年），并由 Node.js 届顶级开发者 TJ 领导开发的（后转向Go语言），所以早期项目选择了 Mocha 做为测试框架，而 Jest、AVA 则是后起之秀（2014年），并且 Stars 数量都在攀升，预计新项目都会在这两个框架中挑选。</li><li>相比外置功能，内置支持可能会与框架融合的更好，理念更趋近，维护更频繁，使用更省心。</li><li>Jest 模拟功能可以实现方法模拟，定时器模拟，模块/文件依赖模拟，在实际编写测试用例中，模拟模块功能（mock modules）被常常用到，它可以确保测试用例快速响应并且不会变化无常。下文也会谈到如何使用它，为什么需要使用它。</li></ol><p>综上，我们选择了 Jest 作为基础测试框架。</p><h2 id="从0到1落地实践" class="post-heading"><a href="#从0到1落地实践" class="headerlink" title="从0到1落地实践"></a>从0到1落地实践<a class="post-anchor" href="#从0到1落地实践" aria-hidden="true"></a></h2><h3 id="Jest-框架配置" class="post-heading"><a href="#Jest-框架配置" class="headerlink" title="Jest 框架配置"></a>Jest 框架配置<a class="post-anchor" href="#Jest-框架配置" aria-hidden="true"></a></h3><p>接下来，我们从 0 到 1 开始实践，首先是搭建测试流，虽然 Jest 可以达到开箱即用，然而项目架构不尽相同，大多时候需要根据实际情况做些基础配置工作。以下是根据羚珑项目提取出来的简化版项目目录结构，如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├─ dist                 <span class="comment"># TS 编译结果目录</span></span><br><span class="line">├─ src                  <span class="comment"># TS 源码目录</span></span><br><span class="line">│   ├─ app.ts              <span class="comment"># 应用主文件，类似 Express 框架的 /app.js 文件</span></span><br><span class="line">│   └─ index.ts            <span class="comment"># 应用启动文件，类似 Express 框架的 /bin/www 文件</span></span><br><span class="line">├─ <span class="built_in">test</span>                 <span class="comment"># 测试文件目录</span></span><br><span class="line">│   ├─ @fixtures           <span class="comment"># 测试固定数据</span></span><br><span class="line">│   ├─ @helpers            <span class="comment"># 测试工具方法</span></span><br><span class="line">│   ├─ module1             <span class="comment"># 模块1的测试套件集合</span></span><br><span class="line">│   │  └─ <span class="built_in">test</span>-suite.ts       <span class="comment"># 测试套件，一类测试用例集合</span></span><br><span class="line">│   └─ module2             <span class="comment"># 模块2的测试套件集合</span></span><br><span class="line">├─ package.json           </span><br><span class="line">└─ yarn.lock</span><br></pre></td></tr></table></figure><p>这里有两个小点：</p><ol><li>以 <code>@</code> 开头的目录，我们定义为特殊文件目录，用于提供些测试辅助工具方法、配置文件等，平级的其他目录则是测试用例所在的目录，按业务模块或功能划分。以 <code>@</code> 开头可以清晰的显示在同级目录最上方，很容易开发定位，凑巧也方便了编写正则匹配。</li><li><code>test-suite.ts</code> 是项目内最小测试文件单元，我们称之为测试套件，表示同一类测试用例的集合，可以是某个通用函数的多个测试用例集合，也可以是一个系列的单元测试用例集合。</li></ol><p>首先安装测试框架。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev jest ts-jest @types/jest</span><br></pre></td></tr></table></figure><p>因为项目是用 TypeScript 编写，所以这里同时安装 <code>ts-jest @types/jest</code>。然后在根目录新建 <code>jest.config.js</code> 配置文件，并做如下小许配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// preset: 'ts-jest',</span></span><br><span class="line">  globals: &#123;</span><br><span class="line">    <span class="string">'ts-jest'</span>: &#123;</span><br><span class="line">      tsConfig: <span class="string">'tsconfig.test.json'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  testEnvironment: <span class="string">'node'</span>,</span><br><span class="line">  roots: [<span class="string">'&lt;rootDir&gt;/src/'</span>, <span class="string">'&lt;rootDir&gt;/test/'</span>],</span><br><span class="line">  testMatch: [<span class="string">'&lt;rootDir&gt;/test/**/*.ts'</span>],</span><br><span class="line">  testPathIgnorePatterns: [<span class="string">'&lt;rootDir&gt;/test/@.+/'</span>],</span><br><span class="line">  moduleNameMapper: &#123;</span><br><span class="line">    <span class="string">'^~/(.*)'</span>: <span class="string">'&lt;rootDir&gt;/src/$1'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>preset:</strong> 预设测试运行环境，多数情况设置为 <code>ts-jest</code> 即可，如果需要为 <code>ts-jest</code> 指定些参数，如上面指定 TS 配置为 <code>tsconfig.test.json</code>，则需要像上面这样的写法，将 <code>ts-jest</code> 挂载到 <code>globals</code> 属性上，更多配置可以移步其官方文档，<a href="https://kulshekhar.github.io/ts-jest/user/config/#options" target="_blank" rel="noopener">这里</a>。</p><p><strong>testEnvironment:</strong> 基于预设再设置测试环境，Node.js 需要设置为 <code>node</code>，因为默认值为浏览器环境 <code>jsdom</code>。</p><p><strong>roots:</strong> 用于设定测试监听的目录，如果匹配到的目录的文件有所改动，就会自动运行测试用例。<code>&lt;rootDir&gt;</code> 表示项目根目录，即与 <code>package.json</code> 同级的目录。这里我们监听 <code>src</code> 和 <code>test</code> 两个目录。</p><p><strong>testMatch:</strong> <code>Glob</code> 模式设置匹配的测试文件，当然也可以是正则模式，这里我们匹配 <code>test</code> 目录下的所有文件，匹配到的文件才会当做测试用例执行。</p><p><strong>testPathIgnorePatterns:</strong> 设置已经匹配到的但需要被忽略的文件，这里我们设置以 <code>@</code> 开头的目录及其所有文件都不当做测试用例。</p><p><strong>moduleNameMapper:</strong> 这个与 <code>TS paths</code> 和 <code>Webpack alias</code> 雷同，用于设置目录别名，可以减少引用文件时的出错率并且提高开发效率。这里我们设置以 <code>~</code> 开头的模块名指向 <code>src</code> 目录。</p><h3 id="第一个单元测试用例" class="post-heading"><a href="#第一个单元测试用例" class="headerlink" title="第一个单元测试用例"></a>第一个单元测试用例<a class="post-anchor" href="#第一个单元测试用例" aria-hidden="true"></a></h3><p>搭建好测试运行环境，于是便可着手编写测试用例了，下面我们编写一个接口单元测试用例，比方说测试首页轮播图接口的正确性。我们将测试用例放在 <code>test/homepage/carousel.ts</code> 文件内，代码如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; forEach, isArray &#125; <span class="keyword">from</span> <span class="string">'lodash’</span></span><br><span class="line"><span class="string">import &#123; JFSRegex, URLRegex &#125; from '</span>~<span class="regexp">/utils/</span>regex<span class="string">'</span></span><br><span class="line"><span class="string">import request from '</span>request-promise<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const baseUrl = '</span>http:<span class="comment">//ling-dev.jd.com/server/api'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个测试用例</span></span><br><span class="line">test(<span class="string">'轮播图个数应该返回 5，并且数据正确'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 对接口发送 HTTP 请求</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> request.get(baseUrl + <span class="string">'/carousel/pictures'</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 校验返回状态码为 200</span></span><br><span class="line">  expect(res.statusCode).toBe(<span class="number">200</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 校验返回数据是数组并且长度为 5</span></span><br><span class="line">  expect(isArray(res.body)).toBe(<span class="literal">true</span>)</span><br><span class="line">  expect(res.body.length).toBe(<span class="number">5</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 校验数据每一项都是包含正确的 url, href 属性的对象</span></span><br><span class="line">  forEach(res.body, picture =&gt; &#123;</span><br><span class="line">    expect(picture).toMatchObject(&#123;</span><br><span class="line">      url: expect.stringMatching(JFSRegex),</span><br><span class="line">      href: expect.stringMatching(URLRegex),</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>编写好测试用例后，第一步需要启动应用服务器：</p><p><img src="https://img12.360buyimg.com/ling/jfs/t1/85706/25/4075/63443/5de4825cEcd9ccbb8/136d88d6addafc29.png" alt="应用服务运行截图"></p><p>第二步运行测试，在命令行窗口输入：<code>npx jest</code>，如下图可以看到用例测试通过。</p><p><img src="https://img10.360buyimg.com/ling/jfs/t1/92054/15/3970/24549/5de47f01Eff6e7001/7849faffae4c4d39.png" alt="测试用例通过截图"></p><p>当然最佳实践则是把命令封装到 <code>package.json</code> 里，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"jest"</span>,</span><br><span class="line">    <span class="attr">"test:watch"</span>: <span class="string">"jest --watch"</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后便可使用 <code>yarn test</code> 来运行测试，通过 <code>yarn test:watch</code> 来启动监听式测试服务。</p><h3 id="SuperTest-增强" class="post-heading"><a href="#SuperTest-增强" class="headerlink" title="SuperTest 增强"></a>SuperTest 增强<a class="post-anchor" href="#SuperTest-增强" aria-hidden="true"></a></h3><p>虽然上面已经完成基本的测试流程开发，但很明显的一个问题是每次运行测试，我们需要先启动应用服务，共启动两个进程，并且需要提前配置 <code>ling-dev.jd.com</code> 指向 <code>127.0.0.1:3800</code>，这是一个繁琐的过程。所以我们引入了 SuperTest，它可以把应用服务集成到测试服务一起启动，并且不需要指定 HTTP 请求的主机地址。</p><p>我们封装一个公共的 <code>request</code> 方法，将它放在 <code>@helpers/agent.ts</code> 文件内，如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> supertest <span class="keyword">from</span> <span class="string">'supertest'</span></span><br><span class="line"><span class="keyword">import</span> app <span class="keyword">from</span> <span class="string">'~/app'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> request = supertest(http.createServer(app.callback()))</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>使用 <code>app.callback()</code> 而不是 <code>app.listen()</code>，是因为它可以将同一个 <code>app</code> 同时作为 HTTP 和 HTTPS 或多个地址。<code>app.callback()</code> 返回适用于 <code>http.createServer()</code> 方法的回调函数来处理请求。</li><li>之后，<code>http.createServer()</code> 创建一个未监听的 HTTP 对象给 SuperTest，当然 SuperTest 内部也会调用 <code>listen(0)</code> 这样的特殊端口，让操作系统提供可用的随机端口来启动应用服务器。</li></ol><p>所以上面的测试用例我们可以改写成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; forEach, isArray &#125; <span class="keyword">from</span> <span class="string">'lodash’</span></span><br><span class="line"><span class="string">import &#123; JFSRegex, URLRegex &#125; from '</span>~<span class="regexp">/utils/</span>regex<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 引入公共的 request 方法</span></span><br><span class="line"><span class="string">import &#123; request &#125; from '</span>../@helpers/agent<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">test('</span>轮播图个数应该返回 <span class="number">5</span>，并且数据正确<span class="string">', async () =&gt; &#123;</span></span><br><span class="line"><span class="string">  const res = await request.get('</span>/api/carousel/pictures<span class="string">')</span></span><br><span class="line"><span class="string">  expect(res.status).toBe(200)</span></span><br><span class="line"><span class="string">  // 同样的校验...</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><p>因为 SuperTest 内部已经帮我们包装好了主机地址并自动启动应用服务，所以请求接口时只需书写具体的接口，如 <code>/api/carousel/pictures</code>，也只需运行一条命令 <code>yarn test</code>，就可以完成整个测试工作。</p><h3 id="数据库内存服务" class="post-heading"><a href="#数据库内存服务" class="headerlink" title="数据库内存服务"></a>数据库内存服务<a class="post-anchor" href="#数据库内存服务" aria-hidden="true"></a></h3><p>项目架构中可以看到数据库使用的是 MongoDB，在测试时，几乎所有的接口都需要与数据库连接。此时可通过环境变量区分并新建 test 数据库，用于运行测试用例。有点不好的是测试套件执行完成后需要对 test 数据库进行清空，以避免脏数据影响下个测试套件，尤其是在并发运行时，需要保持数据隔离。</p><p>使用 MongoDB Memory Server 是更好的选择，它会启动独立的 MongoDB 实例（每个实例大约占用非常低的 7MB 内存），而测试套件将运行在这个独立的实例里。假如并发为 3，那就创建 3 个实例分别运行 3 个测试套件，这样可以很好的保持数据隔离，并且数据都保存在内存中，这使得运行速度会非常快，当测试套件完成后则自动销毁实例。</p><p><img src="https://img13.360buyimg.com/ling/jfs/t1/90876/8/4073/21921/5de50a8bE7087c30f/ee2c0bc4f8ea9708.png" alt="MongoDB Memory Server"></p><p>接下来我们把 MongoDB Memory Server 引入实际测试中，最佳方式是把它写进 Jest 环境配置里，这样只需要一次书写，自动运行在每个测试套件中。所以替换 <code>jest.config.js</code> 配置文件的 <code>testEnvironment</code> 为自定义环境 <code>&lt;rootDir&gt;/test/@helpers/jest-env.js</code>。</p><p>编写自定义环境 <code>@helpers/jest-env.js</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NodeEnvironment = <span class="built_in">require</span>(<span class="string">'jest-environment-node'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; MongoMemoryServer &#125; = <span class="built_in">require</span>(<span class="string">'mongodb-memory-server'</span>)</span><br><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 Node 环境</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomEnvironment</span> <span class="keyword">extends</span> <span class="title">NodeEnvironment</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在测试套件启动前，获取本地开发 MongoDB Uri 并注入 global 对象</span></span><br><span class="line">  <span class="keyword">async</span> setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> uri = <span class="keyword">await</span> getMongoUri()</span><br><span class="line">    <span class="keyword">this</span>.global.testConfig = &#123;</span><br><span class="line">      mongo: &#123; uri &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">super</span>.setup()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getMongoUri</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 which mongod 命令拿到本地 MongoDB 二进制文件路径</span></span><br><span class="line">  <span class="keyword">const</span> mongodPath = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    child_process.exec(</span><br><span class="line">      <span class="string">'which mongod'</span>,</span><br><span class="line">      &#123; <span class="attr">encoding</span>: <span class="string">'utf8'</span> &#125;,</span><br><span class="line">      (err, stdout, stderr) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err || stderr) &#123;</span><br><span class="line">          <span class="keyword">return</span> reject(</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'找不到系统的 mongod，请确保 `which mongod` 可以指向 mongod'</span>)</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(stdout.trim())</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用本地 MongoDB 二进制文件创建内存服务实例</span></span><br><span class="line">  <span class="keyword">const</span> mongod = <span class="keyword">new</span> MongoMemoryServer(&#123;</span><br><span class="line">    binary: &#123; <span class="attr">systemBinary</span>: mongodPath &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 得到创建成功的实例 Uri 地址</span></span><br><span class="line">  <span class="keyword">const</span> uri = <span class="keyword">await</span> mongod.getConnectionString()</span><br><span class="line">  <span class="keyword">return</span> uri</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出自定义环境类</span></span><br><span class="line"><span class="built_in">module</span>.exports = CustomEnvironment</span><br></pre></td></tr></table></figure><p>Mongoose 中便可以这样连接：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> mongoose.connect((global <span class="keyword">as</span> any).testConfig.mongo.uri, &#123;</span><br><span class="line">  useNewUrlParser: <span class="literal">true</span>,</span><br><span class="line">  useUnifiedTopology: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然在 <code>package.json</code> 里需要禁用 MongoDB Memory Server 去下载二进制包，因为上面已经使用了本地二进制包。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">"config": &#123;</span><br><span class="line">  "mongodbMemoryServer": &#123;</span><br><span class="line">    "version": "4.0",</span><br><span class="line">    <span class="comment">// 禁止在 yarn install 时下载二进制包</span></span><br><span class="line">    "disablePostinstall": "1",</span><br><span class="line">    "md5Check": "1"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="登录功能封装与使用" class="post-heading"><a href="#登录功能封装与使用" class="headerlink" title="登录功能封装与使用"></a>登录功能封装与使用<a class="post-anchor" href="#登录功能封装与使用" aria-hidden="true"></a></h3><p>大多时候接口是需要登录后才能访问的，所以我们需要把整块登录功能抽离出来，封装成通用方法，同时借此初始化一些测试专用数据。</p><p>为了使 API 易用，我希望登录 API 长这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; login &#125; <span class="keyword">from</span> <span class="string">'../@helpers/login'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用登录方法，根据传递的角色创建用户，并返回该用户登录的 request 对象。</span></span><br><span class="line"><span class="comment">// 支持多参数，根据参数不同自动初始化测试数据。</span></span><br><span class="line"><span class="keyword">const</span> request = <span class="keyword">await</span> login(&#123;</span><br><span class="line">  role: <span class="string">'user'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用已登录的 request 对象访问需要登录的用户接口，</span></span><br><span class="line"><span class="comment">// 应当是登录态，并正确返回当前登录的用户信息。</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> request.get(<span class="string">'/api/user/info'</span>)</span><br></pre></td></tr></table></figure><p>开发登录方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @helpers/agent.ts </span></span><br><span class="line"><span class="comment">// 新添加 makeAgent 方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">makeAgent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 supertest.agent 支持 cookie 持久化</span></span><br><span class="line">  <span class="keyword">return</span> supertest.agent(http.createServer(app.callback()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @helpers/login.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; assign, cloneDeep, pick &#125; <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"><span class="keyword">import</span> &#123; makeAgent &#125; <span class="keyword">from</span> <span class="string">'./agent'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">userData: UserDataType</span>): <span class="title">Promise</span>&lt;<span class="title">RequestAgent</span>&gt; </span>&#123;</span><br><span class="line">  userData = cloneDeep(userData)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果没有用户名，自动创建用户名</span></span><br><span class="line">  <span class="keyword">if</span> (!userData.username) &#123;</span><br><span class="line">    userData.username = chance.word(&#123; <span class="attr">length</span>: <span class="number">8</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果没有昵称，自动创建昵称</span></span><br><span class="line">  <span class="keyword">if</span> (!userData.nickname) &#123;</span><br><span class="line">    userData.nickname = chance.word(&#123; <span class="attr">length</span>: <span class="number">8</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 得到支持 cookie 持久化的 request 对象</span></span><br><span class="line">  <span class="keyword">const</span> request: any = makeAgent()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送登录请求，这里为测试专门设计一个登录接口</span></span><br><span class="line">  <span class="comment">// 包含正常登录功能，但还会根据传参不同初始化测试专用数据</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> request.post(<span class="string">'/api/login-test'</span>).send(userData)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将登录返回的数据赋值到 request 对象上</span></span><br><span class="line">  assign(request, pick(res.body, [<span class="string">'user'</span>, <span class="string">'otherValidKey...'</span>]))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 request 对象</span></span><br><span class="line">  <span class="keyword">return</span> request <span class="keyword">as</span> RequestAgent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际用例中就像上面示例方式使用。</p><h3 id="模拟功能使用" class="post-heading"><a href="#模拟功能使用" class="headerlink" title="模拟功能使用"></a>模拟功能使用<a class="post-anchor" href="#模拟功能使用" aria-hidden="true"></a></h3><p>从项目架构中可以看到项目也会调用较多外部服务。比方说创建文件夹的接口，内部代码需要调用外部服务去鉴定文件夹名称是否包含敏感词，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; detectText &#125; <span class="keyword">from</span> <span class="string">'~/utils/detect'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用外部服务检测文件夹名称是否包含敏感词</span></span><br><span class="line"><span class="keyword">const</span> &#123; ok, sensitiveWords &#125; = <span class="keyword">await</span> detectText(folderName)</span><br><span class="line"><span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`检测到敏感词: <span class="subst">$&#123;sensitiveWords&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际测试的时候并不需要所有测试用例运行时都调用外部服务，这样会拖慢测试用例的响应时间以及不稳定性。我们可以建立个更好的机制，新建一个测试套件专门用于验证 <code>detectText</code> 工具方法的正确性，而其他测试套件运行时 <code>detectText</code> 方法直接返回 OK 即可，这样既保证了 <code>detectText</code> 方法被验证到，也保证了其他测试套件得到快速响应。</p><p>模拟功能（Mock）就是为这样的情景而诞生的。我们只需要在 <code>detectText</code> 方法的路径 <code>utils/detect.ts</code> 同级新建<code>__mocks__/detect.ts</code> 模拟文件即可，内容如下，直接返回结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">detectText</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  text: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Promise</span>&lt;</span>&#123; ok: boolean; sensitive: boolean; sensitiveWords?: string &#125;&gt; &#123;</span><br><span class="line">  <span class="comment">// 删除所有代码，直接返回 OK</span></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">ok</span>: <span class="literal">true</span>, <span class="attr">sensitive</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后每个需要模拟的测试套件顶部加上下面一句代码即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jest.mock(<span class="string">'~/utils/detect.ts'</span>)</span><br></pre></td></tr></table></figure><p>在验证 <code>detectText</code> 工具方法的测试套件里，则只需 <code>jest.unmock</code> 即可恢复真实的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jest.unmock(<span class="string">'~/utils/detect.ts'</span>)</span><br></pre></td></tr></table></figure><p>当然应该把 <code>jest.mock</code> 写在 <code>setupFiles</code> 配置里，因为需要模拟的测试套件占绝大多数，写在配置里会让它们在运行前自动加载该文件，这样开发就不必每处测试套件都加上一段同样的代码，可以有效提高开发效率。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jest.config.js</span></span><br><span class="line">setupFiles: [<span class="string">'&lt;rootDir&gt;/test/@helpers/jest-setup.ts'</span>]</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @helpers/jest-setup.ts</span></span><br><span class="line">jest.mock(<span class="string">'~/utils/detect.ts'</span>)</span><br></pre></td></tr></table></figure><p>模拟功能还有方法模拟，定时器模拟等，可以查阅其<a href="https://jestjs.io/docs/en/jest-object#mock-modules" target="_blank" rel="noopener">文档</a>了解更多示例。</p><h3 id="快照功能使用" class="post-heading"><a href="#快照功能使用" class="headerlink" title="快照功能使用"></a>快照功能使用<a class="post-anchor" href="#快照功能使用" aria-hidden="true"></a></h3><p>快照功能（Snapshot）可以帮我们测试大型对象，从而简化测试用例。</p><p>举个例子，项目的模板解析接口，该接口会将 PSD 模板文件进行解析，然后吐出一个较大的 JSON 数据，如果挨个校验对象的属性是否正确可能很不理想，所以可以使用快照功能，就是第一次运行测试用例时，会把 JSON 数据存储到本地文件，称之为快照文件，第二次运行时，就会将第二次返回的数据与快照文件进行比较，如果两个快照匹配，则表示测试成功，反之测试失败。</p><p>而使用方式很简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求模板解析接口</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> request.post(<span class="string">'/api/secret/parser'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断言快照是否匹配</span></span><br><span class="line">expect(res.body).toMatchSnapshot()</span><br></pre></td></tr></table></figure><p>更新快照也是敏捷的，运行命令 <code>jest --updateSnapshot</code> 或在监听模式输入 <code>u</code> 来更新。</p><h3 id="集成测试" class="post-heading"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试<a class="post-anchor" href="#集成测试" aria-hidden="true"></a></h3><p>集成测试的概念是在单元测试的基础上，将所有模块按照一定要求或流程关系进行串联测试。比方说，一些模块虽然能够单独工作，但并不能保证连接起来也能正常工作，一些局部反映不出来的问题，在全局上很可能暴露出来。</p><p>因为测试框架 Jest 对于每个测试套件是并行运行的，而套件内的用例则是串行运行的，所以编写集成测试很方便，下面我们用文件夹的使用流程示例如何完成集成测试的编写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; request &#125; <span class="keyword">from</span> <span class="string">'../@helpers/agent'</span></span><br><span class="line"><span class="keyword">import</span> &#123; login &#125; <span class="keyword">from</span> <span class="string">'../@helpers/login'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> urlCreateFolder = <span class="string">'/api/secret/folder'</span>      <span class="comment">// POST</span></span><br><span class="line"><span class="keyword">const</span> urlFolderDetails = <span class="string">'/api/secret/folder'</span>     <span class="comment">// GET</span></span><br><span class="line"><span class="keyword">const</span> urlFetchFolders = <span class="string">'/api/secret/folders'</span>     <span class="comment">// GET</span></span><br><span class="line"><span class="keyword">const</span> urlDeleteFolder = <span class="string">'/api/secret/folder'</span>      <span class="comment">// DELETE</span></span><br><span class="line"><span class="keyword">const</span> urlRenameFolder = <span class="string">'/api/secret/folder/rename'</span>     <span class="comment">// PUT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> folders: ObjectAny[] = []</span><br><span class="line"><span class="keyword">let</span> globalReq: ObjectAny</span><br><span class="line"></span><br><span class="line">test(<span class="string">'没有权限创建文件夹应该返回 403 错误'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> request.post(urlCreateFolder).send(&#123;</span><br><span class="line">    name: <span class="string">'我的文件夹'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  expect(res.status).toBe(<span class="number">403</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'确保创建 3 个文件夹'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 登录有权限创建文件夹的用户，比如设计师</span></span><br><span class="line">  globalReq = <span class="keyword">await</span> login(&#123; <span class="attr">role</span>: <span class="string">'designer'</span> &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> globalReq.post(urlCreateFolder).send(&#123;</span><br><span class="line">      name: <span class="string">'我的文件夹'</span> + i,</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将创建成功的文件夹置入 folders 常量里</span></span><br><span class="line">    folders.push(res.body)</span><br><span class="line">    </span><br><span class="line">    expect(res.status).toBe(<span class="number">200</span>)</span><br><span class="line">    <span class="comment">// 更多验证规则...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'重命名第 2 个文件夹'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> globalReq.put(urlRenameFolder).send(&#123;</span><br><span class="line">    id: folders[<span class="number">1</span>].id,</span><br><span class="line">    name: <span class="string">'新文件夹名称'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  expect(res.status).toBe(<span class="number">200</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'第 2 个文件夹的名称应该是【新文件夹名称】'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> globalReq.get(urlFolderDetails).query(&#123;</span><br><span class="line">    id: folders[<span class="number">1</span>].id,</span><br><span class="line">  &#125;)</span><br><span class="line">  expect(res.status).toBe(<span class="number">200</span>)</span><br><span class="line">  expect(res.body.name).toBe(<span class="string">'新文件夹名称'</span>)</span><br><span class="line">  <span class="comment">// 更多验证规则...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'获取文件夹列表应该返回 3 条数据'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 与上雷同，鉴于代码过多，先行省略...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'删除最后一个文件夹'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 与上雷同，鉴于代码过多，先行省略...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'再次获取文件夹列表应该返回 2 条数据'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 与上雷同，鉴于代码过多，先行省略...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="测试覆盖率" class="post-heading"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率<a class="post-anchor" href="#测试覆盖率" aria-hidden="true"></a></h2><p>测试覆盖率是对测试完成程度的评测，基于文件被测试的情况来反馈测试的质量。</p><p>运行命令 <code>jest --coverage</code> 即可生成测试覆盖率报告，打开生成的 <code>coverage/lcov-report/index.html</code> 文件，各项指标一览无余。因为 Jest 内部使用 Istanbul 生成覆盖率报告，所以各项指标依然参考 <a href="https://istanbul.js.org/" target="_blank" rel="noopener">Istanbul</a>。</p><p><img src="https://img12.360buyimg.com/ling/jfs/t1/90882/7/4331/247766/5de62b7cE653322b2/7f3adbf6e294ce03.png" alt="测试覆盖率报告"></p><h2 id="持续集成" class="post-heading"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成<a class="post-anchor" href="#持续集成" aria-hidden="true"></a></h2><p>写完这么多测试用例之后，或者是开发完功能代码后，我们是不是希望每次将代码推送到托管平台，如 GitLab，托管平台能自动帮我们运行所有测试用例，如果测试失败就邮件通知我们修复，如果测试通过则把开发分支合并到主分支？</p><p>答案是必须的。这就与持续集成（Continuous Integration）不谋而合，通俗的讲就是经常性地将代码合并到主干分支，每次合并前都需要运行自动化测试以验证代码的正确性。</p><p>所以我们配置一些自动化测试任务，按顺序执行安装、编译、测试等命令，测试命令则是运行编写好的测试用例。一个 GitLab 的配置任务（<code>.gitlab-ci.yml</code>）可能像下面这样，仅作参考。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个 job 之前执行的命令</span></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"`whoami` ($0 $SHELL)"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">"`which node` (`node -v`)"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">$CI_PROJECT_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 job 所属 test 阶段及执行的命令等</span></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">except:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node_modules/</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">yarn</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">lint</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 job 所属 deploy 阶段及执行的命令等</span></span><br><span class="line"><span class="attr">deploy-stage:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cd</span> <span class="string">/app</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">make</span> <span class="string">BRANCH=origin/$&#123;CI_COMMIT_REF_NAME&#125;</span> <span class="string">deploy-stage</span></span><br></pre></td></tr></table></figure><p>持续集成的好处：</p><ol><li>快速发现错误。</li><li>防止分支大幅偏离主干分支。</li><li>让产品可以快速迭代，同时还能保持高质量。</li></ol><h2 id="TDD与BDD引入" class="post-heading"><a href="#TDD与BDD引入" class="headerlink" title="TDD与BDD引入"></a>TDD与BDD引入<a class="post-anchor" href="#TDD与BDD引入" aria-hidden="true"></a></h2><p>TDD 全称测试驱动开发（Test-driven development），是敏捷开发中的一种设计方法论，强调先将需求转换为具体的测试用例，然后再开发代码以使测试通过。</p><p>BDD 全称行为驱动开发（Behavior-driven development），也是一种敏捷开发设计方法论，它没有强调具体的形式如何，而是强调【作为什么角色，想要什么功能，以便收益什么】这样的用户故事指定行为的论点。</p><p>两者都是很好的开发模式，结合实际情况，我们的测试更像是 BDD，不过并没有完全摒弃 TDD，我们的建议是如果觉得先写测试可以帮助更快的写好代码，那就先写测试，如果觉得先写代码再写测试，或一边开发一边测试更好，则采用自己的方式，而结果是编码功能和测试用例都需要完成，并且运行通过，最后通过 Code Review 对代码质量做进一步审查与把控。</p><p>笔者称之为【师夷长技，聚于自身】：结合项目自身的实际情况，灵活变通，形成一套适合自身项目发展的模式驱动开发。</p><h2 id="结论" class="post-heading"><a href="#结论" class="headerlink" title="结论"></a>结论<a class="post-anchor" href="#结论" aria-hidden="true"></a></h2><p>自动化测试提供了一种有保障的机制检测整个系统，可以频繁地进行回归测试，有效提高系统稳定性。当然编写与维护测试用例需要耗费一定的成本，需要考虑投入与产出效益之间的平衡。</p><div class="post-tags" style="display:none"><a href="/tags/自动化测试/">自动化测试</a> <a href="/tags/单元测试/">单元测试</a> <a href="/tags/集成测试/">集成测试</a></div><div class="post-categories" style="display:none"><a href="/cates/Web开发/">Web开发</a></div><div class="post-announce">感谢您的阅读，本文由 <a href="//aotu.io">凹凸实验室</a> 版权所有。如若转载，请注明出处：凹凸实验室（<a href="https://aotu.io/notes/2019/12/05/ling-testing-project/">https://aotu.io/notes/2019/12/05/ling-testing-project/</a>）</div><div class="post-revision"><i class="fa fa-clock-o"></i> <time class="post-updated" datetime="2020-04-28T03:04:50.303Z">上次更新：2020-04-28 11:04:50</time></div></div><div class="post-nav"><div class="post-nav-next"><a href="/notes/2020/01/02/gmtc/" title="GMTC |《小程序跨框架开发的探索与实践》演讲全文">GMTC |《小程序跨框架开发的探索与实践》演讲全文 <i class="fa fa-chevron-right"></i></a></div><div class="post-nav-prev"><a href="/notes/2019/12/04/6-Rules-of-Thumb-for-MongoDB-Schema-Design/" title="前端也要懂一点 MongoDB Schema 设计"><i class="fa fa-chevron-left"></i> 前端也要懂一点 MongoDB Schema 设计</a></div></div><div class="post-comments" id="comments"></div><script>var gitalkOpts={id:"2019-12-05-testing",owner:"o2team",repo:"o2team.github.io",title:"羚珑项目自动化测试方案实践",body:"https://aotu.io/notes/2019/12/05/ling-testing-project/index.html\n\nJest, SuperTest, MongoDB Memory Server, CI, TDD/BDD, etc.",clientID:"3c4d153e6874260f9c7e",clientSecret:"dd44012504c6168bc05b9266e0554bb28c62ce15",admin:["Barrior"]}</script></article></div><aside class="mod-side" id="sidebar"><div class="mod-side-sec aotuwx"><img class="aotuwx-qrcode" src="/img/qrcode.jpg" alt="关注我们"><div class="aotuwx-slogan">每周推送精选技术文章</div></div><div class="mod-side-sec works"><div class="mod-side-sec-hd"><h2>服务/产品</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="//taro.jd.com" target="_blank" title="Taro">Taro</a></li><li><a href="//taro-ui.jd.com" target="_blank" title="Taro-UI">Taro-UI</a></li><li><a href="//taro-ext.jd.com" target="_blank" title="Taro 物料市场">Taro 物料市场</a></li><li><a href="//taro-club.jd.com" target="_blank" title="Taro 官方论坛">Taro 官方论坛</a></li><li><a href="//cases.aotu.io/mobi/maga.html" target="_blank" title="拇指期刊">拇指期刊</a></li><li><a href="//athena.aotu.io/" target="_blank" title="Athena">Athena</a></li><li><a href="//guide.aotu.io/" target="_blank" title="前端代码规范">前端代码规范</a></li><li><a href="//halojs.aotu.io/" target="_blank" title="HaloJS">HaloJS</a></li><li><a href="//sign.aotu.io/" target="_blank" title="邮件签名工具">邮件签名工具</a></li><li><a href="//mac.aotu.io/" target="_blank" title="MAC全栈环境">MAC全栈环境</a></li><li><a href="//xcel.aotu.io" target="_blank" title="Excel Filter">Excel Filter</a></li><li><a href="//aotu.jd.com/share/" target="_blank" title="凹凸公开课">凹凸公开课</a></li><li><a href="//at.aotu.io" target="_blank" title="AT-UI">AT-UI</a></li></ul></div></div><div class="mod-side-sec favlinks"><div class="mod-side-sec-hd"><h2>友情链接</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="https://www.cloudbase.net" target="_blank" title="小程序·云开发"><img style="width:22px;vertical-align:middle" src="https://img20.360buyimg.com/ling/jfs/t1/57175/5/15617/50216/5dca6729E00cdff5d/631622525425290e.png">小程序·云开发</a></li><li><a href="https://ling.jd.com" target="_blank" title="京东羚珑智能设计">羚珑智能设计</a></li><li><a href="https://jdc.jd.com" target="_blank" title="京东设计中心">JDC京东设计中心</a></li><li><a href="http://dopro.io/" target="_blank" title="腾讯 Deep Ocean">Deep Ocean</a></li><li><a href="http://fex.baidu.com" target="_blank" title="百度Web前端研发部">百度FEX</a></li><li><a href="http://taobaofed.org" target="_blank" title="淘宝前端团队">淘宝FED</a></li><li><a href="http://tgideas.qq.com" target="_blank" title="腾讯互娱设计中心">TGIdeas</a></li><li><a href="http://isux.tencent.com" target="_blank" title="腾讯SNG设计中心">ISUX</a></li><li><a href="http://cdc.tencent.com" target="_blank" title="腾讯用户研究与体验设计中心">CDC</a></li><li><a href="http://ued.ctrip.com" target="_blank" title="携程设计委员会">携程UED</a></li><li><a href="https://uiiiuiii.com/" target="_blank" title="优优教程网">优优教程网</a></li><li><a href="https://www.designup.cn/" target="_blank" title="Designup">Designup</a></li><li><a href="http://eux.baidu.com/" target="_blank" title="百度EUX">百度EUX</a></li></ul></div></div></aside></div></div><div class="mod-backtop" id="backTop"><i class="fa fa-long-arrow-up"></i></div><footer class="mod-ft" id="footer"><div class="grid"><ul class="mod-ft-links"><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="https://github.com/o2team/o2team.github.io" target="_blank"><i class="fa fa-github-alt"></i></a></li></ul><div class="mod-ft-sec mod-ft-copyright"><p>Designed by <a href="http://aotu.io" target="_blank">凹凸实验室</a> @<a target="_blank" href="http://jdc.jd.com">京东用户体验设计部</a></p><p>Copyright &copy; 2020. All Rights Reserved.</p><p><a href="http://www.miibeian.gov.cn/" target="_blank">粤ICP备15077732号-2</a></p></div></div></footer><script src="/js/bundle/core.js"></script><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/post_wx_share.js"></script><script src="/js/bundle/gitalk.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?e850b980d029480b092fdd7503c3f8de";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript" src="https://tajs.qq.com/stats?sId=53685723" charset="UTF-8"></script></body></html>