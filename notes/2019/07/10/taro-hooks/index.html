<!DOCTYPE html><html class="theme-lattice"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>使用 React Hooks 重构你的小程序 | Aotu.io「凹凸实验室」</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="凹凸实验室"><meta name="designer" content="凹凸实验室"><meta name="rating" content="general"><meta name="format-detection" content="telephone=yes"><meta name="robots" content="index, follow"><meta baidu-gxt-verify-token="2b74a5aea155a215abea8547f929190c"><meta name="keywords" content="Taro,小程序,凹凸实验室,Aotu,前端开发,全栈开发,IOS开发,Android开发"><link rel="canonical" href="https://aotu.io/notes/2019/07/10/taro-hooks/index.html"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png"><link rel="icon" type="image/png" sizes="48x48" href="/img/favicon-48x48.png"><link rel="manifest" href="/img/manifest.json"><meta name="mobile-web-app-capable" content="yes"><meta name="theme-color" content="#2f83cd"><meta name="application-name" content="Aotu.io"><link rel="apple-touch-icon" sizes="57x57" href="/img/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/img/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/img/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/img/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/img/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/img/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/img/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="167x167" href="/img/apple-touch-icon-167x167.png"><link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon-180x180.png"><link rel="apple-touch-icon" sizes="1024x1024" href="/img/apple-touch-icon-1024x1024.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-mobile-web-app-title" content="Aotu.io"><meta name="msapplication-TileColor" content="#fff"><meta name="msapplication-TileImage" content="/img/mstile-144x144.png"><meta name="msapplication-config" content="/img/browserconfig.xml"><meta property="wb:webmaster" content="a1686eb81db284d5"><meta name="wechat-logo" content="https://img12.360buyimg.com/ling/jfs/t1/70681/19/4118/653380/5d2589deE4524c02e/6b872ce2ea1e35d9.png"><meta name="wechat-title" content="使用 React Hooks 重构你的小程序"><meta name="wechat-desc" content="React Hooks 介绍，和它在小程序中的实践和实现。"><link rel="dns-prefetch" href="//storage.360buyimg.com"><link rel="dns-prefetch" href="//img10.360buyimg.com"><link rel="dns-prefetch" href="//img11.360buyimg.com"><link rel="dns-prefetch" href="//img12.360buyimg.com"><link rel="dns-prefetch" href="//img13.360buyimg.com"><link rel="dns-prefetch" href="//img14.360buyimg.com"><link rel="dns-prefetch" href="//img20.360buyimg.com"><link rel="dns-prefetch" href="//img30.360buyimg.com"><link rel="dns-prefetch" href="//misc.aotu.io"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" href="/atom.xml" title="Aotu.io"><meta name="description" content="本文由余澈在 GMTC 全球大前端技术 2019 的演讲：《使用 React Hooks 重构你的小程序》整理而成。  背景一直关注小程序开发的朋友应该会注意到，最开始小程序就是为了微型创新型业务打造的一个框架，最多只能运行 1m 的包。可是后来发现很多厂商把越来越多的业务搬到了小程序上，小程序的能力也在不断地开放，变得越来越强大。于是后来打包限制上升到了 2m，然后引入了分包，现在已经已经可"><meta name="keywords" content="小程序,Taro"><meta property="og:type" content="article"><meta property="og:title" content="使用 React Hooks 重构你的小程序"><meta property="og:url" content="https://aotu.io/notes/2019/07/10/taro-hooks/index.html"><meta property="og:site_name" content="Aotu.io"><meta property="og:description" content="本文由余澈在 GMTC 全球大前端技术 2019 的演讲：《使用 React Hooks 重构你的小程序》整理而成。  背景一直关注小程序开发的朋友应该会注意到，最开始小程序就是为了微型创新型业务打造的一个框架，最多只能运行 1m 的包。可是后来发现很多厂商把越来越多的业务搬到了小程序上，小程序的能力也在不断地开放，变得越来越强大。于是后来打包限制上升到了 2m，然后引入了分包，现在已经已经可"><meta property="og:locale" content="zh-cn"><meta property="og:image" content="https://i.loli.net/2019/07/02/5d1af3a5e84b022890.png"><meta property="og:image" content="https://i.loli.net/2019/07/02/5d1af4ef2dd5a56009.png"><meta property="og:updated_time" content="2020-04-28T03:04:50.303Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="使用 React Hooks 重构你的小程序"><meta name="twitter:description" content="本文由余澈在 GMTC 全球大前端技术 2019 的演讲：《使用 React Hooks 重构你的小程序》整理而成。  背景一直关注小程序开发的朋友应该会注意到，最开始小程序就是为了微型创新型业务打造的一个框架，最多只能运行 1m 的包。可是后来发现很多厂商把越来越多的业务搬到了小程序上，小程序的能力也在不断地开放，变得越来越强大。于是后来打包限制上升到了 2m，然后引入了分包，现在已经已经可"><meta name="twitter:image" content="https://i.loli.net/2019/07/02/5d1af3a5e84b022890.png"><meta name="twitter:site" content="o2circle"><script>var App={root:"/",isHome:!1,isCate:!1,isTag:!1}</script><script>window.WechatShareData={imgUrl:"https://img12.360buyimg.com/ling/jfs/t1/70681/19/4118/653380/5d2589deE4524c02e/6b872ce2ea1e35d9.png",link:window.location.href,title:"使用 React Hooks 重构你的小程序",desc:"React Hooks 介绍，和它在小程序中的实践和实现。"},window.WechatJSSDKURL="https://aotu.jd.com/aotu-wx-api/api/wx/jssdk/signature"</script></head><body class="page-post-detail"><div class="mod-hd"><div class="grid"><div class="mod-logo"><a href="/index.html" title="Aotu.io">Aotu.io</a></div><span class="mod-hd-toggle" id="J_hdToggle"><i class="fa fa-bars"></i></span><div class="mod-hd-main"><div class="mod-hd-inner"><nav class="mod-nav"><ul class="mod-nav-list"><li class="main-nav-item"><a href="/index.html" class="main-nav-link">首页</a></li><li class="main-nav-item"><a target="_blank" href="https://geeks.aotu.io" class="main-nav-link">极客沙龙</a></li><li class="main-nav-item"><a href="https://cases.aotu.io" class="main-nav-link">H5案例</a></li><li class="main-nav-item"><a href="/about/" class="main-nav-link">关于</a></li><li class="main-nav-item"><a href="/join/" class="main-nav-link">加入我们</a></li></ul></nav><div class="mod-search" id="J_search"><a class="fa fa-search mod-search-ico" id="J_searchTrigger" title="搜索"></a><form id="J_searchForm" method="get" class="mod-search-form" action="/search/"><input type="text" name="query" class="mod-search-ipt" id="J_searchInput" placeholder="搜索"></form></div></div></div></div></div><div class="mod-container"><div class="grid"><div class="mod-main typo"><article class="post"><div class="post-cover"><img src="https://img12.360buyimg.com/ling/jfs/t1/70681/19/4118/653380/5d2589deE4524c02e/6b872ce2ea1e35d9.png" alt="使用 React Hooks 重构你的小程序"></div><header class="post-hd"><h1 class="post-tit">使用 React Hooks 重构你的小程序</h1><div class="post-meta">by <a target="_blank" href="https://github.com/yuche" class="post-author">yuche</a> on <span>2019-07-10</span></div><p class="post-subtit" style="display:none"><i class="fa fa-quote-left"></i>React Hooks 介绍，和它在小程序中的实践和实现。</p><span style="display:none" id="busuanzi_value_page_pv"></span></header><div class="post-content"><a id="more"></a><blockquote><p>本文由余澈在 GMTC 全球大前端技术 2019 的演讲：<a href="https://gmtc.infoq.cn/2019/beijing/presentation/1706" target="_blank" rel="noopener">《使用 React Hooks 重构你的小程序》</a>整理而成。</p></blockquote><h2 id="背景" class="post-heading"><a href="#背景" class="headerlink" title="背景"></a>背景<a class="post-anchor" href="#背景" aria-hidden="true"></a></h2><p>一直关注小程序开发的朋友应该会注意到，最开始小程序就是为了微型创新型业务打造的一个框架，最多只能运行 1m 的包。可是后来发现很多厂商把越来越多的业务搬到了小程序上，小程序的能力也在不断地开放，变得越来越强大。于是后来打包限制上升到了 2m，然后引入了分包，现在已经已经可以上传 8m 的小程序。其实这个体积已经可以实现非常巨型非常复杂的业务了。就从 Taro 的用户来看，例如京东购物小程序和 58 同城小程序不管从代码的数量还是复杂度都不亚于 PC 端业务，所以我们可以说前端开发的复杂度正在向小程序端转移。</p><p>而小程序开发其实也是前端开发的一个子集，在整个前端业界，我们又是怎么解决复杂度这个问题的呢？</p><p>首先我们看看 React：React Core Team 成员，同时也是 Redux 的作者 Dan Abramov 在 2018 年的 ReactConf 向大家首次介绍了 React Hooks。React Hooks 是为了解决 Class Component 的一些问题而引入的：</p><ul><li>Class Component 组件间的逻辑难以复用。因为 JavaScript 不像 Go 或 C++ 一样，Class 可以多重继承，类的逻辑的复用就成了一个问题；</li><li>复杂组件难以理解。Class Component 经常会在生命周期做一些数据获取事件监听的副作用函数，这样的情况下我们就很难把组件拆分为更小的力度；</li><li>Class 令人迷惑。很多新手应该会被 Class 组件绑定事件的 <code>this</code> 迷惑过，绑定事件可以用 bind，可以直接写箭头函数，也可以写类属性函数，但到底哪种方法才是最好的呢？而到了 ES 2018，class 还有多种语法，例如装饰器，例如 private fileds 这些奇奇怪怪的语法也为新手增加了更多的困惑。</li></ul><p>而对于 Vue 而言也有相同的问题，Vue 的作者尤玉溪老师在 VueConf China 2019 也给 Vue 3.0 引入了一个叫 <em>Functional-based API</em> 的概念，它是受 React Hooks 启发而增加的新 API。由于 Vue 2.0 组件组合的模式是对象字面量形式，所以 <em>Functional-based API</em> 可以作为 Mixins 的替代，配合新的响应式 API 作为新的组件组合模式。那么对于 Vue 3.0 我们还知之甚少，以后的 API 也有可能改变，但或许是英雄所见略同，React 和 Vue 对于降低前端开发复杂度这一问题都不约而同地选择了 Hooks 这一方案，这到底是为什么呢？</p><p><img src="https://i.loli.net/2019/07/02/5d1af3a5e84b022890.png" alt="why_hooks.png"></p><p>我们可以一下之前的组件组合方案，首先是 <em>Mixins</em>，红色圈的 <em>Mixins</em>，黄色的是组件，我们知道 <em>Mixins</em> 其实就是把多个对象组合成一个对象，<em>Mixins</em> 的过程就有点像调用 <code>Object.assgin</code> 方法。那 <em>Mixins</em> 有什么问题呢？首先是命名空间耦合，如果多个对象同名参数，这些参数就会耦合在一起；其次由于 <em>Mixins</em> 必须是运行时才能知道具体有什么参数，所以是 TypeScript 是无法做静态检查的；第三是组件参数不清晰，在 <em>Mixins</em> 中组件的 props 和其他参数没什么两样，很容易被其它的 <em>Mixins</em> 覆盖掉。</p><p>为了解决 <em>Mixins</em> 的问题，后来发展出了高阶组件（<em>HOC</em>）的方式，高阶组件就和图里一样，一个组件嵌套着另外的组件。它的确解决了 <em>Mixins</em> 的一些问题，例如命名空间解耦，由于每次都会生成新组件，就不存在命名空间问题了；其次它也能很好地做静态检查；但它依然没有办法处理组件 props 的问题，props 还是有可能会在高阶组件中被更改；而且它还有了新的问题，每多用一次高阶组件，都会多出一个组件实例。</p><p>最后我们来看一下 Hooks，紫色的圈圈是 Hooks，就像图里一样，Hooks 都在同一个组件里，Hooks 之间还可以相互调用。因为 Hooks 跑在一个普通函数式组件里，所以他肯定是没有命名空间的问题，同时 TypeScript 也能对普通函数做很好的静态检查，而且 Hooks 也不能更改组件的 Props，传入的是啥最后可用的就是啥；最后 Hooks 也不会生成新的组件，所以他是单组件实例。</p><p><img src="https://i.loli.net/2019/07/02/5d1af4ef2dd5a56009.png" alt="taroxhooks.png"></p><p>在 Taro 1.3 版本，我们实现了一大堆特性，其中的重头戏就是 React Hooks 的支持。虽然 React Hooks 正式稳定的时间并不长，但我们认为这个特性能有效地简化开发模式，提升开发效率和开发体验。即便 Hooks 的生态和最佳实践还尚未完善，但我们相信未来 Hooks 会成为 React 开发模式的主流，也会深刻地影响其它框架未来的 API 构成。所以在 Taro 的规划中我们也把 Hooks 放在了很重要的位置。</p><h2 id="什么是-Hooks？" class="post-heading"><a href="#什么是-Hooks？" class="headerlink" title="什么是 Hooks？"></a>什么是 Hooks？<a class="post-anchor" href="#什么是-Hooks？" aria-hidden="true"></a></h2><p>相信笔者扯了那么多，大家对 Hooks 应该产生了一些兴趣，那什么是 Hooks 呢？简单来说，Hooks 就是一组在 React 组件中运行的函数，让你在不编写 Class 的情况下使用 state 及其它特性。具体来说，Hooks 可以表现为以下的形式：</p><h3 id="useState-与内部状态" class="post-heading"><a href="#useState-与内部状态" class="headerlink" title="useState 与内部状态"></a><code>useState</code> 与内部状态<a class="post-anchor" href="#useState-与内部状态" aria-hidden="true"></a></h3><p>我们可以看一个原生小程序的简单案例，一个简单计数器组件，点击按钮就 + 1，相信每位前端开发朋友都可以轻松地写一个计数器组件。但我们可以稍微改一下代码，把事件处理函数改为箭头函数。如果是这样代码就跑不了了。事实上在原生开发中 <code>this</code> 的问题是一以贯之的，所以我们经常要开个新变量把 <code>this</code> 缓存起来，叫做 <code>self</code> 什么的来避免类似的问题。我们之前也提到过，如果采用 ES6 的 Class 来组织组件同样也会遇到 <code>this</code> 指向不清晰的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  increment: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 这里写箭头函数就跑不了了</span></span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.data.count + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再来看看我们的 hooks 写法，我们引入了一个叫 useState 的函数，它接受一个初始值参数，返回一个元组，如果是写后端的同学应该对这个模式比较熟悉，就像 Koa 或者 Go 一样，一个函数返回两个值或者说叫一个元组，不过我们返回的第一个参数是当前的状态，一个是设置这个状态的函数，每次调用这个设置状态的 <code>setState</code> 函数都会使得整个组件被重新渲染。然后用 ES6 的结构语法把它俩解构出来使用。</p><p>然后我们在定义一个增加的函数，把他绑定到 <code>onClick</code> 事件上。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个值和一个设置值的函数              </span></span><br><span class="line">  <span class="comment">// 每次设置值之后会重新渲染组件</span></span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">increment</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setCount(count + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;View&gt;</span><br><span class="line">      &lt;Text&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Button onClick=&#123;increment&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Button&gt;</span><br><span class="line">    &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>同样是非常简单的代码。如果你熟悉 Taro 之前的版本的话就会知道这样的代码在以前的 Taro 是跑不了的，不过 Taro 1.3 之后事件传参可以传入任何合法值，你如果想直接写箭头函数或者写一个柯里化的函数也是完全没有问题的。</p><p>大家可以发现我们使用的 Hooks 就是一个非常简单非常 normal 的函数，没有 <code>this</code> 没有 class，没有类构造函数，没有了 <code>this</code>，再也不会出现那种 <code>this</code>、<code>self</code> 傻傻分不清楚的情况。</p><p>大家可以记住这个简单的计数器组件，以后之后讲的很多案例是基于这个组件做的。</p><h3 id="useEffect-与副作用" class="post-heading"><a href="#useEffect-与副作用" class="headerlink" title="useEffect 与副作用"></a><code>useEffect</code> 与副作用<a class="post-anchor" href="#useEffect-与副作用" aria-hidden="true"></a></h3><p>接下来我们看一个稍微复杂一些的例子，一个倒计时组件，我们点击按钮就开始倒计时，再点击就停止倒计时。在我们这个组件里有两个变量，<code>start</code> 用于控制是否开始计时，<code>time</code> 就是我们的倒计时时间。这里注意我们需要多次清除 <code>interval</code>，而在现实业务开发中，这个 <code>touchStart</code> 函数可能会复杂得多，一不小心就会提前清除 <code>interval</code> 或忘记清除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    time: <span class="number">60</span></span><br><span class="line">  &#125;,</span><br><span class="line">  start: <span class="literal">false</span>,</span><br><span class="line">  toggleStart () &#123;</span><br><span class="line">    <span class="keyword">this</span>.start = !<span class="keyword">this</span>.start</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.start) &#123;</span><br><span class="line">      <span class="keyword">this</span>.interval = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">          time: <span class="keyword">this</span>.data.time - <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      clearInterval(<span class="keyword">this</span>.interval)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  onUnload () &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.interval)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">"toggleStart"</span>&gt;</span></span><br><span class="line">    &#123;&#123;time&#125;&#125; </span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而我们 Hooks 的例子会是这样：我们引入了一个 <code>useEffect</code> 函数。之前我们提到过，每次调用 <code>useState</code> 返回的 <code>setState</code> 函数都会重新调用整个函数，其实就包括了 <code>useEffect</code> 函数，<code>useEffect</code> 接受两个参数。第一个就是副作用，也就是 <code>effect</code> 函数，他不接受也不返回任何参数。<br>第二个参数是依赖数组，当数组中的变量变化时就会调用，第一个参数 <code>effect</code> 函数。<br><code>Effect</code> 函数还可以返回一个函数，这个函数在下一次 <code>effect</code> 函数被调用时或每次组件被注销时或者就会调用，我们可以在这里清楚掉一些事件的订阅或者 interval 之类可能会导致内存泄露的行为。<br>在我们这个例子中，当 <code>start</code> 每次变化就会重新跑一次 <code>effect</code> 函数，每隔一秒会设置一次 <code>time</code> 的值让它减一，但这样的写法是有问题的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ start, setStart ] = useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> [ time, setTime ] = useState(<span class="number">60</span>)</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// effect 函数，不接受也不返回任何参数</span></span><br><span class="line">    <span class="keyword">let</span> interval</span><br><span class="line">    <span class="keyword">if</span> (start) &#123;</span><br><span class="line">      interval = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// setTime(time - 1) ❌ time 在 effect 闭包函数里是拿不到准确值的</span></span><br><span class="line">        setTime(<span class="function"><span class="params">t</span> =&gt;</span> t <span class="number">-1</span>) <span class="comment">// ✅ 在 setTime 的回调函数参数里可以拿到对应 state 的最新值</span></span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(interval) <span class="comment">// clean-up 函数，当前组件被注销时调用</span></span><br><span class="line">  &#125;, [ start ]) <span class="comment">// 依赖数组，当数组中变量变化时会调用 effect 函数</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;View&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; setStart(!start)&#125;&gt;&#123;time&#125;&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>View&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们在 <code>setInterval</code> 这个函数的闭包中，我们捕捉到 <code>time</code> 这个变量的值不能和最新的值对应得上，<code>time</code> 的值有可能在我们意料之外地被更改了多次。解决的方案也很简单，之前我们提到过 <code>useState</code> 返回的 <code>setState</code> 方法，可以接受一个函数作为参数，而这个函数的参数，就是 <code>state</code> 最新的值，所以只要我们传入一个函数就好了。这是其中一种方法。</p><p>还有另一种方法是使用 <code>useRef</code> Hooks，<code>useRef</code> 可以返回一个可变的引用，它会生成一个对象，对象里这个有 <code>current</code> 属性，而 <code>current</code> 的值是可变的。在我们这个例子里，每次更改 <code>currentTime.current</code> 都是同步的，而且 <code>currentTime</code> 是一个引用，所以 <code>currentTime.current</code> 一定是可控的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ start, setStart ] = useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> [ time, setTime ] = useState(<span class="number">60</span>)</span><br><span class="line">  <span class="keyword">const</span> currentTime = useRef(time) <span class="comment">// 生成一个可变引用</span></span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// effect 函数，不接受也不返回任何参数</span></span><br><span class="line">    <span class="keyword">let</span> interval</span><br><span class="line">    <span class="keyword">if</span> (start) &#123;</span><br><span class="line">      interval = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setTime(currentTime.current--) <span class="comment">// currentTime.current 是可变的</span></span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(interval) <span class="comment">// clean-up 函数，当前组件被注销时调用</span></span><br><span class="line">  &#125;, [ start ]) <span class="comment">// 依赖数组，当数组中变量变化时会调用 effect 函数</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;View&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; setStart(!start)&#125;&gt;&#123;time&#125;&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>View&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然说我们可以 <code>useRef</code> 来解决这个问题，但是没必要这样做。因为 <code>setTime</code> 传递一个回调函数的方法显然可读性更高。真正有必要的是把我们的 <code>interval</code> 变量作为一个 ref，我们在函数最顶层的作用域把 <code>interval</code> 作为一个 ref，这样我们就可以在这个函数的任何一个地方把他清除，而原来的代码中我们把 <code>interval</code> 作为一个普通的变量放在 effect 函数里，这样如果我们有一个事件也需要清除 interval，这就没法做到了。但是用 <code>useRef</code> 生成可变引用就没有这个限制。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ start, setStart ] = useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> [ time, setTime ] = useState(<span class="number">60</span>)</span><br><span class="line">  <span class="keyword">const</span> interval = useRef() <span class="comment">// interval 可以在这个作用域里任何地方清除和设置</span></span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// effect 函数，不接受也不返回任何参数</span></span><br><span class="line">    <span class="keyword">if</span> (start) &#123;</span><br><span class="line">      interval.current = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setTime(<span class="function"><span class="params">t</span> =&gt;</span> t - <span class="number">1</span>) <span class="comment">// ✅ 在 setTime 的回调函数参数里可以拿到对应 state 的最新值</span></span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> clearInterval(interval.current) <span class="comment">// clean-up 函数，当前组件被注销时调用</span></span><br><span class="line">  &#125;, [ start ]) <span class="comment">// 依赖数组，当数组中变量变化时会调用 effect 函数</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;View&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; setStart(!start)&#125;&gt;&#123;time&#125;&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>View&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="useContext-与跨组件通信" class="post-heading"><a href="#useContext-与跨组件通信" class="headerlink" title="useContext 与跨组件通信"></a><code>useContext</code> 与跨组件通信<a class="post-anchor" href="#useContext-与跨组件通信" aria-hidden="true"></a></h3><p>接下来我们再来看一个跨组件通信的例子，例如我们有三个组件，<em>page</em> 组件有一个 <em>child</em> 组件，<em>child</em> 组件有一个 <em>counter</em> 组件，而我们 <em>counter</em> 组件的 <code>count</code> 值和 <code>setCount</code> 函数，是由 <em>page</em> 组件传递下来的。这种情况在一个复杂业务的开发中也经常能遇到，在原生小程序开发中我们应该怎么做呢？</p><p>我们需要手动的把我们 <code>counter</code> 的值和函数手动地依次地传递下去，而这样的传递必须是显式的，你需要在 JavaScript 中设置 props 的参数，也需要在 WXML 里设置 props 的参数，一个也不能少，少了就跑不动。我们还注意到即便 child 组件没有任何业务逻辑，他也必须要设置一个 <code>triggerEvent</code> 的函数和 props 的类型声明。这样的写法无疑是非常麻烦而且限制很大的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- page.wxml --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- child.wxml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- counter.wxml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span>&gt;</span></span><br><span class="line">    You clicked &#123;&#123;count&#125;&#125; times</span><br><span class="line">  <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">butto</span> <span class="attr">bindtap</span>=<span class="string">"increment"</span>&gt;</span></span><br><span class="line">    Click me</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// page.js</span></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  increment () &#123;</span><br><span class="line">    <span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.data.count + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// child.js</span></span><br><span class="line">Component(&#123;</span><br><span class="line">  properties: &#123;</span><br><span class="line">    count: <span class="built_in">Number</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment () &#123;</span><br><span class="line">      <span class="keyword">this</span>.triggerEvent(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// counter.js</span></span><br><span class="line">Component(&#123;</span><br><span class="line">  properties: &#123;</span><br><span class="line">    count: <span class="built_in">Number</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment () &#123;</span><br><span class="line">      <span class="keyword">this</span>.triggerEvent(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>而我们可以看看 Hooks 的写法，首先我们用 <code>Taro.createContext</code> 创建一个 <code>context</code> 对象，在我们 <em>page</em> 组件里把我们的 <code>count</code> 和 <code>setCount</code> 函数作为一个对象传入到 <code>Context.Provider</code> 的 <code>value</code> 里。然后在我们的 <em>Counter</em> 组件，我们可以使用 <code>useContext</code> 这个 Hooks 把我们的 <code>count</code> 和 <code>setCount</code> 取出来，就直接可以使用了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CounterContext = Taro.createContext(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// page.js</span></span><br><span class="line"><span class="keyword">const</span> Page = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;CounterContext.Provider value=&#123;&#123; count, setCount &#125;&#125;&gt;</span><br><span class="line">      &lt;Child /&gt;</span><br><span class="line">    &lt;<span class="regexp">/CounterContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ child.js</span></span><br><span class="line"><span class="regexp">const Child = () =&gt; (</span></span><br><span class="line"><span class="regexp">  &lt;View&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Counter /</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ counter.js</span></span><br><span class="line"><span class="regexp">const Counter = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const &#123; count, setCount &#125; = useContext(CounterContext)</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;View&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Text&gt;</span></span><br><span class="line"><span class="regexp">        You clicked &#123;count&#125; times</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Text&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; setCount(count + <span class="number">1</span>)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>View&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以发现使用 Context 的代码比原来的代码精简了很多，参数不需要一级一级地显式传递，<em>child</em> 组件也和事实一样，没有一行多余的逻辑。但精简不是最大的好处。最大的好处是大家可以发现我们的 Context 可以传递一个复杂的对象，熟悉小程序原生开发的同学可能会知道，所有 props 的传递都会被小程序序列化掉，如果传递了一个复杂的对象最终会变成一个 JSON。但是用 Taro 的 context 则没有这层限制，你可以传入一个带有函数的对象，也可以传入像是 <code>imutabale</code> 或者 <code>obserable</code> 这样复杂的对象。在 taro 1.3 我们对 props 系统进行了一次重构，Taro 的 context 和 props 一样，属性传递没有任何限制，想传啥就传啥。</p><p>另外一个值得注意的点的是，context 的传递可以无视父级组件的更新策略，在这个例子中即便我们通过 <code>shouldComponentUpdate()</code> 禁止了 <em>child</em> 组件的更新，但 <em>counter</em> 作为它的子组件依然是可以更新的。这个特性可以让我们做性能优化的时候更为灵活一些。</p><h2 id="Hooks-在小程序实战" class="post-heading"><a href="#Hooks-在小程序实战" class="headerlink" title="Hooks 在小程序实战"></a>Hooks 在小程序实战<a class="post-anchor" href="#Hooks-在小程序实战" aria-hidden="true"></a></h2><p>讲完了 Hooks 的基本使用，有些同学会觉得：咦，我怎么觉得你这几个东西感觉平平无奇，没什么特别的。但实际上这些基础的 Hooks 单独拿出来看的确不能玩出什么花样，但他们组合起来却能迸发强大的力量。</p><h3 id="自定义-Hooks" class="post-heading"><a href="#自定义-Hooks" class="headerlink" title="自定义 Hooks"></a>自定义 Hooks<a class="post-anchor" href="#自定义-Hooks" aria-hidden="true"></a></h3><p>大家在业务开发可能会遇到这样的需求，实现一个双击事件，如果你是从 H5 开发过来的可能会直接写 <code>onDoubleClick</code>，但很遗憾，小程序组件是没有 <code>doubleClick</code> 这个事件的。当然，如果你使用 Taro 又用了 TypeScript 就不会犯这样的错误，编辑器就回直接给你报错 <code>Text</code> 组件没有这个属性。</p><p>于是你就自己实现了一个双击事件，代码大概是这样，有一个上次点击的时间作为状态，每次触发单机事件的时候和上次点击的时间做对比，如果间隔过小，那他就是一个双击事件。代码非常简单，但我们不禁就会产生一个问题问题，每一次给一个组件加单击事件，我们就每次都加这么一坨代码吗？</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EditableText</span> (<span class="params">&#123; title &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ lastClickTime, setClickTime ] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [ editing, setEditing ] = useState(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;View&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        editing</span><br><span class="line">          ? <span class="xml"><span class="tag">&lt;<span class="name">TextInput</span> <span class="attr">editing</span>=<span class="string">&#123;editing&#125;</span> /&gt;</span></span></span><br><span class="line">          : &lt;Text</span><br><span class="line">            onClick=&#123;e =&gt; &#123;</span><br><span class="line">              const currentTime = e.timeStamp</span><br><span class="line">              const gap = currentTime - lastClickTime</span><br><span class="line">              if (gap &gt; 0 &amp;&amp; gap &lt; 300) &#123; // double click</span><br><span class="line">                setEditing(true)</span><br><span class="line">              &#125;</span><br><span class="line">              setClickTime(currentTime)</span><br><span class="line">            &#125;&#125;</span><br><span class="line">          &gt;</span><br><span class="line">            &#123;title&#125;</span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们就可以写一个自定义 Hooks，代码和原来的代码也差不多，<code>useDoubleClick</code> 不接受任何参数，但当我们调用 <code>useDoubleClick</code> 时候返回一个名为 <code>textOnDoubleClick</code> 的函数，在在 Text 组件的事件传参中，我们再在 <code>textOnDoubleClick</code> 函数中传入一个回调函数，这个回调函数就是触发双击条件时候的函数。当我们给这个自定义 Hooks 做了柯里化之后，我们就可以做到知道 Hook 使用时才暴露回调函数:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDoubleClick</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ lastClickTime, setClickTime ] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">callback</span>) =&gt;</span> <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> currentTime = e.timeStamp</span><br><span class="line">    <span class="keyword">const</span> gap = currentTime - lastClickTime</span><br><span class="line">    <span class="keyword">if</span> (gap &gt; <span class="number">0</span> &amp;&amp; gap &lt; <span class="number">300</span>) &#123;</span><br><span class="line">      callback &amp;&amp; callback(e)</span><br><span class="line">    &#125;</span><br><span class="line">    setClickTime(currentTime)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EditableText</span> (<span class="params">&#123; title &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ editing, setEditing ] = useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> textOnDoubleClick = useDoubleClick()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;View&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        editing</span><br><span class="line">          ? <span class="xml"><span class="tag">&lt;<span class="name">TextInput</span> <span class="attr">editing</span>=<span class="string">&#123;editing&#125;</span> /&gt;</span></span></span><br><span class="line">          : &lt;Text</span><br><span class="line">            onClick=&#123;textOnDoubleClick(() =&gt;</span><br><span class="line">              setEditing(true)</span><br><span class="line">            )&#125;</span><br><span class="line">          &gt;</span><br><span class="line">            &#123;title&#125;</span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>柯里化函数好像有一点点绕，但一旦我们完成了这一步，这种我们的自定义 hooks 就可以像多次调用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EditableText</span> (<span class="params">&#123; title &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> textOnDoubleClick = useDoubleClick()</span><br><span class="line">  <span class="keyword">const</span> buttonOnDoubleClick = useDoubleClick()</span><br><span class="line">  <span class="comment">// 任何实现单击类型的组件都有自己独立的双击状态</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;View&gt;</span><br><span class="line">      &lt;Text onClick=&#123;textOnDoubleClick(...)&#125;&gt;</span><br><span class="line">        &#123;title&#125;</span><br><span class="line">      &lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Button onClick=&#123;buttonOnDoubleClick(...)&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>每一个大家不妨试想如果按照我们传统的 render props 实现，每次都要多写一个 container 组件，如果用 Mixins 或高阶组件来实现就更麻烦，我们需要基于每个不同类型的组件创造一个新的组件。而使用 Hooks，任何一个实现了单机类型的组件都可以通过我们的自定义 Hook 实现双击效果，不管从它的内部实现来看，还是从它暴露的 API 来看都是非常优雅的。</p><h3 id="性能优化" class="post-heading"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化<a class="post-anchor" href="#性能优化" aria-hidden="true"></a></h3><p>接下来我们谈一下性能优化，相信大家也有过这种情况，有一个数组，他只需拿到他的 props 要渲染一次，从此之后他就再也不需要更新了。对于传统而言的 Class Component 我们可以设置 <code>shouldComponentUpdate()</code> 返回 <code>false</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Numbers</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  shouldComponentUpdate () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;</span></span><br><span class="line"><span class="xml">       expensive(this.props.array).map(i =&gt; <span class="tag">&lt;<span class="name">View</span>&gt;</span>&#123;i&#125;<span class="tag">&lt;/<span class="name">View</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于函数式组件而言，我们也可以做一样的事情。Taro 和 React 一样提供 <code>Taro.memo</code> API，他的第一个参数接受一个函数式组件，第二个参数和我们的 <code>shouldComponentUpdate()</code> 一样，判断组件在什么样的情况下需要更新。如果第二个参数没有传入的话，<code>Taro.memo</code> 的效果就和 <code>Taro.PureComponent</code> 一样，对新旧 props 做一层浅对比，如果浅对比不相等则更新组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Numbers</span> (<span class="params">&#123; array &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;View&gt;</span><br><span class="line">      &#123;</span><br><span class="line">       expensive(array).map(</span><br><span class="line">         i =&gt; <span class="xml"><span class="tag">&lt;<span class="name">View</span>&gt;</span>&#123;i&#125;<span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line">       )</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Taro.memo(Numbers, () =&gt; true)</span></span><br></pre></td></tr></table></figure><p>第二种情况我们可以看看我们的老朋友，计数器组件。但是这个计数器组件和老朋友有两点不一样：第一是每次点击 + 1，计数器需要调用 <code>expensive</code> 函数循环 1 亿次才能拿到我们想要的值，第二点是它多了一个 <code>Input</code> 组件。在我们真实的业务开发中，这种情况也很常见：我们的组件可能需要进行一次昂贵的数据处理才能得到最终想要的值，但这个组件又还有多个 state 控制其它的组件。在这种情况下，我们如果正常书写业务逻辑是有性能问题的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [val, setValue] = useState(<span class="string">''</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">expensive</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count * <span class="number">1e9</span>; i++) &#123;</span><br><span class="line">      sum += i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;View&gt;</span><br><span class="line">      &lt;Text&gt;You clicked &#123;expensive()&#125; times&#125;&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Button&gt;</span><br><span class="line">      &lt;Input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.detail.value)&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>因为我们 <code>count</code> 的值跟 <code>Input</code> 的值没有关系，但我们每次改变 <code>Input</code> 的值，就会触发这个组件重新渲染。也就是说这个循环一亿次的 <code>expensive()</code> 函数就会重新调用。这样情况显然是不能接受的。为了解决这个问题，我们可以使用 <code>useMemo</code> API。<code>useMemo</code> 的签名和 <code>useEffect</code> 有点像，区别就在于 <code>useMemo</code> 的第一个函数有返回值，这个函数返回的值同时也是 <code>useMemo</code> 函数的返回值。而第二个参数同样是依赖数组，只有当这个数组的数据变化时候，<code>useMemo</code> 的函数才会重新计算，如果数组没有变化，那就直接从缓存中取数据。在我们这个例子里我们只需要 <code>count</code> 变化才进行计算，而 Input value 变化无需计算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [ count, setCount ] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [val, setValue] = useState(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">const</span> expensive = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count * <span class="number">100</span>; i++) &#123;</span><br><span class="line">      sum += i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">  &#125;, [ count ]) <span class="comment">// ✅ 只有 count 变化时，回调函数才会执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;View&gt;</span><br><span class="line">      &lt;Text&gt;You Clicked &#123;expensive&#125; times&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Button&gt;</span><br><span class="line">      &lt;Input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.detail.value)&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>我们刚才提到的两个 memo 的 API ，他的全称其实是 <em>Memoization</em>。由于 Hooks 都是在普通函数中运行的，所以我们要做好性能优化，一定要好好利用缓存和记忆化这一技术。</p><blockquote><p>在计算机科学中，记忆化（Memoization）是一种提高程序运行速度的优化技术。通过储存大计算量函数的返回值，当这个结果再次被需要时将其从缓存提取，而不用再次计算来节省计算时间。</p></blockquote><h3 id="大规模状态管理" class="post-heading"><a href="#大规模状态管理" class="headerlink" title="大规模状态管理"></a>大规模状态管理<a class="post-anchor" href="#大规模状态管理" aria-hidden="true"></a></h3><p>提到状态管理，React 社区最有名的工具当然是 Redux。在 <code>react-redux@7</code> 中新引用了三个 API:</p><ol><li><code>useSelector</code>。它有点像 <code>connect()</code> 函数的第一个参数 <code>mapStateToProps</code>，把数据从 state 中取出来；</li><li><code>useStore</code> 。返回 <code>store</code> 本身；</li><li><code>useDispatch</code>。返回 <code>store.dispatch</code>。</li></ol><p>在 Taro 中其实你也可以使用我们之前提到过的 <code>createContext</code> 和 <code>useContext</code> 直接就把 <code>useStore</code> 和 <code>useDispatch</code> 实现了。而基于 <code>useStore</code> 和 <code>useDispatch</code> 以及 <code>useState</code>，<code>useMemo</code>，<code>useEffect</code> 也可以实现 <code>useSelector</code>。也就是说 <code>react-redux@7</code> 的新 API 全都是普通 Hooks 构建而成的自定义 Hooks。当然我们也把 <code>react-redux@7</code> 的新功能移植到了 <code>@tarojs/redux</code>，在 Taro 1.3 版本你可以直接使用这几个 API。</p><h2 id="Hooks-的实现" class="post-heading"><a href="#Hooks-的实现" class="headerlink" title="Hooks 的实现"></a>Hooks 的实现<a class="post-anchor" href="#Hooks-的实现" aria-hidden="true"></a></h2><p>我们现在对 Hooks 已经有了以下的了解，一个合法的 Hooks ，必须满足以下需求才能执行:</p><ul><li>只能在函数式函数中调用</li><li>只能在函数最顶层中调用</li><li>不能在条件语句中调用</li><li>不能在循环中调用</li><li>不能在嵌套函数中调用</li></ul><p>我想请大家思考一下，为什么一个 Hook 函数需要满足以上的需求呢？我想请大家以可以框架开发者的角度去思考下这个问题，而不是以 API 的调用者的角度去逆向地思考。当一个 Hook 函数被调用的时，这个 Hook 函数的内部实现应该可以访问到当前正在执行的组件，但是我们的 Hooks API 的入参却没有传入这个组件，那究竟是怎么样的设计才可以让我们的 hook 函数访问到正在执行的组件，也能够准确地定位自己呢？</p><p>聪明的朋友或许已经猜到了，这些所有线索都指向一个结果，<strong>Hooks 必须是一个按顺序执行的函数</strong>。也就是说，不管整个组件执行多少次，渲染多少次，组件中 Hooks 的顺序都是不会变的。</p><p>我们还知道另外一条规则，Hooks 是 React 函数内部的函数，于是我们就可以知道，要实现 Hooks 最关键的问题在于两个:</p><ol><li>找到正在执行的 React 函数</li><li>找到正在执行的 Hooks 的顺序。</li></ol><p>我们可以设置一个全局的对象叫 <code>CurrentOwner</code>，它有两个属性，第一个是 <code>current</code>，他是正在执行的 <code>Taro</code> 函数，我们可以在组件加载和更新时设置它的值，加载或更新完毕之后再设置为 <code>null</code>；第二个属性是 <code>index</code>，它就是 <code>CurrentOwner.current</code> 中 Hooks 的顺序，每次我们执行一个 Hook 函数就自增 1。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CurrentOwner: &#123;</span><br><span class="line">  current: <span class="literal">null</span> | Component&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt;,</span><br><span class="line">  index: <span class="built_in">number</span></span><br><span class="line">&#125; = &#123;</span><br><span class="line">  <span class="comment">// 正在执行的 Taro 函数,</span></span><br><span class="line">  <span class="comment">// 在组件加载和重新渲染前设置它的值</span></span><br><span class="line">  current: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// Taro 函数中 hooks 的顺序</span></span><br><span class="line">  <span class="comment">// 每执行一个 Hook 自增</span></span><br><span class="line">  index: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 React 中其实也有这么一个对象，而且你还可以使用它，它叫做 <code>__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner</code>，也就是说如果你想给 React 15 实现 Hooks，其实也可以做到的。但也正如它的名字一样，如果你用了说不定就被 fire 了，被优化了，所以更好的方案还是直接使用我们 taro。</p><p>接下来我们来实现我们的 <code>getHook</code> 函数，同样很简单，如果 <code>CurrenOwner.current</code> 是 <code>null</code>，那这就不是一个合法的 hook 函数，我们直接报错。如果满足条件，我们就把 hook 的 <code>index</code> + 1，接下来我们把组件的 Hooks 都保存在一个数组里，如果 <code>index</code> 大于 Hooks 的长度，说明 Hooks 没有被创造，我们就 push 一个空对象，避免之后取值发生 runtime error。然后我们直接返回我们的 Hook。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHook</span> (<span class="params"></span>): <span class="title">Hook</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (CurrentOwner.current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`invalid hooks call: hooks can only be called in a taro component.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> index = CurrentOwner.index++ <span class="comment">// hook 在该 Taro 函数中的 ID</span></span><br><span class="line">  <span class="keyword">const</span> hooks: Hook[] = CurrentOwner.current.hooks <span class="comment">// 所有的 hooks</span></span><br><span class="line">  <span class="keyword">if</span> (index &gt;= hooks.length) &#123; <span class="comment">// 如果 hook 还没有创建</span></span><br><span class="line">    hooks.push(&#123;&#125; <span class="keyword">as</span> Hook) <span class="comment">// 对象就是 hook 的内部状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hooks[index] <span class="comment">// 返回正在执行的 hook 状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然我们已经找到了我们正在执行的 Hooks，完整地实现 Hooks 也就不难了。之前我们讨论过 <code>useState</code> 的签名，现在我们一步一步地看他的实现。</p><p>首先如果 <code>initState</code> 是函数，直接执行它。其次调用我们我们之前写好的 <code>getHook</code> 函数，它返回的就是 Hook 的状态。接下来就是 useState 的主逻辑，如果 hook 还没有状态的话，我们就先把正在执行的组件缓存起来，然后 <code>useState</code> 返回的，就是我们的 <code>hook.state</code>, 其实就是一个数组，第一个值当然就是我们 <code>initState</code>，第一个参数是一个函数，它如果是一个函数，我们就执行它，否则就直接把参数赋值给我们 的 <code>hook.state</code> 第一个值，赋值完毕之后我们把当前的组件加入到更新队列，等待更新。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>&lt;<span class="title">S</span>&gt; (<span class="params">initialState: S | (() =&gt; S)</span>): [<span class="title">S</span>, <span class="title">Dispatch</span>&lt;<span class="title">SetStateAction</span>&lt;<span class="title">S</span>&gt;&gt;] </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isFunction(initialState)) &#123; <span class="comment">// 如果 initialState 是函数</span></span><br><span class="line">    initialState = initialState() <span class="comment">// 就直接执行</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> hook = getHook() <span class="keyword">as</span> HookState&lt;S&gt; <span class="comment">// 找到该函数中对应的 hook</span></span><br><span class="line">  <span class="keyword">if</span> (isUndefined(hook.state)) &#123; <span class="comment">// 如果 hook 还没有状态</span></span><br><span class="line">    hook.component = Current.current! <span class="comment">// 正在执行的 Taro 函数，缓存起来</span></span><br><span class="line">    hook.state = [ <span class="comment">// hook.state 就是我们要返回的元组</span></span><br><span class="line">      initialState,</span><br><span class="line">      (action) =&gt; &#123;</span><br><span class="line">        hook.state[<span class="number">0</span>] = isFunction(action) ? action(hook.state[<span class="number">0</span>]) : action</span><br><span class="line">        enqueueRender(hook.component) <span class="comment">// 加入更新队列</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hook.state <span class="comment">// 已经创建 hook 就直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们把 <code>hook.state</code> 返回出去就大功告成了。</p><p>Taro 的 Hooks 总共有八个 API， <code>useState</code> 的实现大家可以发现非常简单，但其实它的代码量和复杂度是所有 Hooks 的实现中第二高的。所以其实 Hooks 也没有什么黑科技，大家可以放心大胆地使用。</p><h2 id="总结与展望" class="post-heading"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望<a class="post-anchor" href="#总结与展望" aria-hidden="true"></a></h2><p>在 2018 年 Ember.js 的作者提出过一个观点，<em>Compilers are the New Frameworks</em>，编译器即框架。什么意思呢？就拿 React 来举例，单单一个 React 其实没什么用，你还需要配合 <em>create-react-app</em>, <em>eslint-plugin-react-hooks</em>, <em>prettier</em> 等等编译相关的工具最终才能构成一个框架，而这些工具也恰巧是 React Core Team 的人创造的。而这样趋势不仅仅发生在 React 身上，大家可以发现在2018年，尤玉溪老师的主要工作就是开发 <em>vue-cli</em>。而对一些更激进的框架，例如 <em>svelte</em>，它的框架就是编译器，编译器就是框架。</p><p>而到了 2019 年，我想提出一个新概念，叫框架即生态。就拿 Taro 来说，使用 Taro 你可以复用 React 生态的东西，同时 Taro 还有 <code>taro doctor</code>，Taro 开发者社区，Taro 物料市场，还有腾讯小程序·云开发等等多个合作伙伴一起构成了 Taro 生态，而整个 Taro 生态才是框架。在过去的半年，我们持续改进并优化了 Taro 框架的表现，以上提到的特性与功能在 Taro 1.3 全部都可以正常使用。而在框架之外，我们也深耕社区，推出了 Taro 物料市场和 Taro 开发者社区，并和腾讯小程序·云开发合作举办了物料开发竞赛。现在，我们诚挚邀请你一起来参与社区贡献，让小程序开发变得更好、更快、更方便：</p><ul><li>Taro 官网：<a href="https://taro.jd.com/" target="_blank" rel="noopener">https://taro.jd.com/</a></li><li>Taro 物料市场：<a href="https://taro-ext.jd.com/" target="_blank" rel="noopener">https://taro-ext.jd.com/</a></li><li>Taro 开发者社区：<a href="https://taro-club.jd.com/" target="_blank" rel="noopener">https://taro-club.jd.com/</a></li></ul><div class="post-tags" style="display:none"><a href="/tags/小程序/">小程序</a> <a href="/tags/Taro/">Taro</a></div><div class="post-categories" style="display:none"><a href="/cates/小程序/">小程序</a></div><div class="post-announce">感谢您的阅读，本文由 <a href="//aotu.io">凹凸实验室</a> 版权所有。如若转载，请注明出处：凹凸实验室（<a href="https://aotu.io/notes/2019/07/10/taro-hooks/">https://aotu.io/notes/2019/07/10/taro-hooks/</a>）</div><div class="post-revision"><i class="fa fa-clock-o"></i> <time class="post-updated" datetime="2020-04-28T03:04:50.303Z">上次更新：2020-04-28 11:04:50</time></div></div><div class="post-nav"><div class="post-nav-next"><a href="/notes/2019/08/05/serverless/" title="serverless">serverless <i class="fa fa-chevron-right"></i></a></div><div class="post-nav-prev"><a href="/notes/2019/07/01/taro-ext-action/" title="邀您参加「Taro x 小程序·云开发」物料开发竞赛"><i class="fa fa-chevron-left"></i> 邀您参加「Taro x 小程序·云开发」物料开发竞赛</a></div></div><div class="post-comments" id="comments"></div><script>var gitalkOpts={id:"2019-07-10-taro-hooks",owner:"o2team",repo:"o2team.github.io",title:"使用 React Hooks 重构你的小程序",body:"https://aotu.io/notes/2019/07/10/taro-hooks/index.html\n\nReact Hooks 介绍，和它在小程序中的实践和实现。",clientID:"3c4d153e6874260f9c7e",clientSecret:"dd44012504c6168bc05b9266e0554bb28c62ce15",admin:["yuche"]}</script></article></div><aside class="mod-side" id="sidebar"><div class="mod-side-sec aotuwx"><img class="aotuwx-qrcode" src="/img/qrcode.jpg" alt="关注我们"><div class="aotuwx-slogan">每周推送精选技术文章</div></div><div class="mod-side-sec works"><div class="mod-side-sec-hd"><h2>服务/产品</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="//taro.jd.com" target="_blank" title="Taro">Taro</a></li><li><a href="//taro-ui.jd.com" target="_blank" title="Taro-UI">Taro-UI</a></li><li><a href="//taro-ext.jd.com" target="_blank" title="Taro 物料市场">Taro 物料市场</a></li><li><a href="//taro-club.jd.com" target="_blank" title="Taro 官方论坛">Taro 官方论坛</a></li><li><a href="//cases.aotu.io/mobi/maga.html" target="_blank" title="拇指期刊">拇指期刊</a></li><li><a href="//athena.aotu.io/" target="_blank" title="Athena">Athena</a></li><li><a href="//guide.aotu.io/" target="_blank" title="前端代码规范">前端代码规范</a></li><li><a href="//halojs.aotu.io/" target="_blank" title="HaloJS">HaloJS</a></li><li><a href="//sign.aotu.io/" target="_blank" title="邮件签名工具">邮件签名工具</a></li><li><a href="//mac.aotu.io/" target="_blank" title="MAC全栈环境">MAC全栈环境</a></li><li><a href="//xcel.aotu.io" target="_blank" title="Excel Filter">Excel Filter</a></li><li><a href="//aotu.jd.com/share/" target="_blank" title="凹凸公开课">凹凸公开课</a></li><li><a href="//at.aotu.io" target="_blank" title="AT-UI">AT-UI</a></li></ul></div></div><div class="mod-side-sec favlinks"><div class="mod-side-sec-hd"><h2>友情链接</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="https://www.cloudbase.net" target="_blank" title="小程序·云开发"><img style="width:22px;vertical-align:middle" src="https://img20.360buyimg.com/ling/jfs/t1/57175/5/15617/50216/5dca6729E00cdff5d/631622525425290e.png">小程序·云开发</a></li><li><a href="https://ling.jd.com" target="_blank" title="京东羚珑智能设计">羚珑智能设计</a></li><li><a href="https://jdc.jd.com" target="_blank" title="京东设计中心">JDC京东设计中心</a></li><li><a href="http://dopro.io/" target="_blank" title="腾讯 Deep Ocean">Deep Ocean</a></li><li><a href="http://fex.baidu.com" target="_blank" title="百度Web前端研发部">百度FEX</a></li><li><a href="http://taobaofed.org" target="_blank" title="淘宝前端团队">淘宝FED</a></li><li><a href="http://tgideas.qq.com" target="_blank" title="腾讯互娱设计中心">TGIdeas</a></li><li><a href="http://isux.tencent.com" target="_blank" title="腾讯SNG设计中心">ISUX</a></li><li><a href="http://cdc.tencent.com" target="_blank" title="腾讯用户研究与体验设计中心">CDC</a></li><li><a href="http://ued.ctrip.com" target="_blank" title="携程设计委员会">携程UED</a></li><li><a href="https://uiiiuiii.com/" target="_blank" title="优优教程网">优优教程网</a></li><li><a href="https://www.designup.cn/" target="_blank" title="Designup">Designup</a></li><li><a href="http://eux.baidu.com/" target="_blank" title="百度EUX">百度EUX</a></li></ul></div></div></aside></div></div><div class="mod-backtop" id="backTop"><i class="fa fa-long-arrow-up"></i></div><footer class="mod-ft" id="footer"><div class="grid"><ul class="mod-ft-links"><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="https://github.com/o2team/o2team.github.io" target="_blank"><i class="fa fa-github-alt"></i></a></li></ul><div class="mod-ft-sec mod-ft-copyright"><p>Designed by <a href="http://aotu.io" target="_blank">凹凸实验室</a> @<a target="_blank" href="http://jdc.jd.com">京东用户体验设计部</a></p><p>Copyright &copy; 2020. All Rights Reserved.</p><p><a href="http://www.miibeian.gov.cn/" target="_blank">粤ICP备15077732号-2</a></p></div></div></footer><script src="/js/bundle/core.js"></script><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/post_wx_share.js"></script><script src="/js/bundle/gitalk.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?e850b980d029480b092fdd7503c3f8de";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript" src="https://tajs.qq.com/stats?sId=53685723" charset="UTF-8"></script></body></html>