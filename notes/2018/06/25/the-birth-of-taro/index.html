<!DOCTYPE html><html class="theme-lattice"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>为何我们要用 React 来写小程序 - Taro 诞生记 | Aotu.io「凹凸实验室」</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="凹凸实验室"><meta name="designer" content="凹凸实验室"><meta name="rating" content="general"><meta name="format-detection" content="telephone=yes"><meta name="robots" content="index, follow"><meta baidu-gxt-verify-token="2b74a5aea155a215abea8547f929190c"><meta name="keywords" content="Taro,Nerv,小程序,React,凹凸实验室,Aotu,前端开发,全栈开发,IOS开发,Android开发"><link rel="canonical" href="https://aotu.io/notes/2018/06/25/the-birth-of-taro/index.html"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png"><link rel="icon" type="image/png" sizes="48x48" href="/img/favicon-48x48.png"><link rel="manifest" href="/img/manifest.json"><meta name="mobile-web-app-capable" content="yes"><meta name="theme-color" content="#2f83cd"><meta name="application-name" content="Aotu.io"><link rel="apple-touch-icon" sizes="57x57" href="/img/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/img/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/img/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/img/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/img/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/img/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/img/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="167x167" href="/img/apple-touch-icon-167x167.png"><link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon-180x180.png"><link rel="apple-touch-icon" sizes="1024x1024" href="/img/apple-touch-icon-1024x1024.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-mobile-web-app-title" content="Aotu.io"><meta name="msapplication-TileColor" content="#fff"><meta name="msapplication-TileImage" content="/img/mstile-144x144.png"><meta name="msapplication-config" content="/img/browserconfig.xml"><meta property="wb:webmaster" content="a1686eb81db284d5"><meta name="wechat-logo" content="http://img30.360buyimg.com/uba/jfs/t24577/94/244848194/33346/9b4ea633/5b2a15dfN4851f58f.jpg"><meta name="wechat-title" content="为何我们要用 React 来写小程序 - Taro 诞生记"><meta name="wechat-desc" content="如今，微信小程序已愈来愈热，但原生的微信小程序开发体验不尽如人意。Taro，为提升小程序开发体验而生，同时它也肩负着更重要的使命，拥有更广阔的想象空间。"><link rel="dns-prefetch" href="//storage.360buyimg.com"><link rel="dns-prefetch" href="//img10.360buyimg.com"><link rel="dns-prefetch" href="//img11.360buyimg.com"><link rel="dns-prefetch" href="//img12.360buyimg.com"><link rel="dns-prefetch" href="//img13.360buyimg.com"><link rel="dns-prefetch" href="//img14.360buyimg.com"><link rel="dns-prefetch" href="//img20.360buyimg.com"><link rel="dns-prefetch" href="//img30.360buyimg.com"><link rel="dns-prefetch" href="//misc.aotu.io"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" href="/atom.xml" title="Aotu.io"><meta name="description" content="在互联网不断发展的今天，前端程序员们也不断面临着新的挑战，在这个变化多端、不断革新自己的领域，每一年都有新的美好事物在发生。从去年微信小程序的诞生，到今年的逐渐火热，以及异军突起的轻应用、百度小程序等的出现，前端可以延伸的领域已经越来越广，当然也意味着业务在不断扩大。这时候，如何通过技术手段来提升开发效率，应对不断增长的业务，就是一个值得探索的话题。本文将对 Taro 诞生的故事，进行深入浅出"><meta name="keywords" content="React,小程序,Nerv,Taro"><meta property="og:type" content="article"><meta property="og:title" content="为何我们要用 React 来写小程序 - Taro 诞生记"><meta property="og:url" content="https://aotu.io/notes/2018/06/25/the-birth-of-taro/index.html"><meta property="og:site_name" content="Aotu.io"><meta property="og:description" content="在互联网不断发展的今天，前端程序员们也不断面临着新的挑战，在这个变化多端、不断革新自己的领域，每一年都有新的美好事物在发生。从去年微信小程序的诞生，到今年的逐渐火热，以及异军突起的轻应用、百度小程序等的出现，前端可以延伸的领域已经越来越广，当然也意味着业务在不断扩大。这时候，如何通过技术手段来提升开发效率，应对不断增长的业务，就是一个值得探索的话题。本文将对 Taro 诞生的故事，进行深入浅出"><meta property="og:locale" content="zh-cn"><meta property="og:image" content="http://img13.360buyimg.com/img/jfs/t24499/361/448655041/15273/6552407d/5b307974Nfaccdf2d.jpg"><meta property="og:image" content="http://img10.360buyimg.com/img/jfs/t23614/365/454746445/128330/71fef006/5b307975Ne1ae5de9.jpg"><meta property="og:image" content="http://img12.360buyimg.com/img/jfs/t23056/19/454899133/104795/d15cd017/5b307975Nd43ac751.jpg"><meta property="og:image" content="http://img11.360buyimg.com/img/jfs/t23071/12/457583038/19273/4ae32c30/5b307974N88af3974.jpg"><meta property="og:image" content="http://m.360buyimg.com/img/jfs/t23551/19/471755927/52473/e349bf6c/5b307975N60463097.jpg"><meta property="og:image" content="http://img30.360buyimg.com/img/jfs/t22843/37/455454462/106864/1d96f394/5b307975Nf78e5829.jpg"><meta property="og:image" content="http://img11.360buyimg.com/img/jfs/t23863/65/477773801/39493/d1292897/5b307974Na1febb30.jpg"><meta property="og:image" content="http://img14.360buyimg.com/img/jfs/t21535/241/1645070830/74027/775c8a15/5b307976Nce466138.jpg"><meta property="og:image" content="http://img30.360buyimg.com/uba/jfs/t22360/120/839096197/151922/229ceba4/5b1a6fcdNed7d4039.jpg"><meta property="og:image" content="http://img20.360buyimg.com/uba/jfs/t20197/283/1687168874/136042/2b4d811f/5b30a65cN9d1f03f1.png"><meta property="og:updated_time" content="2020-04-28T03:04:50.299Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="为何我们要用 React 来写小程序 - Taro 诞生记"><meta name="twitter:description" content="在互联网不断发展的今天，前端程序员们也不断面临着新的挑战，在这个变化多端、不断革新自己的领域，每一年都有新的美好事物在发生。从去年微信小程序的诞生，到今年的逐渐火热，以及异军突起的轻应用、百度小程序等的出现，前端可以延伸的领域已经越来越广，当然也意味着业务在不断扩大。这时候，如何通过技术手段来提升开发效率，应对不断增长的业务，就是一个值得探索的话题。本文将对 Taro 诞生的故事，进行深入浅出"><meta name="twitter:image" content="http://img13.360buyimg.com/img/jfs/t24499/361/448655041/15273/6552407d/5b307974Nfaccdf2d.jpg"><meta name="twitter:site" content="o2circle"><script>var App={root:"/",isHome:!1,isCate:!1,isTag:!1}</script><script>window.WechatShareData={imgUrl:"http://img30.360buyimg.com/uba/jfs/t24577/94/244848194/33346/9b4ea633/5b2a15dfN4851f58f.jpg",link:window.location.href,title:"为何我们要用 React 来写小程序 - Taro 诞生记",desc:"如今，微信小程序已愈来愈热，但原生的微信小程序开发体验不尽如人意。Taro，为提升小程序开发体验而生，同时它也肩负着更重要的使命，拥有更广阔的想象空间。"},window.WechatJSSDKURL="https://aotu.jd.com/aotu-wx-api/api/wx/jssdk/signature"</script></head><body class="page-post-detail"><div class="mod-hd"><div class="grid"><div class="mod-logo"><a href="/index.html" title="Aotu.io">Aotu.io</a></div><span class="mod-hd-toggle" id="J_hdToggle"><i class="fa fa-bars"></i></span><div class="mod-hd-main"><div class="mod-hd-inner"><nav class="mod-nav"><ul class="mod-nav-list"><li class="main-nav-item"><a href="/index.html" class="main-nav-link">首页</a></li><li class="main-nav-item"><a target="_blank" href="https://geeks.aotu.io" class="main-nav-link">极客沙龙</a></li><li class="main-nav-item"><a href="https://cases.aotu.io" class="main-nav-link">H5案例</a></li><li class="main-nav-item"><a href="/about/" class="main-nav-link">关于</a></li><li class="main-nav-item"><a href="/join/" class="main-nav-link">加入我们</a></li></ul></nav><div class="mod-search" id="J_search"><a class="fa fa-search mod-search-ico" id="J_searchTrigger" title="搜索"></a><form id="J_searchForm" method="get" class="mod-search-form" action="/search/"><input type="text" name="query" class="mod-search-ipt" id="J_searchInput" placeholder="搜索"></form></div></div></div></div></div><div class="mod-container"><div class="grid"><div class="mod-main typo"><article class="post"><div class="post-cover"><img src="//img20.360buyimg.com/uba/jfs/t22954/193/251445690/357583/7232c10b/5b2a15e2N23cf1e55.jpg" alt="为何我们要用 React 来写小程序 - Taro 诞生记"></div><header class="post-hd"><h1 class="post-tit">为何我们要用 React 来写小程序 - Taro 诞生记</h1><div class="post-meta">by <a target="_blank" href="https://github.com/luckyadam" class="post-author">luckyadam</a> on <span>2018-06-25</span></div><p class="post-subtit" style="display:none"><i class="fa fa-quote-left"></i>如今，微信小程序已愈来愈热，但原生的微信小程序开发体验不尽如人意。Taro，为提升小程序开发体验而生，同时它也肩负着更重要的使命，拥有更广阔的想象空间。</p><span style="display:none" id="busuanzi_value_page_pv"></span></header><div class="post-content"><a id="more"></a><blockquote><p>在互联网不断发展的今天，前端程序员们也不断面临着新的挑战，在这个变化多端、不断革新自己的领域，每一年都有新的美好事物在发生。从去年微信小程序的诞生，到今年的逐渐火热，以及异军突起的轻应用、百度小程序等的出现，前端可以延伸的领域已经越来越广，当然也意味着业务在不断扩大。这时候，如何通过技术手段来提升开发效率，应对不断增长的业务，就是一个值得探索的话题。本文将对 Taro 诞生的故事，进行深入浅出地介绍，记录下这个忙碌的春夏之交发生的故事。</p></blockquote><h2 id="让人又爱又恨的微信小程序" class="post-heading"><a href="#让人又爱又恨的微信小程序" class="headerlink" title="让人又爱又恨的微信小程序"></a>让人又爱又恨的微信小程序<a class="post-anchor" href="#让人又爱又恨的微信小程序" aria-hidden="true"></a></h2><p>自 <code>2017-1-9</code> 微信小程序（以下简称小程序）诞生以来，就伴随着赞誉与争议不断。从发布上线时的不被大多数人看好，到如今的逐渐火热，甚至说是如日中天也不为过，小程序用时间与实践证明了自己的价值。同时于开发者来说，小程序的生态不断在完善，许多的坑已被踩平，虽然还是存在一些令人诟病的问题，但已经足见微信的诚意了。这个时候要是还没有上手把玩过小程序，就显得非常OUT了。</p><p>小程序对于前端程序员来说应该算得上是福音了，用前端相关的技术，获得丝般顺滑的 <code>Native</code> 体验，前端们又可以在产品小姐姐面前硬气一把了。可以说小程序给前端程序员打开了一扇新的大门，大家都应该感谢微信，但是从开发的角度来说，小程序的开发体验就非常值得商榷了，不仅语法上显得有些不伦不类，而且有些莫名其妙的坑也经常让人不经意间感叹一下和谐社会，从市面上层出不穷的小程序开发框架就可见一斑。以下就盘点部分小程序开发的痛点。</p><h3 id="代码组织与语法" class="post-heading"><a href="#代码组织与语法" class="headerlink" title="代码组织与语法"></a>代码组织与语法<a class="post-anchor" href="#代码组织与语法" aria-hidden="true"></a></h3><p>在小程序中，一个页面 <code>page</code> 可能拥有 <code>page.js</code>、<code>page.wxss</code>、<code>page.wxml</code> 、<code>page.json</code> 四个文件</p><p><img src="http://img13.360buyimg.com/img/jfs/t24499/361/448655041/15273/6552407d/5b307974Nfaccdf2d.jpg" alt></p><p>这样在开发的时候就需要来回进行文件切换，尤其是在同时开发模板和逻辑的时候，切来切去会显得尤其麻烦，影响开发效率，但小程序原生只支持这么写，就显得比较尴尬了。</p><p>而在语法上，小程序的语法可以说既像 <code>React</code> ，又像 <code>Vue</code>，不能说显得有点不伦不类吧，但在使用上总是感觉有些别扭，对于开发者来说，等于又要学习一套新的语法，提升了学习成本。而且，小程序的模板由于没有编辑器插件的支持，书写的时候也没有智能提示与 lint 检查，书写起来显得有些麻烦。</p><h3 id="命名规范" class="post-heading"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范<a class="post-anchor" href="#命名规范" aria-hidden="true"></a></h3><p>在小程序中到处可见规范不统一的情况</p><p>例如组件的属性，以最简单的 <code>&lt;button /&gt;</code> 组件为例，在小程序官方文档中，该组件的属性部分截图如下，大家可以感受下</p><p><img src="http://img10.360buyimg.com/img/jfs/t23614/365/454746445/128330/71fef006/5b307975Ne1ae5de9.jpg" alt></p><p><code>&lt;button /&gt;</code> 组件属性名既有以中划线分割多个单词的情况 <code>session-form</code>，也有多个单词连写的情况 <code>bindgetphonenumber</code>。当然这也不是最严重的，你可以说事件绑定的规范就是 <code>bind + 事件名</code> ，而其他属性的规范就是中划线分割单词，我一度以为小程序就是这个作为标准，直到我看到了 <code>&lt;progress /&gt;</code> 组件</p><p><img src="http://img12.360buyimg.com/img/jfs/t23056/19/454899133/104795/d15cd017/5b307975Nd43ac751.jpg" alt></p><p>这和说好的不一样啊喂！</p><p><img src="http://img11.360buyimg.com/img/jfs/t23071/12/457583038/19273/4ae32c30/5b307974N88af3974.jpg" alt></p><p>同样的情况也出现在 <code>页面</code> 与 <code>组件</code> 的生命周期方法中，<code>页面</code> 的生命周期方法有 <code>onLoad</code>、<code>onReady</code>、<code>onUnload</code> 等，但到了 <code>组件</code> 中则是 <code>created</code>、<code>attached</code> 、<code>ready</code> 等，这样规范又不统一了，为啥 <code>页面</code> 的生命周期方法是 <code>on+Xxx</code> 的格式，但到了 <code>组件</code> 里缺不一样了呢，有点费解。</p><h3 id="开发方式" class="post-heading"><a href="#开发方式" class="headerlink" title="开发方式"></a>开发方式<a class="post-anchor" href="#开发方式" aria-hidden="true"></a></h3><p>小程序官方提供了 <code>微信开发工具</code> 作为开发编译工具，而对于代码本身没有提供一个类似 <code>webpack</code> 的工程化开发工具，来解决开发中的一些问题，所以小程序原生的开发方式显得不那么现代化，这也是很多小程序开发框架致力于解决的问题。例如，在小程序开发中</p><ul><li><strong>不能使用 <code>npm</code> 管理依赖</strong>，在小程序中需要手动把第三方代码文件下载到本地，然后再 <code>reuqire</code> 进行使用，显得不那么优雅</li><li><strong>不能使用 Sass 等 CSS 预处理器</strong>，由于没有预编译的概念，小程序开发中无法使用市面上流行的 CSS 预处理器，这样会使得样式代码难以管理</li><li><strong>不完整的 ES Next 语法支持</strong>，小程序默认只能支持极少一部分 ES6 规范的语法，而 ES 是不断往前发展的，一些非常优秀的新语法特性就不能使用了</li><li><strong>手动的文件处理</strong>，像图片压缩、代码压缩等等的一些文件操作，必须手工来处理，显得有些繁琐</li></ul><p>以上就是从开发者的角度看到的一些小程序的开发问题，不过纵然有千般困难，我们总要面对，作为新时代的前端开发工程师，我们不能一味忍受问题，要保持技术的头脑，以技术作为武器，用技术手段去提升的我们开发体验。</p><h2 id="突发奇想：我能不能用React来写小程序" class="post-heading"><a href="#突发奇想：我能不能用React来写小程序" class="headerlink" title="突发奇想：我能不能用React来写小程序"></a>突发奇想：我能不能用React来写小程序<a class="post-anchor" href="#突发奇想：我能不能用React来写小程序" aria-hidden="true"></a></h2><p>目前前端界言及前端框架，必离不开依然保持着统治地位的 <code>React</code> 与 <code>Vue</code>，这两个都是非常优秀的前端 UI 框架，而且在网上也经常能看到两个框架的粉丝之间热情交流，碰撞出一些思想火花，显得社区异常活跃。</p><p>而我们团队也在去年勇敢地抛弃了历史包袱，非常荣幸地引入了 <code>React</code> 开发方式，让我们团队丢掉了煤油灯，开始通上了电。而且也研发出了一款优秀的类 <code>React</code> 框架 <code>Nerv</code> ，让我们和 <code>React</code> 开发思想结合得更深。</p><p>与小程序的开发方式相比，<code>React</code> 明显显得更加现代化、规范化，而且 <code>React</code> 天生组件化更适合我们的业务开发，<code>JSX</code> 也比字符串模板有更强的表现力。那么这时候我们就在思考，我们能不能用 <code>React</code> 来写小程序？</p><h3 id="理性地探索" class="post-heading"><a href="#理性地探索" class="headerlink" title="理性地探索"></a>理性地探索<a class="post-anchor" href="#理性地探索" aria-hidden="true"></a></h3><h4 id="类比" class="post-heading"><a href="#类比" class="headerlink" title="类比"></a>类比<a class="post-anchor" href="#类比" aria-hidden="true"></a></h4><p>通过对比体验 小程序和 <code>React</code> ，我们还是能发现两者之间相似的地方</p><h5 id="生命周期" class="post-heading"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期<a class="post-anchor" href="#生命周期" aria-hidden="true"></a></h5><p>小程序的生命周期和 <code>React</code> 的生命周期，在很大程度上是类似的，我们甚至能找到他们之间的对应关系</p><p>app 及页面的生命周期</p><table><thead><tr><th>小程序</th><th style="text-align:center">React</th></tr></thead><tbody><tr><td>onLaunch</td><td style="text-align:center">componentWillMount</td></tr><tr><td>onLoad</td><td style="text-align:center">componentWillMount</td></tr><tr><td>onReady</td><td style="text-align:center">componentDidMount</td></tr><tr><td>onShow</td><td style="text-align:center">不支持，需要特殊处理</td></tr><tr><td>onHide</td><td style="text-align:center">不支持，需要特殊处理</td></tr><tr><td>onUnload</td><td style="text-align:center">componentWillUnmount</td></tr></tbody></table><p>可以看出，对于 <code>app</code> 及 <code>页面</code> 来说，除了 <code>onShow</code> 与 <code>onHide</code> 两个方法，其他方法都能在 <code>React</code> 中找到对应。</p><h5 id="数据更新方式" class="post-heading"><a href="#数据更新方式" class="headerlink" title="数据更新方式"></a>数据更新方式<a class="post-anchor" href="#数据更新方式" aria-hidden="true"></a></h5><p>在 <code>React</code> 中，组件的内部数据是用 <code>state</code> 来进行管理的，而在小程序中组件的内部数据都是用 <code>data</code> 来进行管理，两者具有一定相似性。而同时在 <code>React</code> 中，我们更新数据使用的是 <code>setState</code> 方法，传入新的数据或者生成新数据的函数，从而更新相应视图。在小程序中，则对应的有 <code>setData</code> 方法，传入新的数据，从而更新视图。</p><p>两者都是以数据驱动视图的方式进行更新，而且 <code>api</code> 神似。</p><h5 id="事件绑定" class="post-heading"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定<a class="post-anchor" href="#事件绑定" aria-hidden="true"></a></h5><p>小程序中绑定事件使用的是 <code>bind + 事件名</code> 的方式，例如点击事件，小程序中是 <code>bindtap</code></p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">bindtap</span>=<span class="string">"handlClick"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>而在 <code>React</code> 里，则是 <code>on + 事件名</code> 的方式，例如点击事件， <code>React</code> web 中是 <code>onClick</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;View onClick=&#123;<span class="keyword">this</span>.handlClick&#125;&gt;<span class="number">1</span>&lt;<span class="regexp">/View&gt;</span></span><br></pre></td></tr></table></figure><p>虽然看上去不一样，但其实是可以类比的，我们只需要在编译时将 <code>on + 事件名</code> 的形式编译成 <code>bind + 事件名</code> 的形式就可以了。</p><blockquote><p>如此看来，两者之间有些相似，用 <code>React</code> 来写小程序貌似是可行的，但接下来我们就发现了巨大的差异。</p></blockquote><h3 id="巨大的差异" class="post-heading"><a href="#巨大的差异" class="headerlink" title="巨大的差异"></a>巨大的差异<a class="post-anchor" href="#巨大的差异" aria-hidden="true"></a></h3><p><code>React</code> 与小程序之间最大的差异就是他们的模板了，在 <code>React</code> 中，是使用 <code>JSX</code> 来作为组件的模板的，而小程序则与 <code>Vue</code> 一样，是使用字符串模板的。这样两者之间就有着巨大的差异了。</p><p>JSX</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;View className=<span class="string">'index'</span>&gt;</span><br><span class="line">      &#123;<span class="keyword">this</span>.state.list.map(<span class="function">(<span class="params">item, idx</span>) =&gt;</span> (</span><br><span class="line">        &lt;View key=&#123;idx&#125;&gt;&#123;item&#125;&lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;Button onClick=&#123;this.goto&#125;&gt;走你&lt;/</span>Button&gt;</span><br><span class="line">    &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>小程序模板</p><figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"index"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:key</span>=<span class="string">&#123;idx&#125;</span> <span class="attr">wx:for</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123;list&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> <span class="attr">wx:for-item</span>=<span class="string">"item"</span> <span class="attr">wx:for-index</span>=<span class="string">"idx"</span>&gt;</span></span><span class="template-variable">&#123;&#123;item&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">bindtap</span>=<span class="string">"goto"</span>&gt;</span>走你<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>众所周知，<code>JSX</code> 其实本质上就是 <code>JS</code>，我们可以在里面写任意的逻辑代码，这样一来就比字符串模板的表现力与操作性要强多了，况且，小程序的字符串模板功能比较羸弱，只有一些比较基本的功能。那这样的话，要如何来实现用 <code>JSX</code> 来写小程序模板呢。</p><h3 id="编译原理的力量" class="post-heading"><a href="#编译原理的力量" class="headerlink" title="编译原理的力量"></a>编译原理的力量<a class="post-anchor" href="#编译原理的力量" aria-hidden="true"></a></h3><p>我们可以仔细来分析我们的需求，我们期望使用 <code>JSX</code> 来书写小程序模板，但小程序显然是不支持执行 <code>JSX</code> 代码的（要是支持的话，Taro 应该也就不存在了吧），我们也不能期望微信能给我们开个后门来跑 <code>JSX</code>。那么这个时候我们就想，我们要是能够将 <code>JSX</code> 编译成小程序模板就好了。</p><p>事实上在我们平时的开发中，这种编译的操作到处可见，<code>babel</code> 就是我们最常用的 <code>JS 代码编译器</code>，一般浏览器是不能支持一些非常新的语法特性的，但我们又想使用它们，这个时候就可以借助 <code>babel</code> 来将我们的高版本的 ES 代码，编译成浏览器可以运行的 ES 代码。而我们像要将 <code>JSX</code>编译成小程序模板，也是同样的道理。我们首先来了解一下 <code>Babel</code> 的运行机制。</p><p><code>Babel</code> 作为一个 <code>代码编译器</code> ，能够将 ES6/7/8 的代码编译成 ES5 的代码，其核心利用的就是计算中非常基础的编译原理知识，将输入语言代码，通过编译器执行，输出目标语言的代码。编译原理的一般过程就是，输入源程序，经过词法分析、语法分析，构造出语法树，再经过语义分析，理解程序正确与否，再对语法树做出需要的操作与优化，最终生成目标代码。</p><p><img src="http://m.360buyimg.com/img/jfs/t23551/19/471755927/52473/e349bf6c/5b307975N60463097.jpg" alt></p><p><code>Babel</code> 的编译过程亦是如此，主要包含三个阶段</p><ul><li>解析过程，在这个过程中进行词法、语法分析，以及语义分析，生成符合 <a href="https://github.com/estree/estree" target="_blank" rel="noopener">ESTree 标准</a> 虚拟语法树(AST)</li><li>转换过程，针对 AST 做出已定义好的操作，<code>babel</code> 的配置文件 <code>.babelrc</code> 中定义的 <code>preset</code> 、 <code>plugin</code> 就是在这一步中执行并改变 AST 的</li><li>生成过程，将前一步转换好的 AST 生成目标代码的字符串</li></ul><p>为了更好地理解这些过程，大家可以利用 <a href="https://astexplorer.net/" target="_blank" rel="noopener">Ast Explorer</a> 这个网站接一下自己的代码，感受一下每一部分代码所对应的 AST 结构。</p><p><img src="http://img30.360buyimg.com/img/jfs/t22843/37/455454462/106864/1d96f394/5b307975Nf78e5829.jpg" alt></p><p>可以看到，一份源码经过编译器解析后，会变成类似如下的结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">"Program"</span>,</span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  end: <span class="number">78</span>,</span><br><span class="line">  loc: &#123; start, end &#125;</span><br><span class="line">  sourceType: <span class="string">"module"</span>,</span><br><span class="line">  body: [</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">"VariableDeclaration"</span>, ... &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">"VariableDeclaration"</span>, ... &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">"FunctionDeclaration"</span>, ... &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">"ExpressionStatement"</span>, ... &#125;</span><br><span class="line">  ]</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>body</code> 里包含的就是我们示例代码的语法树结构，第一个 <code>VariableDeclaration</code> 对应的是 <code>const a = 1</code>，第三个 <code>FunctionDeclaration</code> 对应的则是 <code>function sum (a, b) { }</code>，分别就是 JS 中的变量定义与函数定义，每一个树节点里都会包含许多子节点，这样就形成了一个树形结构，更多的节点类型，请参考 <a href="https://github.com/babel/babel/tree/master/packages/babel-types" target="_blank" rel="noopener">babel types</a>。</p><p>当然我们在这儿只是简单介绍下编译原理与 <code>babel</code>，编译原理是一门非常深奥的课程， <code>babel</code> 也是一个非常优秀的工具，希望在后续的文章中能和大家再详细探讨这一部分内容。</p><p>再次回到我们的需求，将 <code>JSX</code> 编译成小程序模板，非常幸运的是 <code>babel</code> 的核心编译器 <code>babylon</code> 是支持对 <code>JSX</code> 语法的解析的，我们可以直接利用它来帮我们构造 AST，而我们需要专注的核心就是如何对 AST 进行转换操作，得出我们需要的新 AST，再将新 AST 进行递归遍历，生成小程序的模板。</p><p><code>JSX</code> 代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;View className=<span class="string">'index'</span>&gt;</span><br><span class="line">  &lt;Button className=<span class="string">'add_btn'</span> onClick=&#123;<span class="keyword">this</span>.props.add&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line">  &lt;Button className=<span class="string">'dec_btn'</span> onClick=&#123;<span class="keyword">this</span>.props.dec&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line">  &lt;Button className=<span class="string">'dec_btn'</span> onClick=&#123;<span class="keyword">this</span>.props.asyncAdd&#125;&gt;<span class="keyword">async</span>&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;View&gt;&#123;this.props.counter.num&#125;&lt;/</span>View&gt;</span><br><span class="line">  &lt;A /&gt;</span><br><span class="line">  &lt;Button onClick=&#123;<span class="keyword">this</span>.goto&#125;&gt;走你&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;Image src=&#123;sd&#125; /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/View&gt;</span></span><br></pre></td></tr></table></figure><p>编译生成小程序模板</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">import</span> <span class="attr">src</span>=<span class="string">"../../components/A/A.wxml"</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">block</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"index"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"add_btn"</span> <span class="attr">bindtap</span>=<span class="string">"add"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"dec_btn"</span> <span class="attr">bindtap</span>=<span class="string">"dec"</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"dec_btn"</span> <span class="attr">bindtap</span>=<span class="string">"asyncAdd"</span>&gt;</span>async<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><span class="template-variable">&#123;&#123;counter.num&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">is</span>=<span class="string">"A"</span> <span class="attr">data</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123;...$$A&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">"goto"</span>&gt;</span>走你<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123;sd&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这时候，聪明的你应该就能发现问题的难点所在了，要知道小程序的模板只是字符串，而 <code>JSX</code> 则是真正的 JS 代码扩展，其语法之丰富，显然不是字符串模板所能比，在这一步中，我们要做的操作，包括但不仅限于如下</p><ul><li>理解三目运算符与逻辑表达式，例如三目运算符 <code>abc ? : &lt;View&gt;1&lt;/View&gt; : &lt;View&gt;2&lt;/View&gt;</code> 需要编译成 <code>&lt;view wx:if=&quot;&quot;&gt;1&lt;/view&gt;&lt;view wx:else&gt;2&lt;/view&gt;</code></li><li>理解数组 <code>map</code> 语法，例如 <code>map</code> 的使用 <code>abc.map(item =&gt; &lt;View&gt;item&lt;/View&gt;)</code> 需要编译成 <code>&lt;view wx:for=&quot;&quot; wx:for-item=&quot;item&quot;&gt;item&lt;/view&gt;</code></li><li>等等</li></ul><p>以上仅仅是我们转换规则的冰山一角，<code>JSX</code> 的写法极其灵活多变，我们只能通过穷举的方式，将常用的、React 官方推荐的写法作为转换规则加以支持，而一些比较生僻的，或者是不那么推荐的写的写法则不做支持，转而以 <code>eslint</code> 插件的方式，提示用户进行修改。目前我们支持的 <code>JSX</code> 转换规则，大致能覆盖到 <code>JSX</code> 80% 的写法操作。</p><p>关于 JSX 转小程序模板这一部分，我们将在后续的技术原理分析系列文章中，详细为大家介绍。</p><h2 id="还能不能干点别的" class="post-heading"><a href="#还能不能干点别的" class="headerlink" title="还能不能干点别的"></a>还能不能干点别的<a class="post-anchor" href="#还能不能干点别的" aria-hidden="true"></a></h2><p>经过我们一次次的探索，以及一波波猛如虎的操作，我们已经可以将类 React 代码转成小程序可以跑的代码了，也就是说我们已经可以正式以 React 的方式来写小程序的代码了。喜大普奔！但是我们激动之余，冷静下来继续思考，我们还能不能干点别的有意思的事情呢。</p><h3 id="分析一下需求" class="post-heading"><a href="#分析一下需求" class="headerlink" title="分析一下需求"></a>分析一下需求<a class="post-anchor" href="#分析一下需求" aria-hidden="true"></a></h3><p>我们发现，在平常的工作中，我们业务通常有一些多端的需求，就是要求小程序要有，H5 要有，甚至 RN 也能有就最好了，我猜产品经理还看不上快应用，不然肯定要求我们快应用也上一套吧，反正你们不是经常号称代码优秀、高度可复用么。这个时候，你就会发现，差不多的界面和逻辑，你可能需要重复写上好几轮，这时候要是有个多端代码生成工具就好了，只写一份代码，可以多端运行。Write once, run anywhere，相信是所有工程师的梦想。</p><h3 id="依然编译原理的力量" class="post-heading"><a href="#依然编译原理的力量" class="headerlink" title="依然编译原理的力量"></a>依然编译原理的力量<a class="post-anchor" href="#依然编译原理的力量" aria-hidden="true"></a></h3><p>这时候我们回忆一下前文的内容，将一份代码编译成多端代码，这不正是编译原理干的事么，我们可以输入一份源代码，针对不同的端设定好对应的转换规则，再一键转换出对应端的代码。而且由于我们已经遵循 React 语法了，那我们再转成 H5 端（使用 Nerv）与 RN 端（使用 React）也就有了天然的优势。</p><p><img src="http://img11.360buyimg.com/img/jfs/t23863/65/477773801/39493/d1292897/5b307974Na1febb30.jpg" alt></p><h3 id="设计思路补完" class="post-heading"><a href="#设计思路补完" class="headerlink" title="设计思路补完"></a>设计思路补完<a class="post-anchor" href="#设计思路补完" aria-hidden="true"></a></h3><p>但是仔细思考我们又会发现，仅仅将代码按照对应语法规则转换过去后，还远远不够，因为不同端会有自己的原生组件，端能力 API 等等，代码直接转换过去后，可能不能直接执行。例如，小程序中普通的容器组件用的是 <code>&lt;view /&gt;</code>，而在 H5 中则是 <code>&lt;div /&gt;</code>；小程序中提供了丰富的端能力 API，例如网络请求、文件下载、数据缓存等，而在 H5 中对应功能的 API 则不一致。</p><p>所以，为了弥补不同端的差异，我们需要订制好一个统一的组件库标准，以及统一的 API 标准，在不同的端依靠它们的语法与能力去实现这个组件库与 API，同时还要为不同的端编写相应的运行时框架，负责初始化等等操作。通过以上这些操作，我们就能实现一份一键生成多端的需求了。在 Taro 最初的设计中，我们组件库与 API 的标准就是源自小程序的，因为我们觉得既然已经有定义好的组件库与 API 标准，那为啥不直接拿来使用呢，这样不仅省去了定制标准的冥思苦想，同时也省去了为小程序开发组件库与 API 的麻烦，只需要让其他端来向小程序靠齐就好。</p><p>可能有些人会有疑问，既然是为不同的端实现了对应的组件库与端能力 API （小程序除外，因为组件库和 API 的标准都是源自小程序），那么是怎么能够只写一份代码就够了呢？因为我们有编译的操作，在书写代码的时候，只需要引入标准组件库 <code>@tarojs/components</code> 与运行时框架 <code>@tarojs/taro</code> ，代码经过编译之后，会变成对应端所需要的库。</p><p><img src="http://img14.360buyimg.com/img/jfs/t21535/241/1645070830/74027/775c8a15/5b307976Nce466138.jpg" alt></p><p>既然组件库以及端能力都是依靠不同的端做不同实现来抹平差异，那么同样的，如果我们想为 Taro 引入更多的功能支持的话，有时候也需要按照这个套路来。例如，为了提升开发便利性，我们为 Taro 加入了 <code>Redux</code> 支持，我们的做法就是，在小程序端，我们实现了 <code>@tarojs/redux</code> 这个库来作为小程序的 <code>Redux</code> 辅助库，并且以他作为基准库，它具有和 <code>react-redux</code> 一致的 API，在书写代码的时候，引用的都是 <code>@tarojs/redux</code> ，经过编译后，在 H5 端会替换成 <code>nerv-redux</code>（<code>Nerv</code>的 <code>Redux</code> 辅助库），在 RN 端会替换成 <code>react-redux</code>。这样就实现了 <code>Redux</code> 在 Taro 中的多端支持。</p><p><img src="http://img30.360buyimg.com/uba/jfs/t22360/120/839096197/151922/229ceba4/5b1a6fcdNed7d4039.jpg" alt></p><p>以上就是 Taro 的整体设计思路，里面还有很多细节没有展开去阐述，可能大家会觉得有些意犹未尽，后续我们将会产出一系列的文章来阐述 Taro 的技术细节，例如 《Taro 开发工具原理分析》、《Taro 代码编译的背后》、《深入浅出 JSX 转小程序模板》等等。</p><h2 id="最后的最后" class="post-heading"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后<a class="post-anchor" href="#最后的最后" aria-hidden="true"></a></h2><p>Taro 从立项之初到现在已经差不多有了三个月左右的时间，从最初的激烈讨论方案，各种思想的碰撞，到方案逐渐成型，进入火热的开发迭代，再到现在的小程序端和 H5 端顺利支持，从而决定走向开源。这一路走来，收获颇丰，既有跟团队小伙伴一起创造的激动，也有无数个日夜加班的苦思。Taro 是凹凸实验室的诚意之作，我们也将会一直维护下去，希望 Taro 能越来越好，帮助更多人创造更多价值。</p><p>项目官网：<a href="https://taro.aotu.io/" target="_blank" rel="noopener">https://taro.aotu.io/</a></p><p>项目 GitHub：<a href="https://github.com/NervJS/taro" target="_blank" rel="noopener">https://github.com/NervJS/taro</a></p><p><strong>同时，有任何关于 Taro 希望沟通交流的，欢迎~</strong></p><p><img src="http://img20.360buyimg.com/uba/jfs/t20197/283/1687168874/136042/2b4d811f/5b30a65cN9d1f03f1.png" alt></p><div class="post-tags" style="display:none"><a href="/tags/React/">React</a> <a href="/tags/小程序/">小程序</a> <a href="/tags/Nerv/">Nerv</a> <a href="/tags/Taro/">Taro</a></div><div class="post-categories" style="display:none"><a href="/cates/小程序/">小程序</a></div><div class="post-announce">感谢您的阅读，本文由 <a href="//aotu.io">凹凸实验室</a> 版权所有。如若转载，请注明出处：凹凸实验室（<a href="https://aotu.io/notes/2018/06/25/the-birth-of-taro/">https://aotu.io/notes/2018/06/25/the-birth-of-taro/</a>）</div><div class="post-revision"><i class="fa fa-clock-o"></i> <time class="post-updated" datetime="2020-04-28T03:04:50.299Z">上次更新：2020-04-28 11:04:50</time></div></div><div class="post-nav"><div class="post-nav-next"><a href="/notes/2018/08/27/the-birth-of-taro-ui/" title="首个多端 UI 组件库 - Taro UI 发布">首个多端 UI 组件库 - Taro UI 发布 <i class="fa fa-chevron-right"></i></a></div><div class="post-nav-prev"><a href="/notes/2018/06/07/Taro/" title="多端统一开发框架 - Taro"><i class="fa fa-chevron-left"></i> 多端统一开发框架 - Taro</a></div></div><div class="post-comments" id="comments"></div><script>var gitalkOpts={id:"bm90ZXMvMjAxOC8wNi8yNS90aGUtYmlydGgtb2YtdGFyby8=",owner:"o2team",repo:"o2team.github.io",title:"为何我们要用 React 来写小程序 - Taro 诞生记",body:"https://aotu.io/notes/2018/06/25/the-birth-of-taro/index.html\n\n如今，微信小程序已愈来愈热，但原生的微信小程序开发体验不尽如人意。Taro，为提升小程序开发体验而生，同时它也肩负着更重要的使命，拥有更广阔的想象空间。",clientID:"3c4d153e6874260f9c7e",clientSecret:"dd44012504c6168bc05b9266e0554bb28c62ce15",admin:["luckyadam"]}</script></article></div><aside class="mod-side" id="sidebar"><div class="mod-side-sec aotuwx"><img class="aotuwx-qrcode" src="/img/qrcode.jpg" alt="关注我们"><div class="aotuwx-slogan">每周推送精选技术文章</div></div><div class="mod-side-sec works"><div class="mod-side-sec-hd"><h2>服务/产品</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="//taro.jd.com" target="_blank" title="Taro">Taro</a></li><li><a href="//taro-ui.jd.com" target="_blank" title="Taro-UI">Taro-UI</a></li><li><a href="//taro-ext.jd.com" target="_blank" title="Taro 物料市场">Taro 物料市场</a></li><li><a href="//taro-club.jd.com" target="_blank" title="Taro 官方论坛">Taro 官方论坛</a></li><li><a href="//cases.aotu.io/mobi/maga.html" target="_blank" title="拇指期刊">拇指期刊</a></li><li><a href="//athena.aotu.io/" target="_blank" title="Athena">Athena</a></li><li><a href="//guide.aotu.io/" target="_blank" title="前端代码规范">前端代码规范</a></li><li><a href="//halojs.aotu.io/" target="_blank" title="HaloJS">HaloJS</a></li><li><a href="//sign.aotu.io/" target="_blank" title="邮件签名工具">邮件签名工具</a></li><li><a href="//mac.aotu.io/" target="_blank" title="MAC全栈环境">MAC全栈环境</a></li><li><a href="//xcel.aotu.io" target="_blank" title="Excel Filter">Excel Filter</a></li><li><a href="//aotu.jd.com/share/" target="_blank" title="凹凸公开课">凹凸公开课</a></li><li><a href="//at.aotu.io" target="_blank" title="AT-UI">AT-UI</a></li></ul></div></div><div class="mod-side-sec favlinks"><div class="mod-side-sec-hd"><h2>友情链接</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="https://www.cloudbase.net" target="_blank" title="小程序·云开发"><img style="width:22px;vertical-align:middle" src="https://img20.360buyimg.com/ling/jfs/t1/57175/5/15617/50216/5dca6729E00cdff5d/631622525425290e.png">小程序·云开发</a></li><li><a href="https://ling.jd.com" target="_blank" title="京东羚珑智能设计">羚珑智能设计</a></li><li><a href="https://jdc.jd.com" target="_blank" title="京东设计中心">JDC京东设计中心</a></li><li><a href="http://dopro.io/" target="_blank" title="腾讯 Deep Ocean">Deep Ocean</a></li><li><a href="http://fex.baidu.com" target="_blank" title="百度Web前端研发部">百度FEX</a></li><li><a href="http://taobaofed.org" target="_blank" title="淘宝前端团队">淘宝FED</a></li><li><a href="http://tgideas.qq.com" target="_blank" title="腾讯互娱设计中心">TGIdeas</a></li><li><a href="http://isux.tencent.com" target="_blank" title="腾讯SNG设计中心">ISUX</a></li><li><a href="http://cdc.tencent.com" target="_blank" title="腾讯用户研究与体验设计中心">CDC</a></li><li><a href="http://ued.ctrip.com" target="_blank" title="携程设计委员会">携程UED</a></li><li><a href="https://uiiiuiii.com/" target="_blank" title="优优教程网">优优教程网</a></li><li><a href="https://www.designup.cn/" target="_blank" title="Designup">Designup</a></li><li><a href="http://eux.baidu.com/" target="_blank" title="百度EUX">百度EUX</a></li></ul></div></div></aside></div></div><div class="mod-backtop" id="backTop"><i class="fa fa-long-arrow-up"></i></div><footer class="mod-ft" id="footer"><div class="grid"><ul class="mod-ft-links"><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="https://github.com/o2team/o2team.github.io" target="_blank"><i class="fa fa-github-alt"></i></a></li></ul><div class="mod-ft-sec mod-ft-copyright"><p>Designed by <a href="http://aotu.io" target="_blank">凹凸实验室</a> @<a target="_blank" href="http://jdc.jd.com">京东用户体验设计部</a></p><p>Copyright &copy; 2020. All Rights Reserved.</p><p><a href="http://www.miibeian.gov.cn/" target="_blank">粤ICP备15077732号-2</a></p></div></div></footer><script src="/js/bundle/core.js"></script><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/post_wx_share.js"></script><script src="/js/bundle/gitalk.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?e850b980d029480b092fdd7503c3f8de";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript" src="https://tajs.qq.com/stats?sId=53685723" charset="UTF-8"></script></body></html>